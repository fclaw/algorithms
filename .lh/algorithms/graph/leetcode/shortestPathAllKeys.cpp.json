{
    "sourceFile": "algorithms/graph/leetcode/shortestPathAllKeys.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 64,
            "patches": [
                {
                    "date": 1725884953511,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725884965633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,9 @@\n \n \n namespace algorithms::graph::leetcode::shortest_path_all_keys\n {\n-    \n+\n+    /**\n+     * \n+     */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885127841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,7 +3,21 @@\n namespace algorithms::graph::leetcode::shortest_path_all_keys\n {\n \n     /**\n-     * \n+     * https://leetcode.com/problems/shortest-path-to-get-all-keys\n+     * You are given an m x n grid grid where:\n+\n+'.' is an empty cell.\n+'#' is a wall.\n+'@' is the starting point.\n+Lowercase letters represent keys.\n+Uppercase letters represent locks.\n+You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n+\n+If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n+\n+For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n+\n+Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n      */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885134662,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,11 +5,10 @@\n \n     /**\n      * https://leetcode.com/problems/shortest-path-to-get-all-keys\n      * You are given an m x n grid grid where:\n-\n-'.' is an empty cell.\n-'#' is a wall.\n+     * '.' is an empty cell.\n+     * '#' is a wall.\n '@' is the starting point.\n Lowercase letters represent keys.\n Uppercase letters represent locks.\n You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n"
                },
                {
                    "date": 1725885142365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,11 +7,11 @@\n      * https://leetcode.com/problems/shortest-path-to-get-all-keys\n      * You are given an m x n grid grid where:\n      * '.' is an empty cell.\n      * '#' is a wall.\n-'@' is the starting point.\n-Lowercase letters represent keys.\n-Uppercase letters represent locks.\n+     * '@' is the starting point.\n+     * Lowercase letters represent keys.\n+     * Uppercase letters represent locks.\n You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n \n If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n \n"
                },
                {
                    "date": 1725885151359,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,23 @@\n+\n+\n+namespace algorithms::graph::leetcode::shortest_path_all_keys\n+{\n+\n+    /**\n+     * https://leetcode.com/problems/shortest-path-to-get-all-keys\n+     * You are given an m x n grid grid where:\n+     * '.' is an empty cell.\n+     * '#' is a wall.\n+     * '@' is the starting point.\n+     * Lowercase letters represent keys.\n+     * Uppercase letters represent locks.\n+     * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n+     * You cannot walk outside the grid, or walk into a wall.\n+\n+If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n+\n+For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n+\n+Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n+     */\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885163380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,35 +11,11 @@\n      * '@' is the starting point.\n      * Lowercase letters represent keys.\n      * Uppercase letters represent locks.\n      * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n-     * You cannot walk outside the grid, or walk into a wall.\n+     * You cannot walk outside the grid, or walk into a wall. If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n \n-If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n-\n For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n \n Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n      */\n-}\n-\n-\n-namespace algorithms::graph::leetcode::shortest_path_all_keys\n-{\n-\n-    /**\n-     * https://leetcode.com/problems/shortest-path-to-get-all-keys\n-     * You are given an m x n grid grid where:\n-     * '.' is an empty cell.\n-     * '#' is a wall.\n-     * '@' is the starting point.\n-     * Lowercase letters represent keys.\n-     * Uppercase letters represent locks.\n-You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n-\n-If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n-\n-For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n-\n-Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n-     */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885168626,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,10 @@\n      * '@' is the starting point.\n      * Lowercase letters represent keys.\n      * Uppercase letters represent locks.\n      * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n-     * You cannot walk outside the grid, or walk into a wall. If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n+     * You cannot walk outside the grid, or walk into a wall. \n+     * If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n \n For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n \n Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n"
                },
                {
                    "date": 1725885174888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,10 +13,9 @@\n      * Uppercase letters represent locks.\n      * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n      * You cannot walk outside the grid, or walk into a wall. \n      * If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n+     * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n \n-For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n-\n Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n      */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885183648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,22 @@\n+\n+\n+namespace algorithms::graph::leetcode::shortest_path_all_keys\n+{\n+\n+    /**\n+     * https://leetcode.com/problems/shortest-path-to-get-all-keys\n+     * You are given an m x n grid grid where:\n+     * '.' is an empty cell.\n+     * '#' is a wall.\n+     * '@' is the starting point.\n+     * Lowercase letters represent keys.\n+     * Uppercase letters represent locks.\n+     * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n+     * You cannot walk outside the grid, or walk into a wall. \n+     * If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n+     * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of \n+     * the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n+\n+Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n+     */\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885192562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,30 +14,11 @@\n      * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n      * You cannot walk outside the grid, or walk into a wall. \n      * If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n      * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of \n-     * the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n+     * the first k letters of the English alphabet in the grid. \n+     * This means that there is exactly one key for each lock, and one lock for each key; \n+     * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n \n Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n      */\n-}\n-\n-\n-namespace algorithms::graph::leetcode::shortest_path_all_keys\n-{\n-\n-    /**\n-     * https://leetcode.com/problems/shortest-path-to-get-all-keys\n-     * You are given an m x n grid grid where:\n-     * '.' is an empty cell.\n-     * '#' is a wall.\n-     * '@' is the starting point.\n-     * Lowercase letters represent keys.\n-     * Uppercase letters represent locks.\n-     * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n-     * You cannot walk outside the grid, or walk into a wall. \n-     * If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n-     * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n-\n-Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n-     */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885205844,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,8 +17,7 @@\n      * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of \n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n-\n Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n      */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885222012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,7 +17,7 @@\n      * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of \n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n-Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n+     * Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n      */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885239543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,7 +17,9 @@\n      * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of \n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n-     * Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n-     */\n+     * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n+    int shortestPathAllKeys(vector<string>& grid) {\n+        \n+    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885257593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+#include <vector>\n+#include <string>\n \n \n namespace algorithms::graph::leetcode::shortest_path_all_keys\n {\n"
                },
                {
                    "date": 1725885264940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,8 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int shortestPathAllKeys(vector<string>& grid) {\n+    int shortestPathAllKeys(std::vector<string>& grid) {\n         \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885273365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,8 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int shortestPathAllKeys(std::vector<string>& grid) {\n+    int shortestPathAllKeys(const std::vector<std::string>& grid) {\n         \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885281441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int shortestPathAllKeys(const std::vector<std::string>& grid) {\n-        \n+    int shortestPathAllKeys(const std::vector<std::string>& grid) \n+    {\n+        return 1;    \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725885288740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,10 @@\n \n namespace algorithms::graph::leetcode::shortest_path_all_keys\n {\n \n+using grid = \n+\n     /**\n      * https://leetcode.com/problems/shortest-path-to-get-all-keys\n      * You are given an m x n grid grid where:\n      * '.' is an empty cell.\n"
                },
                {
                    "date": 1725885297928,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n namespace algorithms::graph::leetcode::shortest_path_all_keys\n {\n \n-using grid = \n+using grid = std::vector<std::string>;\n \n     /**\n      * https://leetcode.com/problems/shortest-path-to-get-all-keys\n      * You are given an m x n grid grid where:\n"
                },
                {
                    "date": 1725885303561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int shortestPathAllKeys(const std::vector<std::string>& grid) \n+    int shortestPathAllKeys(const grid& g) \n     {\n         return 1;    \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725890673258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,31 @@\n+#include <vector>\n+#include <string>\n+\n+\n+namespace algorithms::graph::leetcode::shortest_path_all_keys\n+{\n+\n+using grid = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/shortest-path-to-get-all-keys\n+     * You are given an m x n grid grid where:\n+     * '.' is an empty cell.\n+     * '#' is a wall.\n+     * '@' is the starting point.\n+     * Lowercase letters represent keys.\n+     * Uppercase letters represent locks.\n+     * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n+     * You cannot walk outside the grid, or walk into a wall. \n+     * If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n+     * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of \n+     * the first k letters of the English alphabet in the grid. \n+     * This means that there is exactly one key for each lock, and one lock for each key; \n+     * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n+     * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n+    \n+    int shortestPathAllKeys(const grid& g) \n+    {\n+        return 1;    \n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725890680107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,40 +22,10 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    \n+    int bfs()\n     int shortestPathAllKeys(const grid& g) \n     {\n         return 1;    \n     }\n-}\n-#include <vector>\n-#include <string>\n-\n-\n-namespace algorithms::graph::leetcode::shortest_path_all_keys\n-{\n-\n-using grid = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/shortest-path-to-get-all-keys\n-     * You are given an m x n grid grid where:\n-     * '.' is an empty cell.\n-     * '#' is a wall.\n-     * '@' is the starting point.\n-     * Lowercase letters represent keys.\n-     * Uppercase letters represent locks.\n-     * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n-     * You cannot walk outside the grid, or walk into a wall. \n-     * If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n-     * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of \n-     * the first k letters of the English alphabet in the grid. \n-     * This means that there is exactly one key for each lock, and one lock for each key; \n-     * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n-     * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int shortestPathAllKeys(const grid& g) \n-    {\n-        return 1;    \n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725890688070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int bfs()\n+    int bfs(const grid& g, )\n     int shortestPathAllKeys(const grid& g) \n     {\n         return 1;    \n     }\n"
                },
                {
                    "date": 1725890694677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int bfs(const grid& g, )\n+    int bfs(const grid& g, std::string source, )\n     int shortestPathAllKeys(const grid& g) \n     {\n         return 1;    \n     }\n"
                },
                {
                    "date": 1725890709260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,9 @@\n namespace algorithms::graph::leetcode::shortest_path_all_keys\n {\n \n using grid = std::vector<std::string>;\n+using cell = std::string;\n \n     /**\n      * https://leetcode.com/problems/shortest-path-to-get-all-keys\n      * You are given an m x n grid grid where:\n@@ -22,9 +23,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int bfs(const grid& g, std::string source, )\n+    int bfs(const grid& g, std::string source, std::string )\n     int shortestPathAllKeys(const grid& g) \n     {\n         return 1;    \n     }\n"
                },
                {
                    "date": 1725890714993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int bfs(const grid& g, std::string source, std::string )\n+    int bfs(const grid& g,  source, std::string )\n     int shortestPathAllKeys(const grid& g) \n     {\n         return 1;    \n     }\n"
                },
                {
                    "date": 1725890720888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int bfs(const grid& g,  source, std::string )\n+    int bfs(const grid& g, const cell source, std::string )\n     int shortestPathAllKeys(const grid& g) \n     {\n         return 1;    \n     }\n"
                },
                {
                    "date": 1725890731418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int bfs(const grid& g, const cell source, std::string )\n+    int bfs(const grid& g, const cell& source, const cell& sink )\n     int shortestPathAllKeys(const grid& g) \n     {\n         return 1;    \n     }\n"
                },
                {
                    "date": 1725890757317,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    int bfs(const grid& g, const cell& source, const cell& sink )\n+    int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g) \n     {\n         return 1;    \n     }\n"
                },
                {
                    "date": 1725890768412,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,10 +23,12 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n+    int M, N;\n+    \n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n-    int shortestPathAllKeys(const grid& g) \n+    int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725890780793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,11 @@\n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n     int M, N;\n-    \n+    dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n+    bool checkBoundary(int r, int c) \n+    { return r >= 0 && r < M && c >= 0 && c < N; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n"
                },
                {
                    "date": 1725890793152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,9 @@\n {\n \n using grid = std::vector<std::string>;\n using cell = std::string;\n+using dir = std::vector<std::pair<int, int>>;\n \n     /**\n      * https://leetcode.com/problems/shortest-path-to-get-all-keys\n      * You are given an m x n grid grid where:\n@@ -25,9 +26,9 @@\n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n-    bool checkBoundary(int r, int c) \n+    bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n"
                },
                {
                    "date": 1725890807784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,8 +24,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n+    const std::string \n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n"
                },
                {
                    "date": 1725890815413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    const std::string \n+    const std::string PlAYER = \"\"\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n"
                },
                {
                    "date": 1725890821002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    const std::string PlAYER = \"\"\n+    const std::string PlAYER = \"\";\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n"
                },
                {
                    "date": 1725890828865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n      * the first k letters of the English alphabet in the grid. \n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    const std::string PlAYER = \"\";\n+    const std::string PlAYER = \"@\";\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n"
                },
                {
                    "date": 1725890834072,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,8 +25,9 @@\n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n     const std::string PlAYER = \"@\";\n+    const std::string \n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n"
                },
                {
                    "date": 1725890843246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,9 @@\n      * This means that there is exactly one key for each lock, and one lock for each key; \n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n     const std::string PlAYER = \"@\";\n-    const std::string \n+    const std::string WALL = \"#\";\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n"
                },
                {
                    "date": 1725890868032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,9 @@\n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n     const std::string PlAYER = \"@\";\n     const std::string WALL = \"#\";\n+    const std::string EMPTY = \".\"\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n"
                },
                {
                    "date": 1725890931316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n      * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n      * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n     const std::string PlAYER = \"@\";\n     const std::string WALL = \"#\";\n-    const std::string EMPTY = \".\"\n+    const std::string EMPTY = \".\";\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n"
                },
                {
                    "date": 1725890941046,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,8 +32,9 @@\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n+    \n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n     }\n"
                },
                {
                    "date": 1725891108396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,8 @@\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n-    \n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n     }\n"
                },
                {
                    "date": 1725891116913,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,9 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n+    keyToInt()\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n"
                },
                {
                    "date": 1725891122962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    keyToInt()\n+    keyToInt(std::string k) {  }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n"
                },
                {
                    "date": 1725891128156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    keyToInt(std::string k) {  }\n+    int keyToInt(std::string k) {  }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n"
                },
                {
                    "date": 1725891137414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,8 +32,9 @@\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int keyToInt(std::string k) {  }\n+    int lockToInt\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n"
                },
                {
                    "date": 1725891146247,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int keyToInt(std::string k) {  }\n-    int lockToInt\n+    int lockToInt(const cell& lock)\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n"
                },
                {
                    "date": 1725891153287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,10 +31,10 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    int keyToInt(std::string k) {  }\n-    int lockToInt(const cell& lock)\n+    int keyToInt(const cell& k) {  }\n+    int lockToInt(const cell& lock) {}\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n"
                },
                {
                    "date": 1725891190009,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    int keyToInt(const cell& k) {  }\n+    int keyToInt(const cell& key) { std::sto }\n     int lockToInt(const cell& lock) {}\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n"
                },
                {
                    "date": 1725891195503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    int keyToInt(const cell& key) { std::sto }\n+    int keyToInt(const cell& key) { std::stoi(key) }\n     int lockToInt(const cell& lock) {}\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n"
                },
                {
                    "date": 1725891225861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    int keyToInt(const cell& key) { std::stoi(key) }\n+    int keyToInt(const cell& key) { std::stoi(key) - 97; }\n     int lockToInt(const cell& lock) {}\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n"
                },
                {
                    "date": 1725891239128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,10 +31,10 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    int keyToInt(const cell& key) { std::stoi(key) - 97; }\n-    int lockToInt(const cell& lock) {}\n+    int keyToInt(const cell& key) { return std::stoi(key) - 97; }\n+    int lockToInt(const cell& lock) { return std::stoi(key) - 97; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n"
                },
                {
                    "date": 1725891251236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int keyToInt(const cell& key) { return std::stoi(key) - 97; }\n-    int lockToInt(const cell& lock) { return std::stoi(key) - 97; }\n+    int lockToInt(const cell& lock) { return std::stoi(lock) - ; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;    \n"
                },
                {
                    "date": 1725891352018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,12 +31,12 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    int keyToInt(const cell& key) { return std::stoi(key) - 97; }\n-    int lockToInt(const cell& lock) { return std::stoi(lock) - ; }\n+    int keyToInt(const cell& key) { return std::stoi(key); }\n+    int lockToInt(const cell& lock) { return std::stoi(lock) - 65; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n-        return 1;    \n+        return 1;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725891366735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    int keyToInt(const cell& key) { return std::stoi(key); }\n+    int keyToInt(const cell& key) { return std::stoi(key[0]); }\n     int lockToInt(const cell& lock) { return std::stoi(lock) - 65; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n"
                },
                {
                    "date": 1725891372807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    int keyToInt(const cell& key) { return std::stoi(key[0]); }\n+    int keyToInt(const cell& key) { return std::stoi((int)key[0] - 97); }\n     int lockToInt(const cell& lock) { return std::stoi(lock) - 65; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n"
                },
                {
                    "date": 1725891378948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,42 @@\n+#include <vector>\n+#include <string>\n+\n+\n+namespace algorithms::graph::leetcode::shortest_path_all_keys\n+{\n+\n+using grid = std::vector<std::string>;\n+using cell = std::string;\n+using dir = std::vector<std::pair<int, int>>;\n+\n+    /**\n+     * https://leetcode.com/problems/shortest-path-to-get-all-keys\n+     * You are given an m x n grid grid where:\n+     * '.' is an empty cell.\n+     * '#' is a wall.\n+     * '@' is the starting point.\n+     * Lowercase letters represent keys.\n+     * Uppercase letters represent locks.\n+     * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n+     * You cannot walk outside the grid, or walk into a wall. \n+     * If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n+     * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of \n+     * the first k letters of the English alphabet in the grid. \n+     * This means that there is exactly one key for each lock, and one lock for each key; \n+     * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n+     * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n+    const std::string PlAYER = \"@\";\n+    const std::string WALL = \"#\";\n+    const std::string EMPTY = \".\";\n+    int M, N;\n+    dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n+    bool checkBoundary(int r, int c)\n+    { return r >= 0 && r < M && c >= 0 && c < N; }\n+    int keyToInt(const cell& key) { return (int)key[0] - 97; }\n+    int lockToInt(const cell& lock) { return std::stoi(lock) - 65; }\n+    int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n+    int shortestPathAllKeys(const grid& g)\n+    {\n+        return 1;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725891438107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,53 +32,11 @@\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int keyToInt(const cell& key) { return (int)key[0] - 97; }\n-    int lockToInt(const cell& lock) { return std::stoi(lock) - 65; }\n+    int lockToInt(const cell& lock) { return (int)key[0] - 97; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;\n     }\n-}\n-#include <vector>\n-#include <string>\n-\n-\n-namespace algorithms::graph::leetcode::shortest_path_all_keys\n-{\n-\n-using grid = std::vector<std::string>;\n-using cell = std::string;\n-using dir = std::vector<std::pair<int, int>>;\n-\n-    /**\n-     * https://leetcode.com/problems/shortest-path-to-get-all-keys\n-     * You are given an m x n grid grid where:\n-     * '.' is an empty cell.\n-     * '#' is a wall.\n-     * '@' is the starting point.\n-     * Lowercase letters represent keys.\n-     * Uppercase letters represent locks.\n-     * You start at the starting point and one move consists of walking one space in one of the four cardinal directions. \n-     * You cannot walk outside the grid, or walk into a wall. \n-     * If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n-     * For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of \n-     * the first k letters of the English alphabet in the grid. \n-     * This means that there is exactly one key for each lock, and one lock for each key; \n-     * and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n-     * Return the lowest number of moves to acquire all keys. If it is impossible, return -1. */\n-    const std::string PlAYER = \"@\";\n-    const std::string WALL = \"#\";\n-    const std::string EMPTY = \".\";\n-    int M, N;\n-    dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n-    bool checkBoundary(int r, int c)\n-    { return r >= 0 && r < M && c >= 0 && c < N; }\n-    int keyToInt(const cell& key) { return std::stoi((int)key[0] - 97); }\n-    int lockToInt(const cell& lock) { return std::stoi(lock) - 65; }\n-    int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n-    int shortestPathAllKeys(const grid& g)\n-    {\n-        return 1;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725891447658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int keyToInt(const cell& key) { return (int)key[0] - 97; }\n-    int lockToInt(const cell& lock) { return (int)key[0] - 97; }\n+    int lockToInt(const cell& lock) { return (int)lock[0] - 65; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;\n"
                },
                {
                    "date": 1725891474958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,8 +34,9 @@\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int keyToInt(const cell& key) { return (int)key[0] - 97; }\n     int lockToInt(const cell& lock) { return (int)lock[0] - 65; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n+    \n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;\n     }\n"
                },
                {
                    "date": 1725891488689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int keyToInt(const cell& key) { return (int)key[0] - 97; }\n     int lockToInt(const cell& lock) { return (int)lock[0] - 65; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n-    \n+    int calculateMinPath()\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;\n     }\n"
                },
                {
                    "date": 1725891494627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n     int keyToInt(const cell& key) { return (int)key[0] - 97; }\n     int lockToInt(const cell& lock) { return (int)lock[0] - 65; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n-    int calculateMinPath()\n+    int calculateMinPath(const grid& g)\n     int shortestPathAllKeys(const grid& g)\n     {\n         return 1;\n     }\n"
                },
                {
                    "date": 1725891504434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,7 +37,7 @@\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int calculateMinPath(const grid& g) { return 1; }\n     int shortestPathAllKeys(const grid& g)\n     {\n-        return 1;\n+        return calculateMinPath(g);\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725891558495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     int M, N;\n     dir dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n     bool checkBoundary(int r, int c)\n     { return r >= 0 && r < M && c >= 0 && c < N; }\n-    int keyToInt(const cell& key) { return (int)key[0] - 97; }\n+    int keyToInt(const std::string& key) { return (int)key[0] - 97; }\n     int lockToInt(const cell& lock) { return (int)lock[0] - 65; }\n     int bfs(const grid& g, const cell& source, const cell& sink) { return 0; }\n     int calculateMinPath(const grid& g) { return 1; }\n     int shortestPathAllKeys(const grid& g)\n"
                }
            ],
            "date": 1725884953511,
            "name": "Commit-0",
            "content": "\n\nnamespace algorithms::graph::leetcode::shortest_path_all_keys\n{\n    \n}"
        }
    ]
}