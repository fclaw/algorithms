{
    "sourceFile": "algorithms/graph/leetcode/canFinish.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 55,
            "patches": [
                {
                    "date": 1723215123146,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1723215133360,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,4 @@\n-namespace algorithms::graph::leetcode::\n\\ No newline at end of file\n+namespace algorithms::graph::leetcode::can_finish\n+{\n+    \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723215139547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,4 @@\n namespace algorithms::graph::leetcode::can_finish\n {\n-    \n+    // https://leetcode.com/problems/course-schedule/\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723216145744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,8 @@\n namespace algorithms::graph::leetcode::can_finish\n {\n-    // https://leetcode.com/problems/course-schedule/\n+    // https://leetcode.com/problems/course-schedule\n+    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n+        \n+    }\n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723216152979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,9 @@\n namespace algorithms::graph::leetcode::can_finish\n {\n+\n+\n+\n     // https://leetcode.com/problems/course-schedule\n     bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n         \n     }\n"
                },
                {
                    "date": 1723216163960,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n namespace algorithms::graph::leetcode::can_finish\n {\n \n+using graph = \n \n-\n     // https://leetcode.com/problems/course-schedule\n     bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n         \n     }\n"
                },
                {
                    "date": 1723216169475,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n namespace algorithms::graph::leetcode::can_finish\n {\n \n-using graph = \n+using graph = vector<vector<int>>\n \n     // https://leetcode.com/problems/course-schedule\n     bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n         \n"
                },
                {
                    "date": 1723216176098,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n namespace algorithms::graph::leetcode::can_finish\n {\n \n-using graph = vector<vector<int>>\n+using graph = std::vector<std::vector<int>>;\n \n     // https://leetcode.com/problems/course-schedule\n     bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n         \n"
                },
                {
                    "date": 1723216185282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+#include <\n+\n namespace algorithms::graph::leetcode::can_finish\n {\n \n using graph = std::vector<std::vector<int>>;\n"
                },
                {
                    "date": 1723216196817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,13 @@\n-#include <\n+#include <vector>\n \n namespace algorithms::graph::leetcode::can_finish\n {\n \n using graph = std::vector<std::vector<int>>;\n \n     // https://leetcode.com/problems/course-schedule\n-    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n+    bool canFinish(int numCourses, const & prerequisites) {\n         \n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723216204620,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,10 @@\n \n using graph = std::vector<std::vector<int>>;\n \n     // https://leetcode.com/problems/course-schedule\n-    bool canFinish(int numCourses, const & prerequisites) {\n+    bool canFinish(int numCourses, const graph& prerequisites) \n+    {\n         \n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723216224877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,10 +5,15 @@\n \n using graph = std::vector<std::vector<int>>;\n \n     // https://leetcode.com/problems/course-schedule\n+    /**\n+     * There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n+\n+For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n+Return true if you can finish all courses. Otherwise, return false.\n+     */\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n-        \n+\n     }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723216232459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,10 @@\n using graph = std::vector<std::vector<int>>;\n \n     // https://leetcode.com/problems/course-schedule\n     /**\n-     * There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n+     * There are a total of numCourses courses you have to take, \n+     * labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n \n For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n Return true if you can finish all courses. Otherwise, return false.\n      */\n"
                },
                {
                    "date": 1723216242833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,10 @@\n \n     // https://leetcode.com/problems/course-schedule\n     /**\n      * There are a total of numCourses courses you have to take, \n-     * labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n+     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n+     * where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n \n For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n Return true if you can finish all courses. Otherwise, return false.\n      */\n"
                },
                {
                    "date": 1723216251705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,10 @@\n     // https://leetcode.com/problems/course-schedule\n     /**\n      * There are a total of numCourses courses you have to take, \n      * labeled from 0 to numCourses - 1. You are given an array prerequisites \n-     * where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n+     * where prerequisites[i] = [ai, bi] \n+     * indicates that you must take course bi first if you want to take course ai.\n \n For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n Return true if you can finish all courses. Otherwise, return false.\n      */\n"
                },
                {
                    "date": 1723216272083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,11 +10,10 @@\n      * There are a total of numCourses courses you have to take, \n      * labeled from 0 to numCourses - 1. You are given an array prerequisites \n      * where prerequisites[i] = [ai, bi] \n      * indicates that you must take course bi first if you want to take course ai.\n-\n-For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n-Return true if you can finish all courses. Otherwise, return false.\n+     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n+     * Return true if you can finish all courses. Otherwise, return false.\n      */\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n"
                },
                {
                    "date": 1723216278588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,22 @@\n+#include <vector>\n+\n+namespace algorithms::graph::leetcode::can_finish\n+{\n+\n+using graph = std::vector<std::vector<int>>;\n+\n+    // https://leetcode.com/problems/course-schedule\n+    /**\n+     * There are a total of numCourses courses you have to take, \n+     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n+     * where prerequisites[i] = [ai, bi] \n+     * indicates that you must take course bi first if you want to take course ai.\n+     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n+     * Return true if you can finish all courses. Otherwise, return false.\n+     * \n+     */\n+    bool canFinish(int numCourses, const graph& prerequisites) \n+    {\n+\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723216284685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,22 @@\n+#include <vector>\n+\n+namespace algorithms::graph::leetcode::can_finish\n+{\n+\n+using graph = std::vector<std::vector<int>>;\n+\n+    // https://leetcode.com/problems/course-schedule\n+    /**\n+     * There are a total of numCourses courses you have to take, \n+     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n+     * where prerequisites[i] = [ai, bi] \n+     * indicates that you must take course bi first if you want to take course ai.\n+     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n+     * Return true if you can finish all courses. Otherwise, return false.\n+     * topological sort\n+     */\n+    bool canFinish(int numCourses, const graph& prerequisites) \n+    {\n+\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723216291328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,22 @@\n+#include <vector>\n+\n+namespace algorithms::graph::leetcode::can_finish\n+{\n+\n+using graph = std::vector<std::vector<int>>;\n+\n+    // https://leetcode.com/problems/course-schedule\n+    /**\n+     * There are a total of numCourses courses you have to take, \n+     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n+     * where prerequisites[i] = [ai, bi] \n+     * indicates that you must take course bi first if you want to take course ai.\n+     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n+     * Return true if you can finish all courses. Otherwise, return false.\n+     *  topological sort\n+     */\n+    bool canFinish(int numCourses, const graph& prerequisites) \n+    {\n+\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723217138577,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,76 +12,11 @@\n      * where prerequisites[i] = [ai, bi] \n      * indicates that you must take course bi first if you want to take course ai.\n      * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n      * Return true if you can finish all courses. Otherwise, return false.\n-     *  topological sort\n+     * tag: topological sort\n      */\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n-\n+        \n     }\n-}\n-#include <vector>\n-\n-namespace algorithms::graph::leetcode::can_finish\n-{\n-\n-using graph = std::vector<std::vector<int>>;\n-\n-    // https://leetcode.com/problems/course-schedule\n-    /**\n-     * There are a total of numCourses courses you have to take, \n-     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n-     * where prerequisites[i] = [ai, bi] \n-     * indicates that you must take course bi first if you want to take course ai.\n-     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n-     * Return true if you can finish all courses. Otherwise, return false.\n-     * topological sort\n-     */\n-    bool canFinish(int numCourses, const graph& prerequisites) \n-    {\n-\n-    }\n-}\n-#include <vector>\n-\n-namespace algorithms::graph::leetcode::can_finish\n-{\n-\n-using graph = std::vector<std::vector<int>>;\n-\n-    // https://leetcode.com/problems/course-schedule\n-    /**\n-     * There are a total of numCourses courses you have to take, \n-     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n-     * where prerequisites[i] = [ai, bi] \n-     * indicates that you must take course bi first if you want to take course ai.\n-     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n-     * Return true if you can finish all courses. Otherwise, return false.\n-     * \n-     */\n-    bool canFinish(int numCourses, const graph& prerequisites) \n-    {\n-\n-    }\n-}\n-#include <vector>\n-\n-namespace algorithms::graph::leetcode::can_finish\n-{\n-\n-using graph = std::vector<std::vector<int>>;\n-\n-    // https://leetcode.com/problems/course-schedule\n-    /**\n-     * There are a total of numCourses courses you have to take, \n-     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n-     * where prerequisites[i] = [ai, bi] \n-     * indicates that you must take course bi first if you want to take course ai.\n-     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n-     * Return true if you can finish all courses. Otherwise, return false.\n-     */\n-    bool canFinish(int numCourses, const graph& prerequisites) \n-    {\n-\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223375602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,10 @@\n      * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n      * Return true if you can finish all courses. Otherwise, return false.\n      * tag: topological sort\n      */\n+    enum \n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n-        \n+\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223395851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n      * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n      * Return true if you can finish all courses. Otherwise, return false.\n      * tag: topological sort\n      */\n-    enum \n+    enum S\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n"
                },
                {
                    "date": 1723223401880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n      * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n      * Return true if you can finish all courses. Otherwise, return false.\n      * tag: topological sort\n      */\n-    enum S\n+    enum S {  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n"
                },
                {
                    "date": 1723223420451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,8 +13,12 @@\n      * indicates that you must take course bi first if you want to take course ai.\n      * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n      * Return true if you can finish all courses. Otherwise, return false.\n      * tag: topological sort\n+     * The idea is to go through the nodes of the graph and always begin a depth-first search at the current node if it has not been processed yet. During the searches, the nodes have three possible states:\n+• state0:thenodehasnotbeenprocessed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n+Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n+If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n"
                },
                {
                    "date": 1723223432005,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,10 @@\n      * indicates that you must take course bi first if you want to take course ai.\n      * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n      * Return true if you can finish all courses. Otherwise, return false.\n      * tag: topological sort\n-     * The idea is to go through the nodes of the graph and always begin a depth-first search at the current node if it has not been processed yet. During the searches, the nodes have three possible states:\n+     * The idea is to go through the nodes of the graph and \n+     * always begin a depth-first search at the current node if it has not been processed yet. During the searches, the nodes have three possible states:\n • state0:thenodehasnotbeenprocessed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n"
                },
                {
                    "date": 1723223442313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,10 +14,11 @@\n      * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n      * Return true if you can finish all courses. Otherwise, return false.\n      * tag: topological sort\n      * The idea is to go through the nodes of the graph and \n-     * always begin a depth-first search at the current node if it has not been processed yet. During the searches, the nodes have three possible states:\n-• state0:thenodehasnotbeenprocessed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n+     * always begin a depth-first search at the current node if it has not been processed yet. \n+     * During the searches, the nodes have three possible states:\n+• state0 : thenodehasnotbeenprocessed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n"
                },
                {
                    "date": 1723223448480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n      * tag: topological sort\n      * The idea is to go through the nodes of the graph and \n      * always begin a depth-first search at the current node if it has not been processed yet. \n      * During the searches, the nodes have three possible states:\n-• state0 : thenodehasnotbeenprocessed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n+     * 0 : thenodehasnotbeenprocessed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n"
                },
                {
                    "date": 1723223455788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n      * tag: topological sort\n      * The idea is to go through the nodes of the graph and \n      * always begin a depth-first search at the current node if it has not been processed yet. \n      * During the searches, the nodes have three possible states:\n-     * 0 : thenodehasnotbeenprocessed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n+     * 0 : the nodehasnotbeenprocessed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n"
                },
                {
                    "date": 1723223461069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n      * tag: topological sort\n      * The idea is to go through the nodes of the graph and \n      * always begin a depth-first search at the current node if it has not been processed yet. \n      * During the searches, the nodes have three possible states:\n-     * 0 : the nodehasnotbeenprocessed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n+     * 0 : the node has not been processed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n"
                },
                {
                    "date": 1723223469248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,10 @@\n      * tag: topological sort\n      * The idea is to go through the nodes of the graph and \n      * always begin a depth-first search at the current node if it has not been processed yet. \n      * During the searches, the nodes have three possible states:\n-     * 0 : the node has not been processed(white) • state1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n+     * 0 : the node has not been processed (white) \n+     * 1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n"
                },
                {
                    "date": 1723223475630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,9 @@\n      * The idea is to go through the nodes of the graph and \n      * always begin a depth-first search at the current node if it has not been processed yet. \n      * During the searches, the nodes have three possible states:\n      * 0 : the node has not been processed (white) \n-     * 1:thenodeisunderprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n+     * 1 : the node is underprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n"
                },
                {
                    "date": 1723223482568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,30 @@\n+#include <vector>\n+\n+namespace algorithms::graph::leetcode::can_finish\n+{\n+\n+using graph = std::vector<std::vector<int>>;\n+\n+    // https://leetcode.com/problems/course-schedule\n+    /**\n+     * There are a total of numCourses courses you have to take, \n+     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n+     * where prerequisites[i] = [ai, bi] \n+     * indicates that you must take course bi first if you want to take course ai.\n+     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n+     * Return true if you can finish all courses. Otherwise, return false.\n+     * tag: topological sort\n+     * The idea is to go through the nodes of the graph and \n+     * always begin a depth-first search at the current node if it has not been processed yet. \n+     * During the searches, the nodes have three possible states:\n+     * 0 : the node has not been processed (white) \n+     * 1 : the node is under processing (light gray) • state2:thenodehasbeenprocessed(darkgray)\n+Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n+If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n+     */\n+    enum S {  }\n+    bool canFinish(int numCourses, const graph& prerequisites) \n+    {\n+\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223488622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,44 +17,15 @@\n      * The idea is to go through the nodes of the graph and \n      * always begin a depth-first search at the current node if it has not been processed yet. \n      * During the searches, the nodes have three possible states:\n      * 0 : the node has not been processed (white) \n-     * 1 : the node is under processing (light gray) • state2:thenodehasbeenprocessed(darkgray)\n+     * 1 : the node is under processing (light gray) \n+     * 2 : thenodehasbeenprocessed(darkgray)\n Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n-}\n-#include <vector>\n-\n-namespace algorithms::graph::leetcode::can_finish\n-{\n-\n-using graph = std::vector<std::vector<int>>;\n-\n-    // https://leetcode.com/problems/course-schedule\n-    /**\n-     * There are a total of numCourses courses you have to take, \n-     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n-     * where prerequisites[i] = [ai, bi] \n-     * indicates that you must take course bi first if you want to take course ai.\n-     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n-     * Return true if you can finish all courses. Otherwise, return false.\n-     * tag: topological sort\n-     * The idea is to go through the nodes of the graph and \n-     * always begin a depth-first search at the current node if it has not been processed yet. \n-     * During the searches, the nodes have three possible states:\n-     * 0 : the node has not been processed (white) \n-     * 1 : the node is underprocessing(lightgray) • state2:thenodehasbeenprocessed(darkgray)\n-Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n-If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n-     */\n-    enum S {  }\n-    bool canFinish(int numCourses, const graph& prerequisites) \n-    {\n-\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223494078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,31 @@\n+#include <vector>\n+\n+namespace algorithms::graph::leetcode::can_finish\n+{\n+\n+using graph = std::vector<std::vector<int>>;\n+\n+    // https://leetcode.com/problems/course-schedule\n+    /**\n+     * There are a total of numCourses courses you have to take, \n+     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n+     * where prerequisites[i] = [ai, bi] \n+     * indicates that you must take course bi first if you want to take course ai.\n+     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n+     * Return true if you can finish all courses. Otherwise, return false.\n+     * tag: topological sort\n+     * The idea is to go through the nodes of the graph and \n+     * always begin a depth-first search at the current node if it has not been processed yet. \n+     * During the searches, the nodes have three possible states:\n+     * 0 : the node has not been processed (white) \n+     * 1 : the node is under processing (light gray) \n+     * 2 : the node has been processed(darkgray)\n+Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n+If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n+     */\n+    enum S {  }\n+    bool canFinish(int numCourses, const graph& prerequisites) \n+    {\n+\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223508882,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,45 +18,14 @@\n      * always begin a depth-first search at the current node if it has not been processed yet. \n      * During the searches, the nodes have three possible states:\n      * 0 : the node has not been processed (white) \n      * 1 : the node is under processing (light gray) \n-     * 2 : the node has been processed(darkgray)\n-Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n+     * 2 : the node has been processed (dark gray)\n+     * Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n-}\n-#include <vector>\n-\n-namespace algorithms::graph::leetcode::can_finish\n-{\n-\n-using graph = std::vector<std::vector<int>>;\n-\n-    // https://leetcode.com/problems/course-schedule\n-    /**\n-     * There are a total of numCourses courses you have to take, \n-     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n-     * where prerequisites[i] = [ai, bi] \n-     * indicates that you must take course bi first if you want to take course ai.\n-     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n-     * Return true if you can finish all courses. Otherwise, return false.\n-     * tag: topological sort\n-     * The idea is to go through the nodes of the graph and \n-     * always begin a depth-first search at the current node if it has not been processed yet. \n-     * During the searches, the nodes have three possible states:\n-     * 0 : the node has not been processed (white) \n-     * 1 : the node is under processing (light gray) \n-     * 2 : thenodehasbeenprocessed(darkgray)\n-Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n-If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n-     */\n-    enum S {  }\n-    bool canFinish(int numCourses, const graph& prerequisites) \n-    {\n-\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223517911,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,10 @@\n      * During the searches, the nodes have three possible states:\n      * 0 : the node has not been processed (white) \n      * 1 : the node is under processing (light gray) \n      * 2 : the node has been processed (dark gray)\n-     * Initially, the state of each node is 0. When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n+     * Initially, the state of each node is 0. \n+     * When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n"
                },
                {
                    "date": 1723223528666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,10 @@\n      * 0 : the node has not been processed (white) \n      * 1 : the node is under processing (light gray) \n      * 2 : the node has been processed (dark gray)\n      * Initially, the state of each node is 0. \n-     * When a search reaches a node for the first time, its state becomes 1. Finally, after all edges from the node have been processed, its state becomes 2.\n+     * When a search reaches a node for the first time, its state becomes 1. \n+     * Finally, after all edges from the node have been processed, its state becomes 2.\n If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n"
                },
                {
                    "date": 1723223537201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n      * 2 : the node has been processed (dark gray)\n      * Initially, the state of each node is 0. \n      * When a search reaches a node for the first time, its state becomes 1. \n      * Finally, after all edges from the node have been processed, its state becomes 2.\n-If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n+     * If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n"
                },
                {
                    "date": 1723223543906,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,10 @@\n      * 2 : the node has been processed (dark gray)\n      * Initially, the state of each node is 0. \n      * When a search reaches a node for the first time, its state becomes 1. \n      * Finally, after all edges from the node have been processed, its state becomes 2.\n-     * If the graph contains a cycle, we will discover this during the search, because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n+     * If the graph contains a cycle, we will discover this during the search, \n+     * because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n"
                },
                {
                    "date": 1723223549079,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,10 @@\n      * Initially, the state of each node is 0. \n      * When a search reaches a node for the first time, its state becomes 1. \n      * Finally, after all edges from the node have been processed, its state becomes 2.\n      * If the graph contains a cycle, we will discover this during the search, \n-     * because sooner or later we will arrive at a node whose state is 1. In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n+     * because sooner or later we will arrive at a node whose state is 1. \n+     * In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n"
                },
                {
                    "date": 1723223560931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,37 @@\n+#include <vector>\n+\n+namespace algorithms::graph::leetcode::can_finish\n+{\n+\n+using graph = std::vector<std::vector<int>>;\n+\n+    // https://leetcode.com/problems/course-schedule\n+    /**\n+     * There are a total of numCourses courses you have to take, \n+     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n+     * where prerequisites[i] = [ai, bi] \n+     * indicates that you must take course bi first if you want to take course ai.\n+     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n+     * Return true if you can finish all courses. Otherwise, return false.\n+     * tag: topological sort\n+     * The idea is to go through the nodes of the graph and \n+     * always begin a depth-first search at the current node if it has not been processed yet. \n+     * During the searches, the nodes have three possible states:\n+     * 0 : the node has not been processed (white) \n+     * 1 : the node is under processing (light gray) \n+     * 2 : the node has been processed (dark gray)\n+     * Initially, the state of each node is 0. \n+     * When a search reaches a node for the first time, its state becomes 1. \n+     * Finally, after all edges from the node have been processed, its state becomes 2.\n+     * If the graph contains a cycle, we will discover this during the search, \n+     * because sooner or later we will arrive at a node whose state is 1. \n+     * In this case, it is not possible to construct a topological sort. \n+     * If the graph does not contain a cycle, we can construct a topological sort \n+     * by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n+     */\n+    enum S {  }\n+    bool canFinish(int numCourses, const graph& prerequisites) \n+    {\n+\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223578699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,47 +26,13 @@\n      * If the graph contains a cycle, we will discover this during the search, \n      * because sooner or later we will arrive at a node whose state is 1. \n      * In this case, it is not possible to construct a topological sort. \n      * If the graph does not contain a cycle, we can construct a topological sort \n-     * by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n+     * by adding each node to a list when its state becomes 2. \n+     * Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S {  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n-}\n-#include <vector>\n-\n-namespace algorithms::graph::leetcode::can_finish\n-{\n-\n-using graph = std::vector<std::vector<int>>;\n-\n-    // https://leetcode.com/problems/course-schedule\n-    /**\n-     * There are a total of numCourses courses you have to take, \n-     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n-     * where prerequisites[i] = [ai, bi] \n-     * indicates that you must take course bi first if you want to take course ai.\n-     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n-     * Return true if you can finish all courses. Otherwise, return false.\n-     * tag: topological sort\n-     * The idea is to go through the nodes of the graph and \n-     * always begin a depth-first search at the current node if it has not been processed yet. \n-     * During the searches, the nodes have three possible states:\n-     * 0 : the node has not been processed (white) \n-     * 1 : the node is under processing (light gray) \n-     * 2 : the node has been processed (dark gray)\n-     * Initially, the state of each node is 0. \n-     * When a search reaches a node for the first time, its state becomes 1. \n-     * Finally, after all edges from the node have been processed, its state becomes 2.\n-     * If the graph contains a cycle, we will discover this during the search, \n-     * because sooner or later we will arrive at a node whose state is 1. \n-     * In this case, it is not possible to construct a topological sort. If the graph does not contain a cycle, we can construct a topological sort by adding each node to a list when its state becomes 2. Finally, we reverse the list and get a topological sort for the graph.\n-     */\n-    enum S {  }\n-    bool canFinish(int numCourses, const graph& prerequisites) \n-    {\n-\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223633677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n      * If the graph does not contain a cycle, we can construct a topological sort \n      * by adding each node to a list when its state becomes 2. \n      * Finally, we reverse the list and get a topological sort for the graph.\n      */\n-    enum S {  }\n+    enum S { NotPicked = 0,  }\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n"
                },
                {
                    "date": 1723223640381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n      * If the graph does not contain a cycle, we can construct a topological sort \n      * by adding each node to a list when its state becomes 2. \n      * Finally, we reverse the list and get a topological sort for the graph.\n      */\n-    enum S { NotPicked = 0,  }\n+    enum S { NotPicked = 0, S }\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n"
                },
                {
                    "date": 1723223647563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,38 @@\n+#include <vector>\n+\n+namespace algorithms::graph::leetcode::can_finish\n+{\n+\n+using graph = std::vector<std::vector<int>>;\n+\n+    // https://leetcode.com/problems/course-schedule\n+    /**\n+     * There are a total of numCourses courses you have to take, \n+     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n+     * where prerequisites[i] = [ai, bi] \n+     * indicates that you must take course bi first if you want to take course ai.\n+     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n+     * Return true if you can finish all courses. Otherwise, return false.\n+     * tag: topological sort\n+     * The idea is to go through the nodes of the graph and \n+     * always begin a depth-first search at the current node if it has not been processed yet. \n+     * During the searches, the nodes have three possible states:\n+     * 0 : the node has not been processed (white) \n+     * 1 : the node is under processing (light gray) \n+     * 2 : the node has been processed (dark gray)\n+     * Initially, the state of each node is 0. \n+     * When a search reaches a node for the first time, its state becomes 1. \n+     * Finally, after all edges from the node have been processed, its state becomes 2.\n+     * If the graph contains a cycle, we will discover this during the search, \n+     * because sooner or later we will arrive at a node whose state is 1. \n+     * In this case, it is not possible to construct a topological sort. \n+     * If the graph does not contain a cycle, we can construct a topological sort \n+     * by adding each node to a list when its state becomes 2. \n+     * Finally, we reverse the list and get a topological sort for the graph.\n+     */\n+    enum S { NotPicked = 0, Picked = 1, Proc }\n+    bool canFinish(int numCourses, const graph& prerequisites) \n+    {\n+\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223652907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,48 +29,10 @@\n      * If the graph does not contain a cycle, we can construct a topological sort \n      * by adding each node to a list when its state becomes 2. \n      * Finally, we reverse the list and get a topological sort for the graph.\n      */\n-    enum S { NotPicked = 0, Picked = 1, Proc }\n+    enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n-}\n-#include <vector>\n-\n-namespace algorithms::graph::leetcode::can_finish\n-{\n-\n-using graph = std::vector<std::vector<int>>;\n-\n-    // https://leetcode.com/problems/course-schedule\n-    /**\n-     * There are a total of numCourses courses you have to take, \n-     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n-     * where prerequisites[i] = [ai, bi] \n-     * indicates that you must take course bi first if you want to take course ai.\n-     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n-     * Return true if you can finish all courses. Otherwise, return false.\n-     * tag: topological sort\n-     * The idea is to go through the nodes of the graph and \n-     * always begin a depth-first search at the current node if it has not been processed yet. \n-     * During the searches, the nodes have three possible states:\n-     * 0 : the node has not been processed (white) \n-     * 1 : the node is under processing (light gray) \n-     * 2 : the node has been processed (dark gray)\n-     * Initially, the state of each node is 0. \n-     * When a search reaches a node for the first time, its state becomes 1. \n-     * Finally, after all edges from the node have been processed, its state becomes 2.\n-     * If the graph contains a cycle, we will discover this during the search, \n-     * because sooner or later we will arrive at a node whose state is 1. \n-     * In this case, it is not possible to construct a topological sort. \n-     * If the graph does not contain a cycle, we can construct a topological sort \n-     * by adding each node to a list when its state becomes 2. \n-     * Finally, we reverse the list and get a topological sort for the graph.\n-     */\n-    enum S { NotPicked = 0, S }\n-    bool canFinish(int numCourses, const graph& prerequisites) \n-    {\n-\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223660022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,7 +32,7 @@\n      */\n     enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n-\n+        \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723223667259,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,7 +32,7 @@\n      */\n     enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n-        \n+         \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723224250732,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,10 @@\n      * by adding each node to a list when its state becomes 2. \n      * Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n+    void \n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n-         \n+\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723224262106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n      * by adding each node to a list when its state becomes 2. \n      * Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n-    void \n+    void convert\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n"
                },
                {
                    "date": 1723224268038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n      * by adding each node to a list when its state becomes 2. \n      * Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n-    void convert\n+    void convertToAdjList\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n"
                },
                {
                    "date": 1723224281012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n      * by adding each node to a list when its state becomes 2. \n      * Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n-    void convertToAdjList\n+    void convertToAdjList(const graph& )\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n"
                },
                {
                    "date": 1723224294147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n      * by adding each node to a list when its state becomes 2. \n      * Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n-    void convertToAdjList(const graph& )\n+    graph convertToAdjList(const graph& g)\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n"
                },
                {
                    "date": 1723224302437,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,8 @@\n      * by adding each node to a list when its state becomes 2. \n      * Finally, we reverse the list and get a topological sort for the graph.\n      */\n     enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n-    graph convertToAdjList(const graph& g)\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n \n     }\n"
                },
                {
                    "date": 1723224307871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,7 +32,7 @@\n      */\n     enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n     bool canFinish(int numCourses, const graph& prerequisites) \n     {\n-        \n+        graph \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1723224317362,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,38 @@\n+#include <vector>\n+\n+namespace algorithms::graph::leetcode::can_finish\n+{\n+\n+using graph = std::vector<std::vector<int>>;\n+\n+    // https://leetcode.com/problems/course-schedule\n+    /**\n+     * There are a total of numCourses courses you have to take, \n+     * labeled from 0 to numCourses - 1. You are given an array prerequisites \n+     * where prerequisites[i] = [ai, bi] \n+     * indicates that you must take course bi first if you want to take course ai.\n+     * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n+     * Return true if you can finish all courses. Otherwise, return false.\n+     * tag: topological sort\n+     * The idea is to go through the nodes of the graph and \n+     * always begin a depth-first search at the current node if it has not been processed yet. \n+     * During the searches, the nodes have three possible states:\n+     * 0 : the node has not been processed (white) \n+     * 1 : the node is under processing (light gray) \n+     * 2 : the node has been processed (dark gray)\n+     * Initially, the state of each node is 0. \n+     * When a search reaches a node for the first time, its state becomes 1. \n+     * Finally, after all edges from the node have been processed, its state becomes 2.\n+     * If the graph contains a cycle, we will discover this during the search, \n+     * because sooner or later we will arrive at a node whose state is 1. \n+     * In this case, it is not possible to construct a topological sort. \n+     * If the graph does not contain a cycle, we can construct a topological sort \n+     * by adding each node to a list when its state becomes 2. \n+     * Finally, we reverse the list and get a topological sort for the graph.\n+     */\n+    enum S { NotPicked = 0, Picked = 1, Processed = 2 };\n+    bool canFinish(int numCourses, const graph& prerequisites) \n+    {\n+        graph adjList;\n+    }\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1723215123146,
            "name": "Commit-0",
            "content": "namespace algorithms::graph::leetcode::"
        }
    ]
}