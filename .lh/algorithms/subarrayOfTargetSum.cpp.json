{
    "sourceFile": "algorithms/subarrayOfTargetSum.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 11,
            "patches": [
                {
                    "date": 1718553851848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1718554116995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,8 +27,9 @@\n               }\n \n               if(sum > target)\n               {\n+                  \n                   right--;\n                   left++;\n               }\n               else right++;\n"
                },
                {
                    "date": 1718554123555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n               }\n \n               if(sum > target)\n               {\n-                  \n+                  sum = sum\n                   right--;\n                   left++;\n               }\n               else right++;\n"
                },
                {
                    "date": 1718554130213,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,40 @@\n+#include <vector>\n+#include <optional>\n+\n+namespace algorithms::array\n+{\n+     /*\n+        The problem can be solved in O(n) time by using the two pointers method. \n+        The idea is to maintain pointers that point to the first and last value of a subArray. \n+        On each turn, the left pointer moves one step to the right, \n+        and the right pointer moves to the right as long as the resulting subArray sum is at most x. \n+        If the sum becomes exactly x, a solution has been found.\n+     */\n+     std::optional<std::tuple<int, int>> \n+       getSubArrayOfTargetSum(std::vector<int> nums, int target)\n+     {\n+          int n = nums.size();\n+          int left = 0;\n+          int right = 1;\n+          int sum = nums[left] + nums[right];\n+          std::optional<std::tuple<int, int>> res = std::nullopt;\n+          while(right < n)\n+          {\n+              if(sum == target)\n+              {\n+                  res = std::make_optional<std::tuple<int, int>>(left, right);\n+                  break;\n+              }\n+\n+              if(sum > target)\n+              {\n+                  sum = \n+                  right--;\n+                  left++;\n+              }\n+              else \n+              {right++;\n+          }\n+          return res;\n+     }      \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718554135925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,48 +32,11 @@\n                   right--;\n                   left++;\n               }\n               else \n-              {right++;\n-          }\n-          return res;\n-     }      \n-}\n-#include <vector>\n-#include <optional>\n-\n-namespace algorithms::array\n-{\n-     /*\n-        The problem can be solved in O(n) time by using the two pointers method. \n-        The idea is to maintain pointers that point to the first and last value of a subArray. \n-        On each turn, the left pointer moves one step to the right, \n-        and the right pointer moves to the right as long as the resulting subArray sum is at most x. \n-        If the sum becomes exactly x, a solution has been found.\n-     */\n-     std::optional<std::tuple<int, int>> \n-       getSubArrayOfTargetSum(std::vector<int> nums, int target)\n-     {\n-          int n = nums.size();\n-          int left = 0;\n-          int right = 1;\n-          int sum = nums[left] + nums[right];\n-          std::optional<std::tuple<int, int>> res = std::nullopt;\n-          while(right < n)\n-          {\n-              if(sum == target)\n               {\n-                  res = std::make_optional<std::tuple<int, int>>(left, right);\n-                  break;\n-              }\n-\n-              if(sum > target)\n-              {\n-                  sum = sum\n-                  right--;\n-                  left++;\n-              }\n-              else right++;\n+                 sum += \n+                right++;\n           }\n           return res;\n      }      \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718554141617,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,10 +33,11 @@\n                   left++;\n               }\n               else \n               {\n-                 sum += \n+                 sum += nums[right];\n                 right++;\n+              }\n           }\n           return res;\n      }      \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718554159288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,16 +27,16 @@\n               }\n \n               if(sum > target)\n               {\n-                  sum = \n+                  sum = sum - nums[left]\n                   right--;\n                   left++;\n               }\n               else \n               {\n                  sum += nums[right];\n-                right++;\n+                 right++;\n               }\n           }\n           return res;\n      }      \n"
                },
                {
                    "date": 1718554167164,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n               }\n \n               if(sum > target)\n               {\n-                  sum = sum - nums[left]\n+                  sum = sum - nums[left] - nums[]\n                   right--;\n                   left++;\n               }\n               else \n"
                },
                {
                    "date": 1718554172504,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n               }\n \n               if(sum > target)\n               {\n-                  sum = sum - nums[left] - nums[]\n+                  sum = sum - nums[left] - nums[right];\n                   right--;\n                   left++;\n               }\n               else \n"
                },
                {
                    "date": 1718554179744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,43 @@\n+#include <vector>\n+#include <optional>\n+\n+namespace algorithms::array\n+{\n+     /*\n+        The problem can be solved in O(n) time by using the two pointers method. \n+        The idea is to maintain pointers that point to the first and last value of a subArray. \n+        On each turn, the left pointer moves one step to the right, \n+        and the right pointer moves to the right as long as the resulting subArray sum is at most x. \n+        If the sum becomes exactly x, a solution has been found.\n+     */\n+     std::optional<std::tuple<int, int>> \n+       getSubArrayOfTargetSum(std::vector<int> nums, int target)\n+     {\n+          int n = nums.size();\n+          int left = 0;\n+          int right = 1;\n+          int sum = nums[left] + nums[right];\n+          std::optional<std::tuple<int, int>> res = std::nullopt;\n+          while(right < n)\n+          {\n+              if(sum == target)\n+              {\n+                  res = std::make_optional<std::tuple<int, int>>(left, right);\n+                  break;\n+              }\n+\n+              if(sum > target)\n+              {\n+                  sum = sum - nums[left] - nums[right];\n+                  right--;\n+                  left++;\n+              }\n+              else \n+              {\n+                 sum += nums[right];\n+                 right++;\n+              }\n+          }\n+          return res;\n+     }      \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718554215850,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n               }\n \n               if(sum > target)\n               {\n-                  sum = sum - nums[left] - nums[right];\n+                  sum -= (nums[left] - nums[right];\n                   right--;\n                   left++;\n               }\n               else \n@@ -39,48 +39,5 @@\n               }\n           }\n           return res;\n      }      \n-}\n-#include <vector>\n-#include <optional>\n-\n-namespace algorithms::array\n-{\n-     /*\n-        The problem can be solved in O(n) time by using the two pointers method. \n-        The idea is to maintain pointers that point to the first and last value of a subArray. \n-        On each turn, the left pointer moves one step to the right, \n-        and the right pointer moves to the right as long as the resulting subArray sum is at most x. \n-        If the sum becomes exactly x, a solution has been found.\n-     */\n-     std::optional<std::tuple<int, int>> \n-       getSubArrayOfTargetSum(std::vector<int> nums, int target)\n-     {\n-          int n = nums.size();\n-          int left = 0;\n-          int right = 1;\n-          int sum = nums[left] + nums[right];\n-          std::optional<std::tuple<int, int>> res = std::nullopt;\n-          while(right < n)\n-          {\n-              if(sum == target)\n-              {\n-                  res = std::make_optional<std::tuple<int, int>>(left, right);\n-                  break;\n-              }\n-\n-              if(sum > target)\n-              {\n-                  sum = sum - nums[left] - nums[right];\n-                  right--;\n-                  left++;\n-              }\n-              else \n-              {\n-                 sum += nums[right];\n-                 right++;\n-              }\n-          }\n-          return res;\n-     }      \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718554232635,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,16 +27,16 @@\n               }\n \n               if(sum > target)\n               {\n-                  sum -= (nums[left] - nums[right];\n+                  sum -= (nums[left] + nums[right]);\n                   right--;\n                   left++;\n               }\n               else \n               {\n+                right++;\n                  sum += nums[right];\n-                 right++;\n               }\n           }\n           return res;\n      }      \n"
                }
            ],
            "date": 1718553851848,
            "name": "Commit-0",
            "content": "#include <vector>\n#include <optional>\n\nnamespace algorithms::array\n{\n     /*\n        The problem can be solved in O(n) time by using the two pointers method. \n        The idea is to maintain pointers that point to the first and last value of a subArray. \n        On each turn, the left pointer moves one step to the right, \n        and the right pointer moves to the right as long as the resulting subArray sum is at most x. \n        If the sum becomes exactly x, a solution has been found.\n     */\n     std::optional<std::tuple<int, int>> \n       getSubArrayOfTargetSum(std::vector<int> nums, int target)\n     {\n          int n = nums.size();\n          int left = 0;\n          int right = 1;\n          int sum = nums[left] + nums[right];\n          std::optional<std::tuple<int, int>> res = std::nullopt;\n          while(right < n)\n          {\n              if(sum == target)\n              {\n                  res = std::make_optional<std::tuple<int, int>>(left, right);\n                  break;\n              }\n\n              if(sum > target)\n              {\n                  right--;\n                  left++;\n              }\n              else right++;\n          }\n          return res;\n     }      \n}"
        }
    ]
}