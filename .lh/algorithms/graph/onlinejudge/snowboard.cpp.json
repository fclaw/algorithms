{
    "sourceFile": "algorithms/graph/onlinejudge/snowboard.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 70,
            "patches": [
                {
                    "date": 1727521567390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1727521578296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,3 +1,6 @@\n \n \n-name\n\\ No newline at end of file\n+namespace algorithms::graph::onlinejudge::project_scheduling\n+{\n+    \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727521585928,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n \n \n-namespace algorithms::graph::onlinejudge::project_scheduling\n+namespace algorithms::graph::onlinejudge::snowboard\n {\n-    \n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727521592381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n \n \n namespace algorithms::graph::onlinejudge::snowboard\n {\n-\n+    /**   */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727521679235,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,9 @@\n \n \n namespace algorithms::graph::onlinejudge::snowboard\n {\n-    /**   */\n+    /**  https://onlinejudge.org/external/102/10285.pdf */\n+    int longestRun()\n+\n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727521684829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,7 +3,9 @@\n namespace algorithms::graph::onlinejudge::snowboard\n {\n     /**  https://onlinejudge.org/external/102/10285.pdf */\n     int longestRun()\n+    {\n+        return 1;\n+    }\n \n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727522085394,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,5 +7,10 @@\n     {\n         return 1;\n     }\n \n+    void submit()\n+    {\n+        \n+    }\n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727522101392,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,10 +7,10 @@\n     {\n         return 1;\n     }\n \n-    void submit()\n+        void submit(std::optional<char*> file)\n     {\n-        \n-    }\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727522121099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,16 +1,18 @@\n \n \n+\n namespace algorithms::graph::onlinejudge::snowboard\n {\n     /**  https://onlinejudge.org/external/102/10285.pdf */\n     int longestRun()\n     {\n         return 1;\n     }\n \n-        void submit(std::optional<char*> file)\n+    void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n           assert(freopen(file.value(), \"r\", stdin) != nullptr);\n+    }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727522159277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,14 @@\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n \n-\n-\n namespace algorithms::graph::onlinejudge::snowboard\n {\n-    /**  https://onlinejudge.org/external/102/10285.pdf */\n+    /**  https://onlinejudge.org/external/102/10285.pdf \n+     * ongest paths on implicit DAG; how-\n+ever, the graph is small enough for recursive backtracking solution\n+    */\n     int longestRun()\n     {\n         return 1;\n     }\n"
                },
                {
                    "date": 1727522164926,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,9 @@\n \n namespace algorithms::graph::onlinejudge::snowboard\n {\n     /**  https://onlinejudge.org/external/102/10285.pdf \n-     * ongest paths on implicit DAG; how-\n-ever, the graph is small enough for recursive backtracking solution\n+     *  longest paths on implicit DAG; how-ever, the graph is small enough for recursive backtracking solution\n     */\n     int longestRun()\n     {\n         return 1;\n"
                },
                {
                    "date": 1727522173627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,9 @@\n \n namespace algorithms::graph::onlinejudge::snowboard\n {\n     /**  https://onlinejudge.org/external/102/10285.pdf \n-     *  longest paths on implicit DAG; how-ever, the graph is small enough for recursive backtracking solution\n-    */\n+     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution */\n     int longestRun()\n     {\n         return 1;\n     }\n"
                },
                {
                    "date": 1727522217504,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,10 @@\n \n namespace algorithms::graph::onlinejudge::snowboard\n {\n     /**  https://onlinejudge.org/external/102/10285.pdf \n-     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution */\n+     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n+     * */\n     int longestRun()\n     {\n         return 1;\n     }\n"
                },
                {
                    "date": 1727522224171,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,13 @@\n namespace algorithms::graph::onlinejudge::snowboard\n {\n     /**  https://onlinejudge.org/external/102/10285.pdf \n      *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n+     *  1 2 3 4 5\n+16 17 18 19 6\n+15 24 25 20 7\n+14 23 22 21 8\n+13 12 11 10 9\n      * */\n     int longestRun()\n     {\n         return 1;\n"
                },
                {
                    "date": 1727522232639,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,11 +5,11 @@\n namespace algorithms::graph::onlinejudge::snowboard\n {\n     /**  https://onlinejudge.org/external/102/10285.pdf \n      *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n-     *  1 2 3 4 5\n-16 17 18 19 6\n-15 24 25 20 7\n+     *  1 2 3 4    5\n+     * 16 17 18 19 6\n+     * 15 24 25 20 7\n 14 23 22 21 8\n 13 12 11 10 9\n      * */\n     int longestRun()\n"
                },
                {
                    "date": 1727522240258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n namespace algorithms::graph::onlinejudge::snowboard\n {\n     /**  https://onlinejudge.org/external/102/10285.pdf \n      *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n-     *  1 2 3 4    5\n+     *  1  2  3  4 5\n      * 16 17 18 19 6\n      * 15 24 25 20 7\n 14 23 22 21 8\n 13 12 11 10 9\n"
                },
                {
                    "date": 1727522247274,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,10 +8,10 @@\n      *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n      *  1  2  3  4 5\n      * 16 17 18 19 6\n      * 15 24 25 20 7\n-14 23 22 21 8\n-13 12 11 10 9\n+     * 14 23 22 21 8\n+     * 13 12 11 10 9\n      * */\n     int longestRun()\n     {\n         return 1;\n"
                },
                {
                    "date": 1727522275256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,13 @@\n      * 16 17 18 19 6\n      * 15 24 25 20 7\n      * 14 23 22 21 8\n      * 13 12 11 10 9\n+     * One can slide down from one point to a connected other one if and only if the height decreases. One\n+point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n+slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, it would\n+be a much longer run. In fact, it’s the longest possible\n+     * \n      * */\n     int longestRun()\n     {\n         return 1;\n"
                },
                {
                    "date": 1727522281396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,10 +10,9 @@\n      * 16 17 18 19 6\n      * 15 24 25 20 7\n      * 14 23 22 21 8\n      * 13 12 11 10 9\n-     * One can slide down from one point to a connected other one if and only if the height decreases. One\n-point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n+     * One can slide down from one point to a connected other one if and only if the height decreases. Onepoint is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, it would\n be a much longer run. In fact, it’s the longest possible\n      * \n      * */\n"
                },
                {
                    "date": 1727522287418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,10 +10,11 @@\n      * 16 17 18 19 6\n      * 15 24 25 20 7\n      * 14 23 22 21 8\n      * 13 12 11 10 9\n-     * One can slide down from one point to a connected other one if and only if the height decreases. Onepoint is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n-slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, it would\n+     * One can slide down from one point to a connected other one if and only if the height decreases. \n+     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n+     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, it would\n be a much longer run. In fact, it’s the longest possible\n      * \n      * */\n     int longestRun()\n"
                },
                {
                    "date": 1727522293242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,10 +12,10 @@\n      * 14 23 22 21 8\n      * 13 12 11 10 9\n      * One can slide down from one point to a connected other one if and only if the height decreases. \n      * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n-     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, it would\n-be a much longer run. In fact, it’s the longest possible\n+     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n+     * it would be a much longer run. In fact, it’s the longest possible\n      * \n      * */\n     int longestRun()\n     {\n"
                },
                {
                    "date": 1727522300562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,11 +13,9 @@\n      * 13 12 11 10 9\n      * One can slide down from one point to a connected other one if and only if the height decreases. \n      * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n      * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n-     * it would be a much longer run. In fact, it’s the longest possible\n-     * \n-     * */\n+     * it would be a much longer run. In fact, it’s the longest possible */\n     int longestRun()\n     {\n         return 1;\n     }\n"
                },
                {
                    "date": 1727530232915,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,33 @@\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+\n+namespace algorithms::graph::onlinejudge::snowboard\n+{\n+\n+\n+\n+\n+    /**  https://onlinejudge.org/external/102/10285.pdf \n+     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n+     *  1  2  3  4 5\n+     * 16 17 18 19 6\n+     * 15 24 25 20 7\n+     * 14 23 22 21 8\n+     * 13 12 11 10 9\n+     * One can slide down from one point to a connected other one if and only if the height decreases. \n+     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n+     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n+     * it would be a much longer run. In fact, it’s the longest possible */\n+    int longestRun()\n+    {\n+        return 1;\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n+    }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530238566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,11 +4,11 @@\n \n namespace algorithms::graph::onlinejudge::snowboard\n {\n \n+typedef std::vector<>\n \n \n-\n     /**  https://onlinejudge.org/external/102/10285.pdf \n      *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n      *  1  2  3  4 5\n      * 16 17 18 19 6\n@@ -29,34 +29,5 @@\n         if(file.has_value())\n           assert(freopen(file.value(), \"r\", stdin) != nullptr);\n     }\n \n-}\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-\n-namespace algorithms::graph::onlinejudge::snowboard\n-{\n-    /**  https://onlinejudge.org/external/102/10285.pdf \n-     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n-     *  1  2  3  4 5\n-     * 16 17 18 19 6\n-     * 15 24 25 20 7\n-     * 14 23 22 21 8\n-     * 13 12 11 10 9\n-     * One can slide down from one point to a connected other one if and only if the height decreases. \n-     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n-     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n-     * it would be a much longer run. In fact, it’s the longest possible */\n-    int longestRun()\n-    {\n-        return 1;\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n-    }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530247645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n namespace algorithms::graph::onlinejudge::snowboard\n {\n \n-typedef std::vector<>\n+typedef std::vector<std::vector<int>> graph;\n \n \n     /**  https://onlinejudge.org/external/102/10285.pdf \n      *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n"
                },
                {
                    "date": 1727530263381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,13 @@\n #include <optional>\n #include <iostream>\n #include <cassert>\n+#include \"../lp_dag.cpp\"\n \n namespace algorithms::graph::onlinejudge::snowboard\n {\n \n-typedef std::vector<std::vector<int>> graph;\n+typedef std::vector<std::vector<int>> adj;\n \n \n     /**  https://onlinejudge.org/external/102/10285.pdf \n      *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n"
                },
                {
                    "date": 1727530271872,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,10 +6,10 @@\n namespace algorithms::graph::onlinejudge::snowboard\n {\n \n typedef std::vector<std::vector<int>> adj;\n+namespace lp = algorithms::graph::lp_dag;\n \n-\n     /**  https://onlinejudge.org/external/102/10285.pdf \n      *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n      *  1  2  3  4 5\n      * 16 17 18 19 6\n"
                },
                {
                    "date": 1727530445482,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,7 +28,8 @@\n     void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n           assert(freopen(file.value(), \"r\", stdin) != nullptr);\n+          \n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530454170,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,8 +28,8 @@\n     void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n           assert(freopen(file.value(), \"r\", stdin) != nullptr);\n-          \n+        adj graph;  \n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530472897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,8 +28,13 @@\n     void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n           assert(freopen(file.value(), \"r\", stdin) != nullptr);\n-        adj graph;  \n+        adj graph;\n+        int tc;\n+        while(--tc >= 0)\n+        {\n+            \n+        }  \n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530478258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n         adj graph;\n         int tc;\n         while(--tc >= 0)\n         {\n-            \n-        }  \n+\n+        }\n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530498915,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n         adj graph;\n         int tc;\n         while(--tc >= 0)\n         {\n-\n+            std::string s;\n+            \n         }\n     }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530517962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,8 +33,9 @@\n         int tc;\n         while(--tc >= 0)\n         {\n             std::string s;\n-            \n+            std::getline(std::cin, in\n+\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530529647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n #include <optional>\n #include <iostream>\n #include <cassert>\n+#include <sstream>\n #include \"../lp_dag.cpp\"\n \n namespace algorithms::graph::onlinejudge::snowboard\n {\n@@ -33,9 +34,9 @@\n         int tc;\n         while(--tc >= 0)\n         {\n             std::string s;\n-            std::getline(std::cin, in\n+            std::getline(std::cin, s);\n \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530536532,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,8 +34,9 @@\n         int tc;\n         while(--tc >= 0)\n         {\n             std::string s;\n+            std::\n             std::getline(std::cin, s);\n \n         }\n     }\n"
                },
                {
                    "date": 1727530547473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,10 @@\n         int tc;\n         while(--tc >= 0)\n         {\n             std::string s;\n-            std::\n+            std::string track;\n+            int r, c;\n             std::getline(std::cin, s);\n \n         }\n     }\n"
                },
                {
                    "date": 1727530553864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,10 +35,11 @@\n         while(--tc >= 0)\n         {\n             std::string s;\n             std::string track;\n-            int r, c;\n+            int rows, cols;\n             std::getline(std::cin, s);\n+            \n \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530566418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n             std::string s;\n             std::string track;\n             int rows, cols;\n             std::getline(std::cin, s);\n-            \n+            std::stringstream ss(in);\n \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530572137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,46 @@\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <sstream>\n+#include \"../lp_dag.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::snowboard\n+{\n+\n+typedef std::vector<std::vector<int>> adj;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+    /**  https://onlinejudge.org/external/102/10285.pdf \n+     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n+     *  1  2  3  4 5\n+     * 16 17 18 19 6\n+     * 15 24 25 20 7\n+     * 14 23 22 21 8\n+     * 13 12 11 10 9\n+     * One can slide down from one point to a connected other one if and only if the height decreases. \n+     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n+     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n+     * it would be a much longer run. In fact, it’s the longest possible */\n+    int longestRun()\n+    {\n+        return 1;\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n+        adj graph;\n+        int tc;\n+        while(--tc >= 0)\n+        {\n+            std::string s;\n+            std::string track;\n+            int rows, cols;\n+            std::getline(std::cin, s);\n+            std::stringstream ss(s);\n+            s >> \n+\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530578808,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,54 +38,9 @@\n             std::string track;\n             int rows, cols;\n             std::getline(std::cin, s);\n             std::stringstream ss(s);\n-            s >> \n+            s >> track >> \n \n         }\n     }\n-}\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <sstream>\n-#include \"../lp_dag.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::snowboard\n-{\n-\n-typedef std::vector<std::vector<int>> adj;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-    /**  https://onlinejudge.org/external/102/10285.pdf \n-     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n-     *  1  2  3  4 5\n-     * 16 17 18 19 6\n-     * 15 24 25 20 7\n-     * 14 23 22 21 8\n-     * 13 12 11 10 9\n-     * One can slide down from one point to a connected other one if and only if the height decreases. \n-     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n-     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n-     * it would be a much longer run. In fact, it’s the longest possible */\n-    int longestRun()\n-    {\n-        return 1;\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n-        adj graph;\n-        int tc;\n-        while(--tc >= 0)\n-        {\n-            std::string s;\n-            std::string track;\n-            int rows, cols;\n-            std::getline(std::cin, s);\n-            std::stringstream ss(in);\n-\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530584259,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,47 @@\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <sstream>\n+#include \"../lp_dag.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::snowboard\n+{\n+\n+typedef std::vector<std::vector<int>> adj;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+    /**  https://onlinejudge.org/external/102/10285.pdf \n+     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n+     *  1  2  3  4 5\n+     * 16 17 18 19 6\n+     * 15 24 25 20 7\n+     * 14 23 22 21 8\n+     * 13 12 11 10 9\n+     * One can slide down from one point to a connected other one if and only if the height decreases. \n+     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n+     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n+     * it would be a much longer run. In fact, it’s the longest possible */\n+    int longestRun()\n+    {\n+        return 1;\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n+        adj graph;\n+        int tc;\n+        while(--tc >= 0)\n+        {\n+            std::string s;\n+            std::string track;\n+            int rows, cols;\n+            std::getline(std::cin, s);\n+            std::stringstream ss(s);\n+            s >> track >> rows >> cols;\n+            \n+\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530649284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,55 +39,9 @@\n             int rows, cols;\n             std::getline(std::cin, s);\n             std::stringstream ss(s);\n             s >> track >> rows >> cols;\n-            \n+            while()\n \n         }\n     }\n-}\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <sstream>\n-#include \"../lp_dag.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::snowboard\n-{\n-\n-typedef std::vector<std::vector<int>> adj;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-    /**  https://onlinejudge.org/external/102/10285.pdf \n-     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n-     *  1  2  3  4 5\n-     * 16 17 18 19 6\n-     * 15 24 25 20 7\n-     * 14 23 22 21 8\n-     * 13 12 11 10 9\n-     * One can slide down from one point to a connected other one if and only if the height decreases. \n-     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n-     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n-     * it would be a much longer run. In fact, it’s the longest possible */\n-    int longestRun()\n-    {\n-        return 1;\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n-        adj graph;\n-        int tc;\n-        while(--tc >= 0)\n-        {\n-            std::string s;\n-            std::string track;\n-            int rows, cols;\n-            std::getline(std::cin, s);\n-            std::stringstream ss(s);\n-            s >> track >> \n-\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530658263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,12 @@\n             int rows, cols;\n             std::getline(std::cin, s);\n             std::stringstream ss(s);\n             s >> track >> rows >> cols;\n-            while()\n+            while(--rows >= 0)\n+            {\n+                \n+            }\n \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530668309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n             std::stringstream ss(s);\n             s >> track >> rows >> cols;\n             while(--rows >= 0)\n             {\n-                \n+                for(int i = 0; i < cols; i++)\n             }\n \n         }\n     }\n"
                },
                {
                    "date": 1727530676302,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,50 @@\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <sstream>\n+#include \"../lp_dag.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::snowboard\n+{\n+\n+typedef std::vector<std::vector<int>> adj;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+    /**  https://onlinejudge.org/external/102/10285.pdf \n+     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n+     *  1  2  3  4 5\n+     * 16 17 18 19 6\n+     * 15 24 25 20 7\n+     * 14 23 22 21 8\n+     * 13 12 11 10 9\n+     * One can slide down from one point to a connected other one if and only if the height decreases. \n+     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n+     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n+     * it would be a much longer run. In fact, it’s the longest possible */\n+    int longestRun()\n+    {\n+        return 1;\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n+        adj graph;\n+        int tc;\n+        while(--tc >= 0)\n+        {\n+            std::string s;\n+            std::string track;\n+            int rows, cols;\n+            std::getline(std::cin, s);\n+            std::stringstream ss(s);\n+            s >> track >> rows >> cols;\n+            while(--rows >= 0)\n+            {\n+                for(int i = 0; i < cols; i++)\n+            }\n+\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530683333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,60 +41,11 @@\n             std::stringstream ss(s);\n             s >> track >> rows >> cols;\n             while(--rows >= 0)\n             {\n+                int \n                 for(int i = 0; i < cols; i++)\n             }\n \n         }\n     }\n-}\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <sstream>\n-#include \"../lp_dag.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::snowboard\n-{\n-\n-typedef std::vector<std::vector<int>> adj;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-    /**  https://onlinejudge.org/external/102/10285.pdf \n-     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n-     *  1  2  3  4 5\n-     * 16 17 18 19 6\n-     * 15 24 25 20 7\n-     * 14 23 22 21 8\n-     * 13 12 11 10 9\n-     * One can slide down from one point to a connected other one if and only if the height decreases. \n-     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n-     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n-     * it would be a much longer run. In fact, it’s the longest possible */\n-    int longestRun()\n-    {\n-        return 1;\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n-        adj graph;\n-        int tc;\n-        while(--tc >= 0)\n-        {\n-            std::string s;\n-            std::string track;\n-            int rows, cols;\n-            std::getline(std::cin, s);\n-            std::stringstream ss(s);\n-            s >> track >> rows >> cols;\n-            while(--rows >= 0)\n-            {\n-                for(int i = 0; i < cols; i++)\n-            }\n-\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530689486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n             std::stringstream ss(s);\n             s >> track >> rows >> cols;\n             while(--rows >= 0)\n             {\n-                int \n+                int height;\n                 for(int i = 0; i < cols; i++)\n             }\n \n         }\n"
                },
                {
                    "date": 1727530700006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,8 +43,10 @@\n             while(--rows >= 0)\n             {\n                 int height;\n                 for(int i = 0; i < cols; i++)\n+                  std::cin >> height;\n+                  if\n             }\n \n         }\n     }\n"
                },
                {
                    "date": 1727530705742,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,9 +43,10 @@\n             while(--rows >= 0)\n             {\n                 int height;\n                 for(int i = 0; i < cols; i++)\n-                  std::cin >> height;\n+                {\n+                    std::cin >> height;\n                   if\n             }\n \n         }\n"
                },
                {
                    "date": 1727530723336,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,9 @@\n namespace algorithms::graph::onlinejudge::snowboard\n {\n \n typedef std::vector<std::vector<int>> adj;\n+typedef std::vector<std::vector<int>> adj;\n namespace lp = algorithms::graph::lp_dag;\n \n     /**  https://onlinejudge.org/external/102/10285.pdf \n      *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n"
                },
                {
                    "date": 1727530730441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,55 @@\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <sstream>\n+#include \"../lp_dag.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::snowboard\n+{\n+\n+typedef std::vector<std::vector<int>> adj;\n+typedef std::vector<std::vector<int>> matrix;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+    /**  https://onlinejudge.org/external/102/10285.pdf \n+     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n+     *  1  2  3  4 5\n+     * 16 17 18 19 6\n+     * 15 24 25 20 7\n+     * 14 23 22 21 8\n+     * 13 12 11 10 9\n+     * One can slide down from one point to a connected other one if and only if the height decreases. \n+     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n+     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n+     * it would be a much longer run. In fact, it’s the longest possible */\n+    int longestRun()\n+    {\n+        return 1;\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n+        adj graph;\n+        int tc;\n+        while(--tc >= 0)\n+        {\n+            std::string s;\n+            std::string track;\n+            int rows, cols;\n+            std::getline(std::cin, s);\n+            std::stringstream ss(s);\n+            s >> track >> rows >> cols;\n+            while(--rows >= 0)\n+            {\n+                int height;\n+                for(int i = 0; i < cols; i++)\n+                {\n+                    std::cin >> height;\n+                  if\n+            }\n+\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530740993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,8 +37,9 @@\n         {\n             std::string s;\n             std::string track;\n             int rows, cols;\n+            matrix mtx;\n             std::getline(std::cin, s);\n             std::stringstream ss(s);\n             s >> track >> rows >> cols;\n             while(--rows >= 0)\n@@ -51,60 +52,5 @@\n             }\n \n         }\n     }\n-}\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <sstream>\n-#include \"../lp_dag.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::snowboard\n-{\n-\n-typedef std::vector<std::vector<int>> adj;\n-typedef std::vector<std::vector<int>> adj;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-    /**  https://onlinejudge.org/external/102/10285.pdf \n-     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n-     *  1  2  3  4 5\n-     * 16 17 18 19 6\n-     * 15 24 25 20 7\n-     * 14 23 22 21 8\n-     * 13 12 11 10 9\n-     * One can slide down from one point to a connected other one if and only if the height decreases. \n-     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n-     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n-     * it would be a much longer run. In fact, it’s the longest possible */\n-    int longestRun()\n-    {\n-        return 1;\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n-        adj graph;\n-        int tc;\n-        while(--tc >= 0)\n-        {\n-            std::string s;\n-            std::string track;\n-            int rows, cols;\n-            std::getline(std::cin, s);\n-            std::stringstream ss(s);\n-            s >> track >> rows >> cols;\n-            while(--rows >= 0)\n-            {\n-                int height;\n-                for(int i = 0; i < cols; i++)\n-                {\n-                    std::cin >> height;\n-                  if\n-            }\n-\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530755605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,8 @@\n                 int height;\n                 for(int i = 0; i < cols; i++)\n                 {\n                     std::cin >> height;\n-                  if\n             }\n \n         }\n     }\n"
                },
                {
                    "date": 1727530766977,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n             matrix mtx;\n             std::getline(std::cin, s);\n             std::stringstream ss(s);\n             s >> track >> rows >> cols;\n-            while(--rows >= 0)\n+            for(int )\n             {\n                 int height;\n                 for(int i = 0; i < cols; i++)\n                 {\n"
                },
                {
                    "date": 1727530774687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n             matrix mtx;\n             std::getline(std::cin, s);\n             std::stringstream ss(s);\n             s >> track >> rows >> cols;\n-            for(int )\n+            for(int r = 0; r < rows; r++)\n             {\n                 int height;\n                 for(int i = 0; i < cols; i++)\n                 {\n"
                },
                {
                    "date": 1727530786243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,8 +44,9 @@\n             s >> track >> rows >> cols;\n             for(int r = 0; r < rows; r++)\n             {\n                 int height;\n+                std::vector<int> cl;\n                 for(int i = 0; i < cols; i++)\n                 {\n                     std::cin >> height;\n             }\n"
                },
                {
                    "date": 1727530792739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,11 +44,10 @@\n             s >> track >> rows >> cols;\n             for(int r = 0; r < rows; r++)\n             {\n                 int height;\n-                std::vector<int> cl;\n+                std::vector<int> cx;\n                 for(int i = 0; i < cols; i++)\n-                {\n                     std::cin >> height;\n             }\n \n         }\n"
                },
                {
                    "date": 1727530801097,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n             {\n                 int height;\n                 std::vector<int> cx;\n                 for(int i = 0; i < cols; i++)\n-                    std::cin >> height;\n+                  \n             }\n \n         }\n     }\n"
                },
                {
                    "date": 1727530811608,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,10 @@\n             {\n                 int height;\n                 std::vector<int> cx;\n                 for(int i = 0; i < cols; i++)\n-                  \n+                  std::cin \n+                  cx.push_back()\n             }\n \n         }\n     }\n"
                },
                {
                    "date": 1727530816998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n             {\n                 int height;\n                 std::vector<int> cx;\n                 for(int i = 0; i < cols; i++)\n-                  std::cin \n+                  std::cin >> height, \n                   cx.push_back()\n             }\n \n         }\n"
                },
                {
                    "date": 1727530828198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,10 @@\n                 int height;\n                 std::vector<int> cx;\n                 for(int i = 0; i < cols; i++)\n                   std::cin >> height, \n-                  cx.push_back()\n+                  cx.push_back(height);\n+                mtx.  \n             }\n \n         }\n     }\n"
                },
                {
                    "date": 1727530833511,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n                 std::vector<int> cx;\n                 for(int i = 0; i < cols; i++)\n                   std::cin >> height, \n                   cx.push_back(height);\n-                mtx.  \n+                mtx.pus  \n             }\n \n         }\n     }\n"
                },
                {
                    "date": 1727530840649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n                 std::vector<int> cx;\n                 for(int i = 0; i < cols; i++)\n                   std::cin >> height, \n                   cx.push_back(height);\n-                mtx.pus  \n+                mtx.push_back(cx);  \n             }\n \n         }\n     }\n"
                },
                {
                    "date": 1727530860321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,10 @@\n     {\n         return 1;\n     }\n \n+    \n+\n     void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n           assert(freopen(file.value(), \"r\", stdin) != nullptr);\n@@ -51,7 +53,8 @@\n                   cx.push_back(height);\n                 mtx.push_back(cx);  \n             }\n \n+\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530868997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n     {\n         return 1;\n     }\n \n-    \n+    adj \n \n     void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n"
                },
                {
                    "date": 1727530878434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n     {\n         return 1;\n     }\n \n-    adj \n+    adj makeGraph()\n \n     void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n"
                },
                {
                    "date": 1727530887201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n     {\n         return 1;\n     }\n \n-    adj makeGraph()\n+    adj makeGraph(const matrix& m)\n \n     void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n"
                },
                {
                    "date": 1727530892425,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n     {\n         return 1;\n     }\n \n-    adj makeGraph(const matrix& m)\n+    adj makeGraph(const matrix& mtx) { return {}; }\n \n     void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n"
                },
                {
                    "date": 1727530902001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,8 +53,9 @@\n                   cx.push_back(height);\n                 mtx.push_back(cx);  \n             }\n \n+            makeGraph() \n \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530910462,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n                   cx.push_back(height);\n                 mtx.push_back(cx);  \n             }\n \n-            makeGraph(mtx); \n+            adj g makeGraph(mtx); \n \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727530917185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,61 @@\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <sstream>\n+#include \"../lp_dag.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::snowboard\n+{\n+\n+typedef std::vector<std::vector<int>> adj;\n+typedef std::vector<std::vector<int>> matrix;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+    /**  https://onlinejudge.org/external/102/10285.pdf \n+     *  longest paths on implicit DAG; however, the graph is small enough for recursive backtracking solution \n+     *  1  2  3  4 5\n+     * 16 17 18 19 6\n+     * 15 24 25 20 7\n+     * 14 23 22 21 8\n+     * 13 12 11 10 9\n+     * One can slide down from one point to a connected other one if and only if the height decreases. \n+     * One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible\n+     * slide would be 24-17-16-1 (start at 24, end at 1). Of course if you would go 25-24-23-…-3-2-1, \n+     * it would be a much longer run. In fact, it’s the longest possible */\n+    int longestRun()\n+    {\n+        return 1;\n+    }\n+\n+    adj makeGraph(const matrix& mtx) { return {}; }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != nullptr);\n+        adj graph;\n+        int tc;\n+        while(--tc >= 0)\n+        {\n+            std::string s;\n+            std::string track;\n+            int rows, cols;\n+            matrix mtx;\n+            std::getline(std::cin, s);\n+            std::stringstream ss(s);\n+            s >> track >> rows >> cols;\n+            for(int r = 0; r < rows; r++)\n+            {\n+                int height;\n+                std::vector<int> cx;\n+                for(int i = 0; i < cols; i++)\n+                  std::cin >> height, \n+                  cx.push_back(height);\n+                mtx.push_back(cx);  \n+            }\n+\n+            adj graph = makeGraph(mtx); \n+\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1727521567390,
            "name": "Commit-0",
            "content": "\n\nname"
        }
    ]
}