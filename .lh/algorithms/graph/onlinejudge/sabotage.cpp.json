{
    "sourceFile": "algorithms/graph/onlinejudge/sabotage.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 56,
            "patches": [
                {
                    "date": 1727607980107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1727607990622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n \n \n namespace algorithms::graph::onlinejudge::sabotage\n {\n-    \n+    /**   */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608851170,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,11 @@\n \n \n namespace algorithms::graph::onlinejudge::sabotage\n {\n-    /**   */\n+\n+\n+\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608858366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,12 @@\n+#include <vec\n+\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+\n+\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608871364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,23 +1,11 @@\n-#include <vec\n+#include <vector>\n \n-\n namespace algorithms::graph::onlinejudge::sabotage\n {\n \n+typedef std::vector<std::vector<int>>\n \n \n-\n     /** https://onlinejudge.org/external/104/10480.pdf */\n \n-}\n-\n-\n-namespace algorithms::graph::onlinejudge::sabotage\n-{\n-\n-\n-\n-\n-    /** https://onlinejudge.org/external/104/10480.pdf */\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608878114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n \n namespace algorithms::graph::onlinejudge::sabotage\n {\n \n-typedef std::vector<std::vector<int>>\n+typedef std::vector<std::vector<int>> adj_matrix;\n \n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n \n"
                },
                {
                    "date": 1727608885691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,8 @@\n {\n \n typedef std::vector<std::vector<int>> adj_matrix;\n \n-\n     /** https://onlinejudge.org/external/104/10480.pdf */\n+    \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608904076,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,7 +5,7 @@\n \n typedef std::vector<std::vector<int>> adj_matrix;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n-    \n+    void performEdmondsKarp(int V, int director, int server, const graph& g)\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608909645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,7 +5,7 @@\n \n typedef std::vector<std::vector<int>> adj_matrix;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int director, int server, const graph& g)\n+    void performEdmondsKarp(int V, int capital, int server, const graph& g)\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608916134,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,11 @@\n+#include <vector>\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+typedef std::vector<std::vector<int>> adj_matrix;\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+    void performEdmondsKarp(int V, int capital, int major, const graph& g)\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608930417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,18 +5,7 @@\n \n typedef std::vector<std::vector<int>> adj_matrix;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int major, const graph& g)\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g)\n \n-}\n-#include <vector>\n-\n-namespace algorithms::graph::onlinejudge::sabotage\n-{\n-\n-typedef std::vector<std::vector<int>> adj_matrix;\n-\n-    /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int server, const graph& g)\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608944628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,7 +5,9 @@\n \n typedef std::vector<std::vector<int>> adj_matrix;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g)\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n \n+    \n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608964478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,7 +7,16 @@\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n     void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n \n-    \n+    // A DFS based function to find all reachable vertices from s.  The function\n+// marks visited[i] as true if i is reachable from s.  The initial values in\n+// visited[] must be false. We can also use BFS to find reachable vertices\n+void dfs(int rGraph[V][V], int s, bool visited[])\n+{\n+    visited[s] = true;\n+    for (int i = 0; i < V; i++)\n+       if (rGraph[s][i] && !visited[i])\n+           dfs(rGraph, i, visited);\n+}\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608977889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,17 +6,18 @@\n typedef std::vector<std::vector<int>> adj_matrix;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n     void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n+        /** dfs based function to find all reachable vertices from s. \n+     *  The function marks visited[i] as true if i is reachable from s. \n+     *  The initial values in visited[] must be false. \n+     * We can also use BFS to find reachable vertices */\n+    void reachableVertices(int V, int s, vi visited)\n+    {\n+        visited[s] = true;\n+        for (int i = 0; i < V; i++)\n+          if(mf::residual_graph[s][i] && \n+             !visited[i])\n+            reachableVertices(V, i, visited);\n+    }\n \n-    // A DFS based function to find all reachable vertices from s.  The function\n-// marks visited[i] as true if i is reachable from s.  The initial values in\n-// visited[] must be false. We can also use BFS to find reachable vertices\n-void dfs(int rGraph[V][V], int s, bool visited[])\n-{\n-    visited[s] = true;\n-    for (int i = 0; i < V; i++)\n-       if (rGraph[s][i] && !visited[i])\n-           dfs(rGraph, i, visited);\n-}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727608991056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,13 +6,14 @@\n typedef std::vector<std::vector<int>> adj_matrix;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n     void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n-        /** dfs based function to find all reachable vertices from s. \n+\n+    /** dfs based function to find all reachable vertices from s. \n      *  The function marks visited[i] as true if i is reachable from s. \n      *  The initial values in visited[] must be false. \n      * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int s, vi visited)\n+    void reachableVertices(int V, int capi, vi visited)\n     {\n         visited[s] = true;\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n"
                },
                {
                    "date": 1727609018557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,17 +3,18 @@\n namespace algorithms::graph::onlinejudge::sabotage\n {\n \n typedef std::vector<std::vector<int>> adj_matrix;\n+typdef \n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n     void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n \n     /** dfs based function to find all reachable vertices from s. \n      *  The function marks visited[i] as true if i is reachable from s. \n      *  The initial values in visited[] must be false. \n      * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int capi, vi visited)\n+    void reachableVertices(int V, int capital, vi visited)\n     {\n         visited[s] = true;\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n"
                },
                {
                    "date": 1727609028418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n namespace algorithms::graph::onlinejudge::sabotage\n {\n \n typedef std::vector<std::vector<int>> adj_matrix;\n-typdef \n+typedef std::vector<int> vv;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n     void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n \n"
                },
                {
                    "date": 1727609036236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,25 @@\n+#include <vector>\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+typedef std::vector<std::vector<int>> adj_matrix;\n+typedef std::vector<int> vv;\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n+\n+    /** dfs based function to find all reachable vertices from s. \n+     *  The function marks visited[i] as true if i is reachable from s. \n+     *  The initial values in visited[] must be false. \n+     * We can also use BFS to find reachable vertices */\n+    void reachableVertices(int V, int capital, vv visited)\n+    {\n+        visited[;\n+        for (int i = 0; i < V; i++)\n+          if(mf::residual_graph[s][i] && \n+             !visited[i])\n+            reachableVertices(V, i, visited);\n+    }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609042202,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,39 +12,14 @@\n     /** dfs based function to find all reachable vertices from s. \n      *  The function marks visited[i] as true if i is reachable from s. \n      *  The initial values in visited[] must be false. \n      * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int capital, vv visited)\n+    void reachableVertices(int V, int capital, vv vs)\n     {\n-        visited[;\n+        visited;\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n              !visited[i])\n             reachableVertices(V, i, visited);\n     }\n \n-}\n-#include <vector>\n-\n-namespace algorithms::graph::onlinejudge::sabotage\n-{\n-\n-typedef std::vector<std::vector<int>> adj_matrix;\n-typedef std::vector<int> vv;\n-\n-    /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n-\n-    /** dfs based function to find all reachable vertices from s. \n-     *  The function marks visited[i] as true if i is reachable from s. \n-     *  The initial values in visited[] must be false. \n-     * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int capital, vi visited)\n-    {\n-        visited[s] = true;\n-        for (int i = 0; i < V; i++)\n-          if(mf::residual_graph[s][i] && \n-             !visited[i])\n-            reachableVertices(V, i, visited);\n-    }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609047397,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,25 @@\n+#include <vector>\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+typedef std::vector<std::vector<int>> adj_matrix;\n+typedef std::vector<int> vv;\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n+\n+    /** dfs based function to find all reachable vertices from s. \n+     *  The function marks visited[i] as true if i is reachable from s. \n+     *  The initial values in visited[] must be false. \n+     * We can also use BFS to find reachable vertices */\n+    void reachableVertices(int V, int capital, vv vi)\n+    {\n+        visited;\n+        for (int i = 0; i < V; i++)\n+          if(mf::residual_graph[s][i] && \n+             !visited[i])\n+            reachableVertices(V, i, visited);\n+    }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609053535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,39 +12,14 @@\n     /** dfs based function to find all reachable vertices from s. \n      *  The function marks visited[i] as true if i is reachable from s. \n      *  The initial values in visited[] must be false. \n      * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int capital, vv vi)\n+    void reachableVertices(int V, int capital, vv visited)\n     {\n-        visited;\n+        visited.;\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n              !visited[i])\n             reachableVertices(V, i, visited);\n     }\n \n-}\n-#include <vector>\n-\n-namespace algorithms::graph::onlinejudge::sabotage\n-{\n-\n-typedef std::vector<std::vector<int>> adj_matrix;\n-typedef std::vector<int> vv;\n-\n-    /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n-\n-    /** dfs based function to find all reachable vertices from s. \n-     *  The function marks visited[i] as true if i is reachable from s. \n-     *  The initial values in visited[] must be false. \n-     * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int capital, vv vs)\n-    {\n-        visited;\n-        for (int i = 0; i < V; i++)\n-          if(mf::residual_graph[s][i] && \n-             !visited[i])\n-            reachableVertices(V, i, visited);\n-    }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609058889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n      *  The initial values in visited[] must be false. \n      * We can also use BFS to find reachable vertices */\n     void reachableVertices(int V, int capital, vv visited)\n     {\n-        visited.;\n+        visited.push_back();\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n              !visited[i])\n             reachableVertices(V, i, visited);\n"
                },
                {
                    "date": 1727609089696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n #include <vector>\n+#include \"../edmonds_karp.cpp\"\n \n namespace algorithms::graph::onlinejudge::sabotage\n {\n \n@@ -12,11 +13,11 @@\n     /** dfs based function to find all reachable vertices from s. \n      *  The function marks visited[i] as true if i is reachable from s. \n      *  The initial values in visited[] must be false. \n      * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int capital, vv visited)\n+    void reachableVertices(int V, int s, vv visited)\n     {\n-        visited.push_back();\n+        visited.push_back(s);\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n              !visited[i])\n             reachableVertices(V, i, visited);\n"
                },
                {
                    "date": 1727609097726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,9 @@\n {\n \n typedef std::vector<std::vector<int>> adj_matrix;\n typedef std::vector<int> vv;\n+namespace mf = algorithms::graph::max_flow;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n     void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n \n"
                },
                {
                    "date": 1727609122812,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n #include <vector>\n+\n #include \"../edmonds_karp.cpp\"\n \n namespace algorithms::graph::onlinejudge::sabotage\n {\n"
                },
                {
                    "date": 1727609132673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n #include <vector>\n-\n+#include <unordered_map>\n #include \"../edmonds_karp.cpp\"\n \n namespace algorithms::graph::onlinejudge::sabotage\n {\n"
                },
                {
                    "date": 1727609140955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,29 @@\n+#include <vector>\n+#include <unordered_map>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+typedef std::vector<std::vector<int>> adj_matrix;\n+typedef std::vector<int> vv;\n+typedef std::unor\n+namespace mf = algorithms::graph::max_flow;\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n+\n+    /** dfs based function to find all reachable vertices from s. \n+     *  The function marks visited[i] as true if i is reachable from s. \n+     *  The initial values in visited[] must be false. \n+     * We can also use BFS to find reachable vertices */\n+    void reachableVertices(int V, int s, vv visited)\n+    {\n+        visited.push_back(s);\n+        for (int i = 0; i < V; i++)\n+          if(mf::residual_graph[s][i] && \n+             !visited[i])\n+            reachableVertices(V, i, visited);\n+    }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609149203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,33 +25,5 @@\n              !visited[i])\n             reachableVertices(V, i, visited);\n     }\n \n-}\n-#include <vector>\n-#include <unordered_map>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::sabotage\n-{\n-\n-typedef std::vector<std::vector<int>> adj_matrix;\n-typedef std::vector<int> vv;\n-namespace mf = algorithms::graph::max_flow;\n-\n-    /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n-\n-    /** dfs based function to find all reachable vertices from s. \n-     *  The function marks visited[i] as true if i is reachable from s. \n-     *  The initial values in visited[] must be false. \n-     * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int s, vv visited)\n-    {\n-        visited.push_back(s);\n-        for (int i = 0; i < V; i++)\n-          if(mf::residual_graph[s][i] && \n-             !visited[i])\n-            reachableVertices(V, i, visited);\n-    }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609155359,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n {\n \n typedef std::vector<std::vector<int>> adj_matrix;\n typedef std::vector<int> vv;\n-typedef std::unor\n+typedef std::unordered_map<int, \n namespace mf = algorithms::graph::max_flow;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n     void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n"
                },
                {
                    "date": 1727609162036,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,14 @@\n #include <vector>\n-#include <unordered_map>\n+#include <unordered_set>\n #include \"../edmonds_karp.cpp\"\n \n namespace algorithms::graph::onlinejudge::sabotage\n {\n \n typedef std::vector<std::vector<int>> adj_matrix;\n typedef std::vector<int> vv;\n-typedef std::unordered_map<int, \n+typedef std::unordered_map<int>\n namespace mf = algorithms::graph::max_flow;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n     void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n"
                },
                {
                    "date": 1727609167786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n {\n \n typedef std::vector<std::vector<int>> adj_matrix;\n typedef std::vector<int> vv;\n-typedef std::unordered_map<int>\n+typedef std::unordered_set<int> \n namespace mf = algorithms::graph::max_flow;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n     void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n"
                },
                {
                    "date": 1727609173223,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     /** dfs based function to find all reachable vertices from s. \n      *  The function marks visited[i] as true if i is reachable from s. \n      *  The initial values in visited[] must be false. \n      * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int s, vv visited)\n+    void reachableVertices(int V, int s, sv visited)\n     {\n         visited.push_back(s);\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n"
                },
                {
                    "date": 1727609182729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n {\n \n typedef std::vector<std::vector<int>> adj_matrix;\n typedef std::vector<int> vv;\n-typedef std::unordered_set<int> \n+typedef std::unordered_set<int> sv;\n namespace mf = algorithms::graph::max_flow;\n \n     /** https://onlinejudge.org/external/104/10480.pdf */\n     void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n@@ -16,11 +16,11 @@\n     /** dfs based function to find all reachable vertices from s. \n      *  The function marks visited[i] as true if i is reachable from s. \n      *  The initial values in visited[] must be false. \n      * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int s, sv visited)\n+    void reachableVertices(int V, int s, sv& visited)\n     {\n-        visited.push_back(s);\n+        visited.insert(s);\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n              !visited[i])\n             reachableVertices(V, i, visited);\n"
                },
                {
                    "date": 1727609209663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n     {\n         visited.insert(s);\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n-             !visited[i])\n+             !visited.)\n             reachableVertices(V, i, visited);\n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609216616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n     {\n         visited.insert(s);\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n-             !visited.)\n+             !visited.find(s) != visited.e)\n             reachableVertices(V, i, visited);\n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609222817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n     {\n         visited.insert(s);\n         for (int i = 0; i < V; i++)\n           if(mf::residual_graph[s][i] && \n-             !visited.find(s) != visited.e)\n+             visited.find(s) != visited.end())\n             reachableVertices(V, i, visited);\n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609399100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,5 +25,7 @@\n              visited.find(s) != visited.end())\n             reachableVertices(V, i, visited);\n     }\n \n+    \n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609414515,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,7 +25,7 @@\n              visited.find(s) != visited.end())\n             reachableVertices(V, i, visited);\n     }\n \n-    \n+    void submit()\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609424663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,7 +25,8 @@\n              visited.find(s) != visited.end())\n             reachableVertices(V, i, visited);\n     }\n \n-    void submit()\n+    void submit(std::optional<char*> file)\n+    \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609435002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,7 +26,10 @@\n             reachableVertices(V, i, visited);\n     }\n \n     void submit(std::optional<char*> file)\n-    \n+    {\n+        if(file.has_value())\n+        assert(freopen(file.value(), \"r\", stdin) != NULL);\n+    }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609451713,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n #include <vector>\n #include <unordered_set>\n+#include <cassert>\n #include \"../edmonds_karp.cpp\"\n \n namespace algorithms::graph::onlinejudge::sabotage\n {\n@@ -28,8 +29,8 @@\n \n     void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n-        assert(freopen(file.value(), \"r\", stdin) != NULL);\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609457693,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,7 +30,9 @@\n     void submit(std::optional<char*> file)\n     {\n         if(file.has_value())\n           assert(freopen(file.value(), \"r\", stdin) != NULL);\n+\n+          \n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609498852,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,9 @@\n     {\n         if(file.has_value())\n           assert(freopen(file.value(), \"r\", stdin) != NULL);\n \n-          \n+        int vert\n+\n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609509459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,40 @@\n+#include <vector>\n+#include <unordered_set>\n+#include <cassert>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+typedef std::vector<std::vector<int>> adj_matrix;\n+typedef std::vector<int> vv;\n+typedef std::unordered_set<int> sv;\n+namespace mf = algorithms::graph::max_flow;\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n+\n+    /** dfs based function to find all reachable vertices from s. \n+     *  The function marks visited[i] as true if i is reachable from s. \n+     *  The initial values in visited[] must be false. \n+     * We can also use BFS to find reachable vertices */\n+    void reachableVertices(int V, int s, sv& visited)\n+    {\n+        visited.insert(s);\n+        for (int i = 0; i < V; i++)\n+          if(mf::residual_graph[s][i] && \n+             visited.find(s) != visited.end())\n+            reachableVertices(V, i, visited);\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+\n+        int vertices, edges;\n+        std::cin >> veri\n+\n+    }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609516520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,40 @@\n+#include <vector>\n+#include <unordered_set>\n+#include <cassert>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+typedef std::vector<std::vector<int>> adj_matrix;\n+typedef std::vector<int> vv;\n+typedef std::unordered_set<int> sv;\n+namespace mf = algorithms::graph::max_flow;\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n+\n+    /** dfs based function to find all reachable vertices from s. \n+     *  The function marks visited[i] as true if i is reachable from s. \n+     *  The initial values in visited[] must be false. \n+     * We can also use BFS to find reachable vertices */\n+    void reachableVertices(int V, int s, sv& visited)\n+    {\n+        visited.insert(s);\n+        for (int i = 0; i < V; i++)\n+          if(mf::residual_graph[s][i] && \n+             visited.find(s) != visited.end())\n+            reachableVertices(V, i, visited);\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+\n+        int vertices, edges;\n+        std::cin >> vertices >> edges;\n+\n+    }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609521579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,87 +33,9 @@\n           assert(freopen(file.value(), \"r\", stdin) != NULL);\n \n         int vertices, edges;\n         std::cin >> vertices >> edges;\n+        for()\n \n     }\n \n-}\n-#include <vector>\n-#include <unordered_set>\n-#include <cassert>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::sabotage\n-{\n-\n-typedef std::vector<std::vector<int>> adj_matrix;\n-typedef std::vector<int> vv;\n-typedef std::unordered_set<int> sv;\n-namespace mf = algorithms::graph::max_flow;\n-\n-    /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n-\n-    /** dfs based function to find all reachable vertices from s. \n-     *  The function marks visited[i] as true if i is reachable from s. \n-     *  The initial values in visited[] must be false. \n-     * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int s, sv& visited)\n-    {\n-        visited.insert(s);\n-        for (int i = 0; i < V; i++)\n-          if(mf::residual_graph[s][i] && \n-             visited.find(s) != visited.end())\n-            reachableVertices(V, i, visited);\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-\n-        int vertices, edges;\n-        std::cin >> veri\n-\n-    }\n-\n-}\n-#include <vector>\n-#include <unordered_set>\n-#include <cassert>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::sabotage\n-{\n-\n-typedef std::vector<std::vector<int>> adj_matrix;\n-typedef std::vector<int> vv;\n-typedef std::unordered_set<int> sv;\n-namespace mf = algorithms::graph::max_flow;\n-\n-    /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n-\n-    /** dfs based function to find all reachable vertices from s. \n-     *  The function marks visited[i] as true if i is reachable from s. \n-     *  The initial values in visited[] must be false. \n-     * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int s, sv& visited)\n-    {\n-        visited.insert(s);\n-        for (int i = 0; i < V; i++)\n-          if(mf::residual_graph[s][i] && \n-             visited.find(s) != visited.end())\n-            reachableVertices(V, i, visited);\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-\n-        int vert\n-\n-    }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609527190,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,42 @@\n+#include <vector>\n+#include <unordered_set>\n+#include <cassert>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+typedef std::vector<std::vector<int>> adj_matrix;\n+typedef std::vector<int> vv;\n+typedef std::unordered_set<int> sv;\n+namespace mf = algorithms::graph::max_flow;\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n+\n+    /** dfs based function to find all reachable vertices from s. \n+     *  The function marks visited[i] as true if i is reachable from s. \n+     *  The initial values in visited[] must be false. \n+     * We can also use BFS to find reachable vertices */\n+    void reachableVertices(int V, int s, sv& visited)\n+    {\n+        visited.insert(s);\n+        for (int i = 0; i < V; i++)\n+          if(mf::residual_graph[s][i] && \n+             visited.find(s) != visited.end())\n+            reachableVertices(V, i, visited);\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+\n+        int vertices, edges;\n+        std::cin >> vertices >> edges;\n+        adj_matrix \n+        for()\n+\n+    }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609533055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,42 @@\n+#include <vector>\n+#include <unordered_set>\n+#include <cassert>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+typedef std::vector<std::vector<int>> adj_matrix;\n+typedef std::vector<int> vv;\n+typedef std::unordered_set<int> sv;\n+namespace mf = algorithms::graph::max_flow;\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n+\n+    /** dfs based function to find all reachable vertices from s. \n+     *  The function marks visited[i] as true if i is reachable from s. \n+     *  The initial values in visited[] must be false. \n+     * We can also use BFS to find reachable vertices */\n+    void reachableVertices(int V, int s, sv& visited)\n+    {\n+        visited.insert(s);\n+        for (int i = 0; i < V; i++)\n+          if(mf::residual_graph[s][i] && \n+             visited.find(s) != visited.end())\n+            reachableVertices(V, i, visited);\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+\n+        int vertices, edges;\n+        std::cin >> vertices >> edges;\n+        adj_matrix graph\n+        for()\n+\n+    }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609540004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,93 +33,10 @@\n           assert(freopen(file.value(), \"r\", stdin) != NULL);\n \n         int vertices, edges;\n         std::cin >> vertices >> edges;\n-        adj_matrix graph\n+        adj_matrix graph = adj_matrix()\n         for()\n \n     }\n \n-}\n-#include <vector>\n-#include <unordered_set>\n-#include <cassert>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::sabotage\n-{\n-\n-typedef std::vector<std::vector<int>> adj_matrix;\n-typedef std::vector<int> vv;\n-typedef std::unordered_set<int> sv;\n-namespace mf = algorithms::graph::max_flow;\n-\n-    /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n-\n-    /** dfs based function to find all reachable vertices from s. \n-     *  The function marks visited[i] as true if i is reachable from s. \n-     *  The initial values in visited[] must be false. \n-     * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int s, sv& visited)\n-    {\n-        visited.insert(s);\n-        for (int i = 0; i < V; i++)\n-          if(mf::residual_graph[s][i] && \n-             visited.find(s) != visited.end())\n-            reachableVertices(V, i, visited);\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-\n-        int vertices, edges;\n-        std::cin >> vertices >> edges;\n-        adj_matrix \n-        for()\n-\n-    }\n-\n-}\n-#include <vector>\n-#include <unordered_set>\n-#include <cassert>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::sabotage\n-{\n-\n-typedef std::vector<std::vector<int>> adj_matrix;\n-typedef std::vector<int> vv;\n-typedef std::unordered_set<int> sv;\n-namespace mf = algorithms::graph::max_flow;\n-\n-    /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n-\n-    /** dfs based function to find all reachable vertices from s. \n-     *  The function marks visited[i] as true if i is reachable from s. \n-     *  The initial values in visited[] must be false. \n-     * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int s, sv& visited)\n-    {\n-        visited.insert(s);\n-        for (int i = 0; i < V; i++)\n-          if(mf::residual_graph[s][i] && \n-             visited.find(s) != visited.end())\n-            reachableVertices(V, i, visited);\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-\n-        int vertices, edges;\n-        std::cin >> vertices >> edges;\n-        for()\n-\n-    }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609550292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n           assert(freopen(file.value(), \"r\", stdin) != NULL);\n \n         int vertices, edges;\n         std::cin >> vertices >> edges;\n-        adj_matrix graph = adj_matrix()\n+        adj_matrix graph = adj_matrix(vertices + 1, )\n         for()\n \n     }\n \n"
                },
                {
                    "date": 1727609558532,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,42 @@\n+#include <vector>\n+#include <unordered_set>\n+#include <cassert>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+typedef std::vector<std::vector<int>> adj_matrix;\n+typedef std::vector<int> vv;\n+typedef std::unordered_set<int> sv;\n+namespace mf = algorithms::graph::max_flow;\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n+\n+    /** dfs based function to find all reachable vertices from s. \n+     *  The function marks visited[i] as true if i is reachable from s. \n+     *  The initial values in visited[] must be false. \n+     * We can also use BFS to find reachable vertices */\n+    void reachableVertices(int V, int s, sv& visited)\n+    {\n+        visited.insert(s);\n+        for (int i = 0; i < V; i++)\n+          if(mf::residual_graph[s][i] && \n+             visited.find(s) != visited.end())\n+            reachableVertices(V, i, visited);\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+\n+        int vertices, edges;\n+        std::cin >> vertices >> edges;\n+        adj_matrix graph = adj_matrix(vertices + 1, vv(adj_matrix + 1));\n+        for(int )\n+\n+    }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609567454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,51 +34,10 @@\n \n         int vertices, edges;\n         std::cin >> vertices >> edges;\n         adj_matrix graph = adj_matrix(vertices + 1, vv(adj_matrix + 1));\n-        for(int )\n+        for(int i = 0; i < edges; i++)\n+        \n \n     }\n \n-}\n-#include <vector>\n-#include <unordered_set>\n-#include <cassert>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::sabotage\n-{\n-\n-typedef std::vector<std::vector<int>> adj_matrix;\n-typedef std::vector<int> vv;\n-typedef std::unordered_set<int> sv;\n-namespace mf = algorithms::graph::max_flow;\n-\n-    /** https://onlinejudge.org/external/104/10480.pdf */\n-    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n-\n-    /** dfs based function to find all reachable vertices from s. \n-     *  The function marks visited[i] as true if i is reachable from s. \n-     *  The initial values in visited[] must be false. \n-     * We can also use BFS to find reachable vertices */\n-    void reachableVertices(int V, int s, sv& visited)\n-    {\n-        visited.insert(s);\n-        for (int i = 0; i < V; i++)\n-          if(mf::residual_graph[s][i] && \n-             visited.find(s) != visited.end())\n-            reachableVertices(V, i, visited);\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-\n-        int vertices, edges;\n-        std::cin >> vertices >> edges;\n-        adj_matrix graph = adj_matrix(vertices + 1, )\n-        for()\n-\n-    }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609587677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,11 @@\n         int vertices, edges;\n         std::cin >> vertices >> edges;\n         adj_matrix graph = adj_matrix(vertices + 1, vv(adj_matrix + 1));\n         for(int i = 0; i < edges; i++)\n-        \n+        {\n+            int f\n+        }\n \n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727609604214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,11 @@\n         std::cin >> vertices >> edges;\n         adj_matrix graph = adj_matrix(vertices + 1, vv(adj_matrix + 1));\n         for(int i = 0; i < edges; i++)\n         {\n-            int f\n+            int from, to, w;\n+            std::cin >> from >> to >> w;\n+            --from\n         }\n \n     }\n \n"
                },
                {
                    "date": 1727609611439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,10 @@\n         for(int i = 0; i < edges; i++)\n         {\n             int from, to, w;\n             std::cin >> from >> to >> w;\n-            --from\n+            --from; --to;\n+            adj\n         }\n \n     }\n \n"
                },
                {
                    "date": 1727609617034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,9 @@\n         {\n             int from, to, w;\n             std::cin >> from >> to >> w;\n             --from; --to;\n-            gra\n+            graph[from]\n         }\n \n     }\n \n"
                },
                {
                    "date": 1727609623006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,48 @@\n+#include <vector>\n+#include <unordered_set>\n+#include <cassert>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::sabotage\n+{\n+\n+typedef std::vector<std::vector<int>> adj_matrix;\n+typedef std::vector<int> vv;\n+typedef std::unordered_set<int> sv;\n+namespace mf = algorithms::graph::max_flow;\n+\n+    /** https://onlinejudge.org/external/104/10480.pdf */\n+    void performEdmondsKarp(int V, int capital, int major, const adj_matrix& g) {}\n+\n+    /** dfs based function to find all reachable vertices from s. \n+     *  The function marks visited[i] as true if i is reachable from s. \n+     *  The initial values in visited[] must be false. \n+     * We can also use BFS to find reachable vertices */\n+    void reachableVertices(int V, int s, sv& visited)\n+    {\n+        visited.insert(s);\n+        for (int i = 0; i < V; i++)\n+          if(mf::residual_graph[s][i] && \n+             visited.find(s) != visited.end())\n+            reachableVertices(V, i, visited);\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+\n+        int vertices, edges;\n+        std::cin >> vertices >> edges;\n+        adj_matrix graph = adj_matrix(vertices + 1, vv(adj_matrix + 1));\n+        for(int i = 0; i < edges; i++)\n+        {\n+            int from, to, w;\n+            std::cin >> from >> to >> w;\n+            --from; --to;\n+            graph[from][to] = w;\n+        }\n+\n+    }\n+\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1727607980107,
            "name": "Commit-0",
            "content": "\n\nnamespace algorithms::graph::onlinejudge::sabotage\n{\n    \n}"
        }
    ]
}