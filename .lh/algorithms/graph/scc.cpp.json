{
    "sourceFile": "algorithms/graph/scc.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1724229502217,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1724229510109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,2 +1,5 @@\n \n-namespace algorithms::graph::\n\\ No newline at end of file\n+namespace algorithms::graph::scc\n+{\n+    \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724229518006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,10 @@\n \n namespace algorithms::graph::scc\n {\n-    \n+\n+    /**\n+     * \n+     * \n+     * \n+     */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724229830266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n namespace algorithms::graph::scc\n {\n \n     /**\n+     * The basic idea of the algorithm is that SCCs form subtrees in the DFS spanning tree (compare the original directed graph and the DFS spanning tree in Figure 4.9). On top of computing dfs_num(u) and dfs_low(u) for each vertex, we also append vertex u to the back of a stack S (here the stack is implemented with a vector) and keep track of the vertices that are currently explored via vi visited. The condition to update dfs_low(u) is slightly different from the previous DFS algorithm for finding articulation points and bridges. Here, only vertices that currently have visited flag turned on (part of the current SCC) that can update dfs_low(u). Now, if we have vertex u in this DFS spanning tree with dfs_low(u) = dfs_num(u), we can conclude that u is the root (start) of an SCC (observe vertex 0, 1, and 4) in Figure 4.9) and the members of those SCCs are identified by popping the current content of stack S until we reach vertex u (the root) of SCC again\n      * \n      * \n-     * \n      */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724229835306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n namespace algorithms::graph::scc\n {\n \n     /**\n-     * The basic idea of the algorithm is that SCCs form subtrees in the DFS spanning tree (compare the original directed graph and the DFS spanning tree in Figure 4.9). On top of computing dfs_num(u) and dfs_low(u) for each vertex, we also append vertex u to the back of a stack S (here the stack is implemented with a vector) and keep track of the vertices that are currently explored via vi visited. The condition to update dfs_low(u) is slightly different from the previous DFS algorithm for finding articulation points and bridges. Here, only vertices that currently have visited flag turned on (part of the current SCC) that can update dfs_low(u). Now, if we have vertex u in this DFS spanning tree with dfs_low(u) = dfs_num(u), we can conclude that u is the root (start) of an SCC (observe vertex 0, 1, and 4) in Figure 4.9) and the members of those SCCs are identified by popping the current content of stack S until we reach vertex u (the root) of SCC again\n+     *  The basic idea of the algorithm is that SCCs form subtrees in the DFS spanning tree (compare the original directed graph and the DFS spanning tree in Figure 4.9). On top of computing dfs_num(u) and dfs_low(u) for each vertex, we also append vertex u to the back of a stack S (here the stack is implemented with a vector) and keep track of the vertices that are currently explored via vi visited. The condition to update dfs_low(u) is slightly different from the previous DFS algorithm for finding articulation points and bridges. Here, only vertices that currently have visited flag turned on (part of the current SCC) that can update dfs_low(u). Now, if we have vertex u in this DFS spanning tree with dfs_low(u) = dfs_num(u), we can conclude that u is the root (start) of an SCC (observe vertex 0, 1, and 4) in Figure 4.9) and the members of those SCCs are identified by popping the current content of stack S until we reach vertex u (the root) of SCC again\n      * \n      * \n      */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724229843002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,11 @@\n+\n+namespace algorithms::graph::scc\n+{\n+\n+    /**\n+     *  The basic idea of the algorithm is that SCCs form subtrees in the DFS spanning tree \n+     *  (compare the original directed graph and the DFS spanning tree in Figure 4.9). On top of computing dfs_num(u) and dfs_low(u) for each vertex, we also append vertex u to the back of a stack S (here the stack is implemented with a vector) and keep track of the vertices that are currently explored via vi visited. The condition to update dfs_low(u) is slightly different from the previous DFS algorithm for finding articulation points and bridges. Here, only vertices that currently have visited flag turned on (part of the current SCC) that can update dfs_low(u). Now, if we have vertex u in this DFS spanning tree with dfs_low(u) = dfs_num(u), we can conclude that u is the root (start) of an SCC (observe vertex 0, 1, and 4) in Figure 4.9) and the members of those SCCs are identified by popping the current content of stack S until we reach vertex u (the root) of SCC again\n+     * \n+     * \n+     */\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724229853897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,10 @@\n \n     /**\n      *  The basic idea of the algorithm is that SCCs form subtrees in the DFS spanning tree \n      *  (compare the original directed graph and the DFS spanning tree in Figure 4.9). \n-     *  On top of computing dfs_num(u) and dfs_low(u) for each vertex, we also append vertex u to the back of a stack S (here the stack is implemented with a vector) and keep track of the vertices that are currently explored via vi visited. The condition to update dfs_low(u) is slightly different from the previous DFS algorithm for finding articulation points and bridges. Here, only vertices that currently have visited flag turned on (part of the current SCC) that can update dfs_low(u). Now, if we have vertex u in this DFS spanning tree with dfs_low(u) = dfs_num(u), we can conclude that u is the root (start) of an SCC (observe vertex 0, 1, and 4) in Figure 4.9) and the members of those SCCs are identified by popping the current content of stack S until we reach vertex u (the root) of SCC again\n+     *  On top of computing dfs_num(u) and dfs_low(u) for each vertex, \n+     *  we also append vertex u to the back of a stack S (here the stack is implemented with a vector) and keep track of the vertices that are currently explored via vi visited. The condition to update dfs_low(u) is slightly different from the previous DFS algorithm for finding articulation points and bridges. Here, only vertices that currently have visited flag turned on (part of the current SCC) that can update dfs_low(u). Now, if we have vertex u in this DFS spanning tree with dfs_low(u) = dfs_num(u), we can conclude that u is the root (start) of an SCC (observe vertex 0, 1, and 4) in Figure 4.9) and the members of those SCCs are identified by popping the current content of stack S until we reach vertex u (the root) of SCC again\n      * \n      * \n      */\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724229860041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,10 @@\n      *  The basic idea of the algorithm is that SCCs form subtrees in the DFS spanning tree \n      *  (compare the original directed graph and the DFS spanning tree in Figure 4.9). \n      *  On top of computing dfs_num(u) and dfs_low(u) for each vertex, \n      *  we also append vertex u to the back of a stack S (here the stack is implemented with a vector) \n-     *  and keep track of the vertices that are currently explored via vi visited. The condition to update dfs_low(u) is slightly different from the previous DFS algorithm for finding articulation points and bridges. Here, only vertices that currently have visited flag turned on (part of the current SCC) that can update dfs_low(u). Now, if we have vertex u in this DFS spanning tree with dfs_low(u) = dfs_num(u), we can conclude that u is the root (start) of an SCC (observe vertex 0, 1, and 4) in Figure 4.9) and the members of those SCCs are identified by popping the current content of stack S until we reach vertex u (the root) of SCC again\n+     *  and keep track of the vertices that are currently explored via vi visited. \n+     *  The condition to update dfs_low(u) is slightly different from the previous DFS algorithm for finding articulation points and bridges. Here, only vertices that currently have visited flag turned on (part of the current SCC) that can update dfs_low(u). Now, if we have vertex u in this DFS spanning tree with dfs_low(u) = dfs_num(u), we can conclude that u is the root (start) of an SCC (observe vertex 0, 1, and 4) in Figure 4.9) and the members of those SCCs are identified by popping the current content of stack S until we reach vertex u (the root) of SCC again\n      * \n      * \n      */\n }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1724229502217,
            "name": "Commit-0",
            "content": "\nnamespace algorithms::graph::"
        }
    ]
}