{
    "sourceFile": "algorithms/graph/onlinejudge/countWays.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 18,
            "patches": [
                {
                    "date": 1726830941676,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1726830992054,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,37 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::onlinejudge::ways_to_live\n+{\n+\n+\n+typedef std::vector<std::vector<int>> graph;\n+typedef std::vector<int> table;\n+\n+\n+    /** https://onlinejudge.org/external/9/988.pdf\n+     * UVa 988 - Many paths, one destination\n+     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n+     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n+     * given a specific set of choices at each point in time. One is given a list of events, and a\n+     * number of choices that can be selected, for each event. The objective is to count how many\n+     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n+     * further choices (that is, death, index n).\n+     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n+     * time, but cannot go backward. The number of such paths can be found easily by computing\n+     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n+     * first in the topological order and the vertex n/death will always be the last in the topological\n+     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n+     * one by one according to the topological order. When processing a vertex u, we update each\n+     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n+     * we will know the number of paths in num paths[n] */\n+    int countWays(int v, const graph& g)\n+    {\n+        table dp = table(v, -1);\n+        dp[0] = 1;\n+        for(int i = 1; i < v; i++)\n+          for(auto v : g[i])\n+            dp[v] += dp[i - 1];\n+        return dp[v - 1];\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1726831009830,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n      * we will know the number of paths in num paths[n] */\n     int countWays(int v, const graph& g)\n     {\n         table dp = table(v, -1);\n-        dp[0] = 1;\n+        dp[0] = 0;\n         for(int i = 1; i < v; i++)\n           for(auto v : g[i])\n             dp[v] += dp[i - 1];\n         return dp[v - 1];\n"
                },
                {
                    "date": 1726831016424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,47 +28,10 @@\n     int countWays(int v, const graph& g)\n     {\n         table dp = table(v, -1);\n         dp[0] = 0;\n-        for(int i = 1; i < v; i++)\n+        for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n-            dp[v] += dp[i - 1];\n+            dp[v] += dp[i];\n         return dp[v - 1];\n     }\n-}\n-#include <vector>\n-\n-\n-namespace algorithms::graph::onlinejudge::ways_to_live\n-{\n-\n-\n-typedef std::vector<std::vector<int> graph;\n-typedef std::vector<int> table;\n-\n-\n-    /** https://onlinejudge.org/external/9/988.pdf\n-     * UVa 988 - Many paths, one destination\n-     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n-     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n-     * given a specific set of choices at each point in time. One is given a list of events, and a\n-     * number of choices that can be selected, for each event. The objective is to count how many\n-     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n-     * further choices (that is, death, index n).\n-     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n-     * time, but cannot go backward. The number of such paths can be found easily by computing\n-     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n-     * first in the topological order and the vertex n/death will always be the last in the topological\n-     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n-     * one by one according to the topological order. When processing a vertex u, we update each\n-     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n-     * we will know the number of paths in num paths[n] */\n-    int countWays(int v, const graph& g)\n-    {\n-        table dp = table(v, -1);\n-        dp[0] = 0;\n-        for(int i = 1; i < v; i++)\n-          for(auto v : g[i])\n-            dp[v] += dp[i - 1];\n-        return dp[v - 1];\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1726831034359,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n      * we will know the number of paths in num paths[n] */\n     int countWays(int v, const graph& g)\n     {\n         table dp = table(v, -1);\n-        dp[0] = 0;\n+        dp[0] = 1;\n         for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n             dp[v] += dp[i];\n         return dp[v - 1];\n"
                },
                {
                    "date": 1726831082631,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,37 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::onlinejudge::ways_to_live\n+{\n+\n+\n+typedef std::vector<std::vector<int>> graph;\n+typedef std::vector<int> table;\n+\n+\n+    /** https://onlinejudge.org/external/9/988.pdf\n+     * UVa 988 - Many paths, one destination\n+     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n+     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n+     * given a specific set of choices at each point in time. One is given a list of events, and a\n+     * number of choices that can be selected, for each event. The objective is to count how many\n+     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n+     * further choices (that is, death, index n).\n+     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n+     * time, but cannot go backward. The number of such paths can be found easily by computing\n+     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n+     * first in the topological order and the vertex n/death will always be the last in the topological\n+     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n+     * one by one according to the topological order. When processing a vertex u, we update each\n+     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n+     * we will know the number of paths in num paths[n] */\n+    int countWays(int v, const graph& g)\n+    {\n+        table dp = table(v, -1);\n+        dp[0] = 1;\n+        for(int i = 0; i < v; i++)\n+          for(auto v : g[i])\n+            dp[v] += dp[i];\n+        return dp[v - 1];\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1726831089243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,37 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::onlinejudge::ways_to_live\n+{\n+\n+\n+typedef std::vector<std::vector<int>> graph;\n+typedef std::vector<int> table;\n+\n+\n+    /** https://onlinejudge.org/external/9/988.pdf\n+     * UVa 988 - Many paths, one destination\n+     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n+     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n+     * given a specific set of choices at each point in time. One is given a list of events, and a\n+     * number of choices that can be selected, for each event. The objective is to count how many\n+     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n+     * further choices (that is, death, index n).\n+     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n+     * time, but cannot go backward. The number of such paths can be found easily by computing\n+     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n+     * first in the topological order and the vertex n/death will always be the last in the topological\n+     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n+     * one by one according to the topological order. When processing a vertex u, we update each\n+     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n+     * we will know the number of paths in num paths[n] */\n+    int countWays(int v, const graph& g)\n+    {\n+        table dp = table(v, -1);\n+        dp[0] = 1;\n+        for(int i = 0; i < v; i++)\n+          for(auto v : g[i])\n+            dp[v] += dp[i];\n+        return dp[v - 1];\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1726831111026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,81 +31,12 @@\n         dp[0] = 1;\n         for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n             dp[v] += dp[i];\n-        return dp[v - 1];\n-    }\n-}\n-#include <vector>\n+         \n+        for(auto d : dp)\n+          cout << d << \" \"; \n+        cout << \"\\n\";\n \n-\n-namespace algorithms::graph::onlinejudge::ways_to_live\n-{\n-\n-\n-typedef std::vector<std::vector<int>> graph;\n-typedef std::vector<int> table;\n-\n-\n-    /** https://onlinejudge.org/external/9/988.pdf\n-     * UVa 988 - Many paths, one destination\n-     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n-     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n-     * given a specific set of choices at each point in time. One is given a list of events, and a\n-     * number of choices that can be selected, for each event. The objective is to count how many\n-     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n-     * further choices (that is, death, index n).\n-     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n-     * time, but cannot go backward. The number of such paths can be found easily by computing\n-     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n-     * first in the topological order and the vertex n/death will always be the last in the topological\n-     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n-     * one by one according to the topological order. When processing a vertex u, we update each\n-     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n-     * we will know the number of paths in num paths[n] */\n-    int countWays(int v, const graph& g)\n-    {\n-        table dp = table(v, -1);\n-        dp[0] = 1;\n-        for(int i = 0; i < v; i++)\n-          for(auto v : g[i])\n-            dp[v] += dp[i];\n         return dp[v - 1];\n     }\n-}\n-#include <vector>\n-\n-\n-namespace algorithms::graph::onlinejudge::ways_to_live\n-{\n-\n-\n-typedef std::vector<std::vector<int>> graph;\n-typedef std::vector<int> table;\n-\n-\n-    /** https://onlinejudge.org/external/9/988.pdf\n-     * UVa 988 - Many paths, one destination\n-     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n-     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n-     * given a specific set of choices at each point in time. One is given a list of events, and a\n-     * number of choices that can be selected, for each event. The objective is to count how many\n-     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n-     * further choices (that is, death, index n).\n-     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n-     * time, but cannot go backward. The number of such paths can be found easily by computing\n-     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n-     * first in the topological order and the vertex n/death will always be the last in the topological\n-     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n-     * one by one according to the topological order. When processing a vertex u, we update each\n-     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n-     * we will know the number of paths in num paths[n] */\n-    int countWays(int v, const graph& g)\n-    {\n-        table dp = table(v, -1);\n-        dp[0] = 1;\n-        for(int i = 0; i < v; i++)\n-          for(auto v : g[i])\n-            dp[v] += dp[i];\n-        return dp[v - 1];\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1726831158306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,42 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::onlinejudge::ways_to_live\n+{\n+\n+\n+typedef std::vector<std::vector<int>> graph;\n+typedef std::vector<int> table;\n+\n+\n+    /** https://onlinejudge.org/external/9/988.pdf\n+     * UVa 988 - Many paths, one destination\n+     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n+     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n+     * given a specific set of choices at each point in time. One is given a list of events, and a\n+     * number of choices that can be selected, for each event. The objective is to count how many\n+     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n+     * further choices (that is, death, index n).\n+     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n+     * time, but cannot go backward. The number of such paths can be found easily by computing\n+     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n+     * first in the topological order and the vertex n/death will always be the last in the topological\n+     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n+     * one by one according to the topological order. When processing a vertex u, we update each\n+     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n+     * we will know the number of paths in num paths[n] */\n+    int countWays(int v, const graph& g)\n+    {\n+        table dp = table(v, 0);\n+        dp[0] = 1;\n+        for(int i = 0; i < v; i++)\n+          for(auto v : g[i])\n+            dp[v] += dp[i];\n+         \n+        for(auto d : dp)\n+          cout << d << \" \"; \n+        cout << \"\\n\";\n+\n+        return dp[v - 1];\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1726831290435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,9 @@\n      * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n      * we will know the number of paths in num paths[n] */\n     int countWays(int v, const graph& g)\n     {\n+        std::vector<int> \n         table dp = table(v, 0);\n         dp[0] = 1;\n         for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n@@ -38,47 +39,5 @@\n         cout << \"\\n\";\n \n         return dp[v - 1];\n     }\n-}\n-#include <vector>\n-\n-\n-namespace algorithms::graph::onlinejudge::ways_to_live\n-{\n-\n-\n-typedef std::vector<std::vector<int>> graph;\n-typedef std::vector<int> table;\n-\n-\n-    /** https://onlinejudge.org/external/9/988.pdf\n-     * UVa 988 - Many paths, one destination\n-     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n-     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n-     * given a specific set of choices at each point in time. One is given a list of events, and a\n-     * number of choices that can be selected, for each event. The objective is to count how many\n-     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n-     * further choices (that is, death, index n).\n-     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n-     * time, but cannot go backward. The number of such paths can be found easily by computing\n-     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n-     * first in the topological order and the vertex n/death will always be the last in the topological\n-     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n-     * one by one according to the topological order. When processing a vertex u, we update each\n-     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n-     * we will know the number of paths in num paths[n] */\n-    int countWays(int v, const graph& g)\n-    {\n-        table dp = table(v, -1);\n-        dp[0] = 1;\n-        for(int i = 0; i < v; i++)\n-          for(auto v : g[i])\n-            dp[v] += dp[i];\n-         \n-        for(auto d : dp)\n-          cout << d << \" \"; \n-        cout << \"\\n\";\n-\n-        return dp[v - 1];\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1726831302532,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,43 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::onlinejudge::ways_to_live\n+{\n+\n+\n+typedef std::vector<std::vector<int>> graph;\n+typedef std::vector<int> table;\n+\n+\n+    /** https://onlinejudge.org/external/9/988.pdf\n+     * UVa 988 - Many paths, one destination\n+     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n+     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n+     * given a specific set of choices at each point in time. One is given a list of events, and a\n+     * number of choices that can be selected, for each event. The objective is to count how many\n+     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n+     * further choices (that is, death, index n).\n+     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n+     * time, but cannot go backward. The number of such paths can be found easily by computing\n+     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n+     * first in the topological order and the vertex n/death will always be the last in the topological\n+     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n+     * one by one according to the topological order. When processing a vertex u, we update each\n+     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n+     * we will know the number of paths in num paths[n] */\n+    int countWays(int v, const graph& g)\n+    {\n+        std::vector<int> termin\n+        table dp = table(v, 0);\n+        dp[0] = 1;\n+        for(int i = 0; i < v; i++)\n+          for(auto v : g[i])\n+            dp[v] += dp[i];\n+         \n+        for(auto d : dp)\n+          cout << d << \" \"; \n+        cout << \"\\n\";\n+\n+        return dp[v - 1];\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1726831309178,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n      * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n      * we will know the number of paths in num paths[n] */\n     int countWays(int v, const graph& g)\n     {\n-        std::vector<int> termin\n+        std::vector<int> terminus\n         table dp = table(v, 0);\n         dp[0] = 1;\n         for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n@@ -39,48 +39,5 @@\n         cout << \"\\n\";\n \n         return dp[v - 1];\n     }\n-}\n-#include <vector>\n-\n-\n-namespace algorithms::graph::onlinejudge::ways_to_live\n-{\n-\n-\n-typedef std::vector<std::vector<int>> graph;\n-typedef std::vector<int> table;\n-\n-\n-    /** https://onlinejudge.org/external/9/988.pdf\n-     * UVa 988 - Many paths, one destination\n-     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n-     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n-     * given a specific set of choices at each point in time. One is given a list of events, and a\n-     * number of choices that can be selected, for each event. The objective is to count how many\n-     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n-     * further choices (that is, death, index n).\n-     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n-     * time, but cannot go backward. The number of such paths can be found easily by computing\n-     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n-     * first in the topological order and the vertex n/death will always be the last in the topological\n-     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n-     * one by one according to the topological order. When processing a vertex u, we update each\n-     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n-     * we will know the number of paths in num paths[n] */\n-    int countWays(int v, const graph& g)\n-    {\n-        std::vector<int> \n-        table dp = table(v, 0);\n-        dp[0] = 1;\n-        for(int i = 0; i < v; i++)\n-          for(auto v : g[i])\n-            dp[v] += dp[i];\n-         \n-        for(auto d : dp)\n-          cout << d << \" \"; \n-        cout << \"\\n\";\n-\n-        return dp[v - 1];\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1726831315483,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,10 @@\n      * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n      * we will know the number of paths in num paths[n] */\n     int countWays(int v, const graph& g)\n     {\n-        std::vector<int> terminus\n+        std::vector<int> terminus_points;\n+        \n         table dp = table(v, 0);\n         dp[0] = 1;\n         for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n"
                },
                {
                    "date": 1726831321901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n      * we will know the number of paths in num paths[n] */\n     int countWays(int v, const graph& g)\n     {\n         std::vector<int> terminus_points;\n-        \n+        for()\n         table dp = table(v, 0);\n         dp[0] = 1;\n         for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n"
                },
                {
                    "date": 1726831327047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n      * we will know the number of paths in num paths[n] */\n     int countWays(int v, const graph& g)\n     {\n         std::vector<int> terminus_points;\n-        for()\n+        \n         table dp = table(v, 0);\n         dp[0] = 1;\n         for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n"
                },
                {
                    "date": 1726831333176,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n      * we will know the number of paths in num paths[n] */\n     int countWays(int v, const graph& g)\n     {\n         std::vector<int> terminus_points;\n-        \n+        for(auto )\n         table dp = table(v, 0);\n         dp[0] = 1;\n         for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n"
                },
                {
                    "date": 1726831339017,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,44 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::onlinejudge::ways_to_live\n+{\n+\n+\n+typedef std::vector<std::vector<int>> graph;\n+typedef std::vector<int> table;\n+\n+\n+    /** https://onlinejudge.org/external/9/988.pdf\n+     * UVa 988 - Many paths, one destination\n+     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n+     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n+     * given a specific set of choices at each point in time. One is given a list of events, and a\n+     * number of choices that can be selected, for each event. The objective is to count how many\n+     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n+     * further choices (that is, death, index n).\n+     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n+     * time, but cannot go backward. The number of such paths can be found easily by computing\n+     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n+     * first in the topological order and the vertex n/death will always be the last in the topological\n+     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n+     * one by one according to the topological order. When processing a vertex u, we update each\n+     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n+     * we will know the number of paths in num paths[n] */\n+    int countWays(int v, const graph& g)\n+    {\n+        std::vector<int> terminus_points;\n+        for(auto x : g) if()\n+        table dp = table(v, 0);\n+        dp[0] = 1;\n+        for(int i = 0; i < v; i++)\n+          for(auto v : g[i])\n+            dp[v] += dp[i];\n+         \n+        for(auto d : dp)\n+          cout << d << \" \"; \n+        cout << \"\\n\";\n+\n+        return dp[v - 1];\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1726831344537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n      * we will know the number of paths in num paths[n] */\n     int countWays(int v, const graph& g)\n     {\n         std::vector<int> terminus_points;\n-        for(auto xs : g) if(xs.)\n+        for(auto xs : g) if(xs.sz)\n         table dp = table(v, 0);\n         dp[0] = 1;\n         for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n"
                },
                {
                    "date": 1726831362164,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n      * we will know the number of paths in num paths[n] */\n     int countWays(int v, const graph& g)\n     {\n         std::vector<int> terminus_points;\n-        for(int i = 0; i < \n+        for(int i = 0; i < v; i\n         table dp = table(v, 0);\n         dp[0] = 1;\n         for(int i = 0; i < v; i++)\n           for(auto v : g[i])\n"
                }
            ],
            "date": 1726830941676,
            "name": "Commit-0",
            "content": "#include <vector>\n\n\nnamespace algorithms::graph::onlinejudge::ways_to_live\n{\n\n\ntypedef std::vector<std::vector<int> graph;\ntypedef std::vector<int> table;\n\n\n    /** https://onlinejudge.org/external/9/988.pdf\n     * UVa 988 - Many paths, one destination\n     * Motivating problem (UVa 988 - Many paths, one destination): In life, one has many paths\n     * to choose, leading to many different lives. Enumerate how many different lives one can live,\n     * given a specific set of choices at each point in time. One is given a list of events, and a\n     * number of choices that can be selected, for each event. The objective is to count how many\n     * ways to go from the event that started it all (birth, index 0) to an event where one has no \n     * further choices (that is, death, index n).\n     * Clearly the underlying graph of the problem above is a DAG as one can move forward in\n     * time, but cannot go backward. The number of such paths can be found easily by computing\n     * one (any) topological order in O(V +E) (in this problem, vertex 0/birth will always be the\n     * first in the topological order and the vertex n/death will always be the last in the topological\n     * order). We start by setting num paths[0] = 1. Then, we process the remaining vertices\n     * one by one according to the topological order. When processing a vertex u, we update each\n     * neighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps, \n     * we will know the number of paths in num paths[n] */\n    int countWays(int v, const graph& g)\n    {\n        table dp = table(v, -1);\n        dp[0] = 0;\n        for(int i = 1; i < v; i++)\n          for(auto v : g[i])\n            dp[v] += dp[i - 1];\n        return dp[v - 1];\n    }\n}"
        }
    ]
}