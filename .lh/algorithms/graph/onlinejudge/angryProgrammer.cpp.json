{
    "sourceFile": "algorithms/graph/onlinejudge/angryProgrammer.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 63,
            "patches": [
                {
                    "date": 1727260761817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1727260774055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,3 +1,5 @@\n \n \n \n+\n+namespace algorithms::graph::onlinejudge::angry\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727260782708,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,8 @@\n \n \n \n \n-namespace algorithms::graph::onlinejudge::angry\n\\ No newline at end of file\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+    \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727261872251,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,6 +3,9 @@\n \n \n namespace algorithms::graph::onlinejudge::angry_programmer\n {\n-    \n+\n+\n+\n+   \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727261894464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,8 @@\n \n namespace algorithms::graph::onlinejudge::angry_programmer\n {\n \n+typedef std::vector<>\n \n \n-   \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727261901090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,8 @@\n \n namespace algorithms::graph::onlinejudge::angry_programmer\n {\n \n-typedef std::vector<>\n+typedef std::vector<edge> graph;\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727261919328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n \n namespace algorithms::graph::onlinejudge::angry_programmer\n {\n \n+typedef std::tuple<int, int,  edge\n typedef std::vector<edge> graph;\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727261925125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n namespace algorithms::graph::onlinejudge::angry_programmer\n {\n \n-typedef std::tuple<int, int,  edge\n+typedef std::tuple<int, int, cost> edge\n typedef std::vector<edge> graph;\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727261932096,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,10 @@\n \n namespace algorithms::graph::onlinejudge::angry_programmer\n {\n \n-typedef std::tuple<int, int, cost> edge\n+typdef int cost;\n+typedef std::tuple<int, int, cost> edge;\n typedef std::vector<edge> graph;\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727261937777,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,13 @@\n \n \n \n \n+\n namespace algorithms::graph::onlinejudge::angry_programmer\n {\n \n-typdef int cost;\n+typedef int cost;\n typedef std::tuple<int, int, cost> edge;\n typedef std::vector<edge> graph;\n \n \n"
                },
                {
                    "date": 1727261950832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,8 @@\n+#include <vector>\n+#include <tuple>\n \n \n-\n-\n-\n namespace algorithms::graph::onlinejudge::angry_programmer\n {\n \n typedef int cost;\n"
                },
                {
                    "date": 1727261958508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,6 +8,8 @@\n typedef int cost;\n typedef std::tuple<int, int, cost> edge;\n typedef std::vector<edge> graph;\n \n+namespace mf = algorithms::graph::mf;\n \n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727261965280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,15 @@\n+#include <vector>\n+#include <tuple>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+\n+typedef int cost;\n+typedef std::tuple<int, int, cost> edge;\n+typedef std::vector<edge> graph;\n+\n+namespace mf = algorithms::graph::mf;\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727261984186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,17 @@\n+#include <vector>\n+#include <tuple>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+\n+typedef int cost;\n+typedef std::tuple<int, int, cost> edge;\n+typedef std::vector<edge> graph;\n+\n+namespace mf = algorithms::graph::mf;\n+\n+\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262001254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,38 +10,8 @@\n typedef std::vector<edge> graph;\n \n namespace mf = algorithms::graph::mf;\n \n+   int cal\n \n \n-\n-}\n-#include <vector>\n-#include <tuple>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::angry_programmer\n-{\n-\n-typedef int cost;\n-typedef std::tuple<int, int, cost> edge;\n-typedef std::vector<edge> graph;\n-\n-namespace mf = algorithms::graph::mf;\n-\n-\n-}\n-#include <vector>\n-#include <tuple>\n-\n-\n-namespace algorithms::graph::onlinejudge::angry_programmer\n-{\n-\n-typedef int cost;\n-typedef std::tuple<int, int, cost> edge;\n-typedef std::vector<edge> graph;\n-\n-namespace mf = algorithms::graph::mf;\n-\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262008144,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,8 @@\n typedef std::vector<edge> graph;\n \n namespace mf = algorithms::graph::mf;\n \n-   int cal\n+   int minCost\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262016521,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,8 @@\n typedef std::vector<edge> graph;\n \n namespace mf = algorithms::graph::mf;\n \n-   int minCost\n+   int minCost(int V, )\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262022060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,8 @@\n typedef std::vector<edge> graph;\n \n namespace mf = algorithms::graph::mf;\n \n-   int minCost(int V, )\n+   int minCost(int V, const graph& g)\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262035937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,7 +11,9 @@\n \n namespace mf = algorithms::graph::mf;\n \n    int minCost(int V, const graph& g)\n+   {\n+   }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262057614,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,26 @@\n namespace mf = algorithms::graph::mf;\n \n    int minCost(int V, const graph& g)\n    {\n+               mf::MAX_V = V;\n+        mf::source = 0;\n+        mf::sink = V - 1;\n+        mf::residual_graph.resize(mf::MAX_V);\n+        for(auto& x : mf::residual_graph)\n+          x.resize(mf::MAX_V);\n+\n+        for(int i = 0; i < mf::MAX_V; i++)\n+          for(int j = 0; j < mf::MAX_V; j++)\n+            mf::residual_graph[i][j] = 0;\n+        \n+        for(edge t : g)\n+        {\n+            int from = std::get<0>(t);\n+            int to = std::get<1>(t);\n+            capacity cap = std::get<2>(t);\n+            mf::residual_graph[from][to] = cap;\n+        }\n    }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262062734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n namespace mf = algorithms::graph::mf;\n \n    int minCost(int V, const graph& g)\n    {\n-               mf::MAX_V = V;\n+        mf::MAX_V = V;\n         mf::source = 0;\n         mf::sink = V - 1;\n         mf::residual_graph.resize(mf::MAX_V);\n         for(auto& x : mf::residual_graph)\n"
                },
                {
                    "date": 1727262073022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n         {\n             int from = std::get<0>(t);\n             int to = std::get<1>(t);\n             capacity cap = std::get<2>(t);\n-            mf::residual_graph[from][to] = cap;\n+            mf::residual_graph[from][to] = cost;\n         }\n    }\n \n \n"
                },
                {
                    "date": 1727262078107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n         for(edge t : g)\n         {\n             int from = std::get<0>(t);\n             int to = std::get<1>(t);\n-            capacity cap = std::get<2>(t);\n+            cost c = std::get<2>(t);\n             mf::residual_graph[from][to] = cost;\n         }\n    }\n \n"
                },
                {
                    "date": 1727262084188,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n         {\n             int from = std::get<0>(t);\n             int to = std::get<1>(t);\n             cost c = std::get<2>(t);\n-            mf::residual_graph[from][to] = cost;\n+            mf::residual_graph[from][to] = c;\n         }\n    }\n \n \n"
                },
                {
                    "date": 1727262092783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,8 +30,9 @@\n             int to = std::get<1>(t);\n             cost c = std::get<2>(t);\n             mf::residual_graph[from][to] = c;\n         }\n+        \n    }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262106264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n \n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n-        mf::source = 0;\n+        mf::source = 1;\n         mf::sink = V - 1;\n         mf::residual_graph.resize(mf::MAX_V);\n         for(auto& x : mf::residual_graph)\n           x.resize(mf::MAX_V);\n@@ -30,9 +30,10 @@\n             int to = std::get<1>(t);\n             cost c = std::get<2>(t);\n             mf::residual_graph[from][to] = c;\n         }\n-        \n+\n+\n    }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262112189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n \n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n-        mf::source = 1;\n+        mf::source = 0;\n         mf::sink = V - 1;\n         mf::residual_graph.resize(mf::MAX_V);\n         for(auto& x : mf::residual_graph)\n           x.resize(mf::MAX_V);\n"
                },
                {
                    "date": 1727262197239,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,10 +30,9 @@\n             int to = std::get<1>(t);\n             cost c = std::get<2>(t);\n             mf::residual_graph[from][to] = c;\n         }\n-\n-\n+        \n    }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262208335,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,10 @@\n             int to = std::get<1>(t);\n             cost c = std::get<2>(t);\n             mf::residual_graph[from][to] = c;\n         }\n-        \n+                mf::edmonds_karp();\n+        return mf::max_flow;\n    }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262213707,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,10 @@\n             int to = std::get<1>(t);\n             cost c = std::get<2>(t);\n             mf::residual_graph[from][to] = c;\n         }\n-                mf::edmonds_karp();\n+        \n+        mf::edmonds_karp();\n         return mf::max_flow;\n    }\n \n \n"
                },
                {
                    "date": 1727262296906,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,40 @@\n+#include <vector>\n+#include <tuple>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+\n+typedef int cost;\n+typedef std::tuple<int, int, cost> edge;\n+typedef std::vector<edge> graph;\n+\n+namespace mf = algorithms::graph::mf;\n+\n+   int minCost(int V, const graph& g)\n+   {\n+        mf::MAX_V = V;\n+        mf::source = 0;\n+        mf::sink = V - 1;\n+        mf::residual_graph.resize(mf::MAX_V);\n+        for(auto& x : mf::residual_graph)\n+          x.resize(mf::MAX_V);\n+\n+        for(int i = 0; i < mf::MAX_V; i++)\n+          for(int j = 0; j < mf::MAX_V; j++)\n+            mf::residual_graph[i][j] = 0;\n+        \n+        for(edge t : g)\n+        {\n+            int from = std::get<0>(t);\n+            int to = std::get<1>(t);\n+            cost c = std::get<2>(t);\n+            mf::residual_graph[from][to] = c;\n+        }\n+\n+        mf::edmonds_karp();\n+        return 1;\n+   }\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262307279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,11 @@\n typedef std::vector<edge> graph;\n \n namespace mf = algorithms::graph::mf;\n \n+   /**\n+    * \n+    */\n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n         mf::source = 0;\n@@ -36,45 +39,5 @@\n         return 1;\n    }\n \n \n-}\n-#include <vector>\n-#include <tuple>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::angry_programmer\n-{\n-\n-typedef int cost;\n-typedef std::tuple<int, int, cost> edge;\n-typedef std::vector<edge> graph;\n-\n-namespace mf = algorithms::graph::mf;\n-\n-   int minCost(int V, const graph& g)\n-   {\n-        mf::MAX_V = V;\n-        mf::source = 0;\n-        mf::sink = V - 1;\n-        mf::residual_graph.resize(mf::MAX_V);\n-        for(auto& x : mf::residual_graph)\n-          x.resize(mf::MAX_V);\n-\n-        for(int i = 0; i < mf::MAX_V; i++)\n-          for(int j = 0; j < mf::MAX_V; j++)\n-            mf::residual_graph[i][j] = 0;\n-        \n-        for(edge t : g)\n-        {\n-            int from = std::get<0>(t);\n-            int to = std::get<1>(t);\n-            cost c = std::get<2>(t);\n-            mf::residual_graph[from][to] = c;\n-        }\n-        \n-        mf::edmonds_karp();\n-        return mf::max_flow;\n-   }\n-\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262315638,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,10 +10,9 @@\n typedef std::vector<edge> graph;\n \n namespace mf = algorithms::graph::mf;\n \n-   /**\n-    * \n+   /*Minimum Cut problem\n     */\n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n"
                },
                {
                    "date": 1727262369984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,11 @@\n typedef std::vector<edge> graph;\n \n namespace mf = algorithms::graph::mf;\n \n-   /*Minimum Cut problem\n+   /** Minimum Cut problem\n+    * Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n+source s ∈ S-component and sink t ∈ T-component\n     */\n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n"
                },
                {
                    "date": 1727262376260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n namespace mf = algorithms::graph::mf;\n \n    /** Minimum Cut problem\n     * Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n-source s ∈ S-component and sink t ∈ T-component\n+    * source s ∈ S-component and sink t ∈ T-component\n     */\n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n"
                },
                {
                    "date": 1727262396463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,10 +11,14 @@\n \n namespace mf = algorithms::graph::mf;\n \n    /** Minimum Cut problem\n-    * Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n-    * source s ∈ S-component and sink t ∈ T-component\n+    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n+    *  source s ∈ S-component and sink t ∈ T-component.\n+    * The by-product of computing Max Flow is Min Cut! Let’s see\n+Figure 4.24.D again. After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n+from source s again. All reachable vertices from source s using positive weighted edges in\n+the residual graph belong to the S-component\n     */\n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n"
                },
                {
                    "date": 1727262403956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,10 +13,9 @@\n \n    /** Minimum Cut problem\n     *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n     *  source s ∈ S-component and sink t ∈ T-component.\n-    * The by-product of computing Max Flow is Min Cut! Let’s see\n-Figure 4.24.D again. After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n+    * The by-product of computing Max Flow is Min Cut! After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n from source s again. All reachable vertices from source s using positive weighted edges in\n the residual graph belong to the S-component\n     */\n    int minCost(int V, const graph& g)\n"
                },
                {
                    "date": 1727262410467,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,10 @@\n \n    /** Minimum Cut problem\n     *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n     *  source s ∈ S-component and sink t ∈ T-component.\n-    * The by-product of computing Max Flow is Min Cut! After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n+    * The by-product of computing Max Flow is Min Cut! \n+    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n from source s again. All reachable vertices from source s using positive weighted edges in\n the residual graph belong to the S-component\n     */\n    int minCost(int V, const graph& g)\n"
                },
                {
                    "date": 1727262415563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,48 @@\n+#include <vector>\n+#include <tuple>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+\n+typedef int cost;\n+typedef std::tuple<int, int, cost> edge;\n+typedef std::vector<edge> graph;\n+\n+namespace mf = algorithms::graph::mf;\n+\n+   /** Minimum Cut problem\n+    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n+    *  source s ∈ S-component and sink t ∈ T-component.\n+    * The by-product of computing Max Flow is Min Cut! \n+    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n+    * from source s again. All reachable vertices from source s using positive weighted edges in\n+the residual graph belong to the S-component\n+    */\n+   int minCost(int V, const graph& g)\n+   {\n+        mf::MAX_V = V;\n+        mf::source = 0;\n+        mf::sink = V - 1;\n+        mf::residual_graph.resize(mf::MAX_V);\n+        for(auto& x : mf::residual_graph)\n+          x.resize(mf::MAX_V);\n+\n+        for(int i = 0; i < mf::MAX_V; i++)\n+          for(int j = 0; j < mf::MAX_V; j++)\n+            mf::residual_graph[i][j] = 0;\n+        \n+        for(edge t : g)\n+        {\n+            int from = std::get<0>(t);\n+            int to = std::get<1>(t);\n+            cost c = std::get<2>(t);\n+            mf::residual_graph[from][to] = c;\n+        }\n+\n+        mf::edmonds_karp();\n+        return 1;\n+   }\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262422627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,10 +15,10 @@\n     *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n     *  source s ∈ S-component and sink t ∈ T-component.\n     * The by-product of computing Max Flow is Min Cut! \n     * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n-    * from source s again. All reachable vertices from source s using positive weighted edges in\n-the residual graph belong to the S-component\n+    * from source s again. All reachable vertices from source s using positive weighted edges in \n+    * the residual graph belong to the S-component\n     */\n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n@@ -44,53 +44,5 @@\n         return 1;\n    }\n \n \n-}\n-#include <vector>\n-#include <tuple>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::angry_programmer\n-{\n-\n-typedef int cost;\n-typedef std::tuple<int, int, cost> edge;\n-typedef std::vector<edge> graph;\n-\n-namespace mf = algorithms::graph::mf;\n-\n-   /** Minimum Cut problem\n-    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n-    *  source s ∈ S-component and sink t ∈ T-component.\n-    * The by-product of computing Max Flow is Min Cut! \n-    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n-from source s again. All reachable vertices from source s using positive weighted edges in\n-the residual graph belong to the S-component\n-    */\n-   int minCost(int V, const graph& g)\n-   {\n-        mf::MAX_V = V;\n-        mf::source = 0;\n-        mf::sink = V - 1;\n-        mf::residual_graph.resize(mf::MAX_V);\n-        for(auto& x : mf::residual_graph)\n-          x.resize(mf::MAX_V);\n-\n-        for(int i = 0; i < mf::MAX_V; i++)\n-          for(int j = 0; j < mf::MAX_V; j++)\n-            mf::residual_graph[i][j] = 0;\n-        \n-        for(edge t : g)\n-        {\n-            int from = std::get<0>(t);\n-            int to = std::get<1>(t);\n-            cost c = std::get<2>(t);\n-            mf::residual_graph[from][to] = c;\n-        }\n-\n-        mf::edmonds_karp();\n-        return 1;\n-   }\n-\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262500259,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     *  source s ∈ S-component and sink t ∈ T-component.\n     * The by-product of computing Max Flow is Min Cut! \n     * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n     * from source s again. All reachable vertices from source s using positive weighted edges in \n-    * the residual graph belong to the S-component\n+    * the residual graph belong to the S-component. All other unreachable\n     */\n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n"
                },
                {
                    "date": 1727262523306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,10 @@\n     *  source s ∈ S-component and sink t ∈ T-component.\n     * The by-product of computing Max Flow is Min Cut! \n     * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n     * from source s again. All reachable vertices from source s using positive weighted edges in \n-    * the residual graph belong to the S-component. All other unreachable\n+    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). All edges connecting the S-\n+component to the T-component belong to the cut-set of C\n     */\n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n"
                },
                {
                    "date": 1727262529366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,10 +16,10 @@\n     *  source s ∈ S-component and sink t ∈ T-component.\n     * The by-product of computing Max Flow is Min Cut! \n     * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n     * from source s again. All reachable vertices from source s using positive weighted edges in \n-    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). All edges connecting the S-\n-component to the T-component belong to the cut-set of C\n+    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n+    * All edges connecting the S-component to the T-component belong to the cut-set of C\n     */\n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n"
                },
                {
                    "date": 1727262536037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,49 @@\n+#include <vector>\n+#include <tuple>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+\n+typedef int cost;\n+typedef std::tuple<int, int, cost> edge;\n+typedef std::vector<edge> graph;\n+\n+namespace mf = algorithms::graph::mf;\n+\n+   /** Minimum Cut problem\n+    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n+    *  source s ∈ S-component and sink t ∈ T-component.\n+    * The by-product of computing Max Flow is Min Cut! \n+    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n+    * from source s again. All reachable vertices from source s using positive weighted edges in \n+    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n+    * All edges connecting the S-component to the T-component belong to the cut-set of C\n+    */\n+   int minCost(int V, const graph& g)\n+   {\n+        mf::MAX_V = V;\n+        mf::source = 0;\n+        mf::sink = V - 1;\n+        mf::residual_graph.resize(mf::MAX_V);\n+        for(auto& x : mf::residual_graph)\n+          x.resize(mf::MAX_V);\n+\n+        for(int i = 0; i < mf::MAX_V; i++)\n+          for(int j = 0; j < mf::MAX_V; j++)\n+            mf::residual_graph[i][j] = 0;\n+        \n+        for(edge t : g)\n+        {\n+            int from = std::get<0>(t);\n+            int to = std::get<1>(t);\n+            cost c = std::get<2>(t);\n+            mf::residual_graph[from][to] = c;\n+        }\n+\n+        mf::edmonds_karp();\n+        return 1;\n+   }\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262543355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,10 +17,9 @@\n     * The by-product of computing Max Flow is Min Cut! \n     * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n     * from source s again. All reachable vertices from source s using positive weighted edges in \n     * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n-    * All edges connecting the S-component to the T-component belong to the cut-set of C\n-    */\n+    * All edges connecting the S-component to the T-component belong to the cut-set of C */\n    int minCost(int V, const graph& g)\n    {\n         mf::MAX_V = V;\n         mf::source = 0;\n@@ -45,54 +44,5 @@\n         return 1;\n    }\n \n \n-}\n-#include <vector>\n-#include <tuple>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::angry_programmer\n-{\n-\n-typedef int cost;\n-typedef std::tuple<int, int, cost> edge;\n-typedef std::vector<edge> graph;\n-\n-namespace mf = algorithms::graph::mf;\n-\n-   /** Minimum Cut problem\n-    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n-    *  source s ∈ S-component and sink t ∈ T-component.\n-    * The by-product of computing Max Flow is Min Cut! \n-    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n-    * from source s again. All reachable vertices from source s using positive weighted edges in \n-    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n-    * All edges connecting the S-component to the T-component belong to the cut-set of C\n-    */\n-   int minCost(int V, const graph& g)\n-   {\n-        mf::MAX_V = V;\n-        mf::source = 0;\n-        mf::sink = V - 1;\n-        mf::residual_graph.resize(mf::MAX_V);\n-        for(auto& x : mf::residual_graph)\n-          x.resize(mf::MAX_V);\n-\n-        for(int i = 0; i < mf::MAX_V; i++)\n-          for(int j = 0; j < mf::MAX_V; j++)\n-            mf::residual_graph[i][j] = 0;\n-        \n-        for(edge t : g)\n-        {\n-            int from = std::get<0>(t);\n-            int to = std::get<1>(t);\n-            cost c = std::get<2>(t);\n-            mf::residual_graph[from][to] = c;\n-        }\n-\n-        mf::edmonds_karp();\n-        return 1;\n-   }\n-\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727262725976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,8 +41,8 @@\n         }\n \n         mf::edmonds_karp();\n         return 1;\n-   }\n+   }  \n+}\n \n\\ No newline at end of file\n \n-}\n"
                },
                {
                    "date": 1727262731503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,4 +44,5 @@\n         return 1;\n    }  \n }\n \n+name\n"
                },
                {
                    "date": 1727262740327,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,5 +44,5 @@\n         return 1;\n    }  \n }\n \n-name\n+namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n"
                },
                {
                    "date": 1727262752632,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,4 +45,9 @@\n    }  \n }\n \n namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n+\n+void submit_ap()\n+{\n+    \n+}\n"
                },
                {
                    "date": 1727262757922,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,53 @@\n+#include <vector>\n+#include <tuple>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+\n+typedef int cost;\n+typedef std::tuple<int, int, cost> edge;\n+typedef std::vector<edge> graph;\n+\n+namespace mf = algorithms::graph::mf;\n+\n+   /** Minimum Cut problem\n+    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n+    *  source s ∈ S-component and sink t ∈ T-component.\n+    * The by-product of computing Max Flow is Min Cut! \n+    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n+    * from source s again. All reachable vertices from source s using positive weighted edges in \n+    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n+    * All edges connecting the S-component to the T-component belong to the cut-set of C */\n+   int minCost(int V, const graph& g)\n+   {\n+        mf::MAX_V = V;\n+        mf::source = 0;\n+        mf::sink = V - 1;\n+        mf::residual_graph.resize(mf::MAX_V);\n+        for(auto& x : mf::residual_graph)\n+          x.resize(mf::MAX_V);\n+\n+        for(int i = 0; i < mf::MAX_V; i++)\n+          for(int j = 0; j < mf::MAX_V; j++)\n+            mf::residual_graph[i][j] = 0;\n+        \n+        for(edge t : g)\n+        {\n+            int from = std::get<0>(t);\n+            int to = std::get<1>(t);\n+            cost c = std::get<2>(t);\n+            mf::residual_graph[from][to] = c;\n+        }\n+\n+        mf::edmonds_karp();\n+        return 1;\n+   }  \n+}\n+\n+namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n+\n+void submit_ap()\n+{\n+    \n+}\n"
                },
                {
                    "date": 1727262792305,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,57 +50,4 @@\n void submit_ap()\n {\n     \n }\n-#include <vector>\n-#include <tuple>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::angry_programmer\n-{\n-\n-typedef int cost;\n-typedef std::tuple<int, int, cost> edge;\n-typedef std::vector<edge> graph;\n-\n-namespace mf = algorithms::graph::mf;\n-\n-   /** Minimum Cut problem\n-    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n-    *  source s ∈ S-component and sink t ∈ T-component.\n-    * The by-product of computing Max Flow is Min Cut! \n-    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n-    * from source s again. All reachable vertices from source s using positive weighted edges in \n-    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n-    * All edges connecting the S-component to the T-component belong to the cut-set of C */\n-   int minCost(int V, const graph& g)\n-   {\n-        mf::MAX_V = V;\n-        mf::source = 0;\n-        mf::sink = V - 1;\n-        mf::residual_graph.resize(mf::MAX_V);\n-        for(auto& x : mf::residual_graph)\n-          x.resize(mf::MAX_V);\n-\n-        for(int i = 0; i < mf::MAX_V; i++)\n-          for(int j = 0; j < mf::MAX_V; j++)\n-            mf::residual_graph[i][j] = 0;\n-        \n-        for(edge t : g)\n-        {\n-            int from = std::get<0>(t);\n-            int to = std::get<1>(t);\n-            cost c = std::get<2>(t);\n-            mf::residual_graph[from][to] = c;\n-        }\n-\n-        mf::edmonds_karp();\n-        return 1;\n-   }  \n-}\n-\n-namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n-\n-void submit_ap()\n-{\n-    \n-}\n"
                },
                {
                    "date": 1727262799180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,6 +48,6 @@\n namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n \n void submit_ap()\n {\n-    \n+    int \n }\n"
                },
                {
                    "date": 1727262807378,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,6 +48,7 @@\n namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n \n void submit_ap()\n {\n-    int \n+    int m, w;\n+    \n }\n"
                },
                {
                    "date": 1727262814469,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,55 @@\n+#include <vector>\n+#include <tuple>\n+#include <cstdio>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+\n+typedef int cost;\n+typedef std::tuple<int, int, cost> edge;\n+typedef std::vector<edge> graph;\n+\n+namespace mf = algorithms::graph::mf;\n+\n+   /** Minimum Cut problem\n+    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n+    *  source s ∈ S-component and sink t ∈ T-component.\n+    * The by-product of computing Max Flow is Min Cut! \n+    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n+    * from source s again. All reachable vertices from source s using positive weighted edges in \n+    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n+    * All edges connecting the S-component to the T-component belong to the cut-set of C */\n+   int minCost(int V, const graph& g)\n+   {\n+        mf::MAX_V = V;\n+        mf::source = 0;\n+        mf::sink = V - 1;\n+        mf::residual_graph.resize(mf::MAX_V);\n+        for(auto& x : mf::residual_graph)\n+          x.resize(mf::MAX_V);\n+\n+        for(int i = 0; i < mf::MAX_V; i++)\n+          for(int j = 0; j < mf::MAX_V; j++)\n+            mf::residual_graph[i][j] = 0;\n+        \n+        for(edge t : g)\n+        {\n+            int from = std::get<0>(t);\n+            int to = std::get<1>(t);\n+            cost c = std::get<2>(t);\n+            mf::residual_graph[from][to] = c;\n+        }\n+\n+        mf::edmonds_karp();\n+        return 1;\n+   }  \n+}\n+\n+namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n+\n+void submit_ap()\n+{\n+    int m, w;\n+\n+}\n"
                },
                {
                    "date": 1727262821186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,60 +50,6 @@\n \n void submit_ap()\n {\n     int m, w;\n-\n+    scanf()\n }\n-#include <vector>\n-#include <tuple>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::angry_programmer\n-{\n-\n-typedef int cost;\n-typedef std::tuple<int, int, cost> edge;\n-typedef std::vector<edge> graph;\n-\n-namespace mf = algorithms::graph::mf;\n-\n-   /** Minimum Cut problem\n-    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n-    *  source s ∈ S-component and sink t ∈ T-component.\n-    * The by-product of computing Max Flow is Min Cut! \n-    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n-    * from source s again. All reachable vertices from source s using positive weighted edges in \n-    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n-    * All edges connecting the S-component to the T-component belong to the cut-set of C */\n-   int minCost(int V, const graph& g)\n-   {\n-        mf::MAX_V = V;\n-        mf::source = 0;\n-        mf::sink = V - 1;\n-        mf::residual_graph.resize(mf::MAX_V);\n-        for(auto& x : mf::residual_graph)\n-          x.resize(mf::MAX_V);\n-\n-        for(int i = 0; i < mf::MAX_V; i++)\n-          for(int j = 0; j < mf::MAX_V; j++)\n-            mf::residual_graph[i][j] = 0;\n-        \n-        for(edge t : g)\n-        {\n-            int from = std::get<0>(t);\n-            int to = std::get<1>(t);\n-            cost c = std::get<2>(t);\n-            mf::residual_graph[from][to] = c;\n-        }\n-\n-        mf::edmonds_karp();\n-        return 1;\n-   }  \n-}\n-\n-namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n-\n-void submit_ap()\n-{\n-    int m, w;\n-    \n-}\n"
                },
                {
                    "date": 1727262831879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,6 +50,6 @@\n \n void submit_ap()\n {\n     int m, w;\n-    scanf()\n+    whilescanf()\n }\n"
                },
                {
                    "date": 1727262838818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,58 @@\n+#include <vector>\n+#include <tuple>\n+#include <cstdio>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+\n+typedef int cost;\n+typedef std::tuple<int, int, cost> edge;\n+typedef std::vector<edge> graph;\n+\n+namespace mf = algorithms::graph::mf;\n+\n+   /** Minimum Cut problem\n+    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n+    *  source s ∈ S-component and sink t ∈ T-component.\n+    * The by-product of computing Max Flow is Min Cut! \n+    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n+    * from source s again. All reachable vertices from source s using positive weighted edges in \n+    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n+    * All edges connecting the S-component to the T-component belong to the cut-set of C */\n+   int minCost(int V, const graph& g)\n+   {\n+        mf::MAX_V = V;\n+        mf::source = 0;\n+        mf::sink = V - 1;\n+        mf::residual_graph.resize(mf::MAX_V);\n+        for(auto& x : mf::residual_graph)\n+          x.resize(mf::MAX_V);\n+\n+        for(int i = 0; i < mf::MAX_V; i++)\n+          for(int j = 0; j < mf::MAX_V; j++)\n+            mf::residual_graph[i][j] = 0;\n+        \n+        for(edge t : g)\n+        {\n+            int from = std::get<0>(t);\n+            int to = std::get<1>(t);\n+            cost c = std::get<2>(t);\n+            mf::residual_graph[from][to] = c;\n+        }\n+\n+        mf::edmonds_karp();\n+        return 1;\n+   }  \n+}\n+\n+namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n+\n+void submit_ap()\n+{\n+    int m, w;\n+    while(true)\n+    {\n+        \n+    }\n+}\n"
                },
                {
                    "date": 1727262844491,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,62 +52,7 @@\n {\n     int m, w;\n     while(true)\n     {\n-        \n+        scanf(\"\")\n     }\n }\n-#include <vector>\n-#include <tuple>\n-#include <cstdio>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::angry_programmer\n-{\n-\n-typedef int cost;\n-typedef std::tuple<int, int, cost> edge;\n-typedef std::vector<edge> graph;\n-\n-namespace mf = algorithms::graph::mf;\n-\n-   /** Minimum Cut problem\n-    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n-    *  source s ∈ S-component and sink t ∈ T-component.\n-    * The by-product of computing Max Flow is Min Cut! \n-    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n-    * from source s again. All reachable vertices from source s using positive weighted edges in \n-    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n-    * All edges connecting the S-component to the T-component belong to the cut-set of C */\n-   int minCost(int V, const graph& g)\n-   {\n-        mf::MAX_V = V;\n-        mf::source = 0;\n-        mf::sink = V - 1;\n-        mf::residual_graph.resize(mf::MAX_V);\n-        for(auto& x : mf::residual_graph)\n-          x.resize(mf::MAX_V);\n-\n-        for(int i = 0; i < mf::MAX_V; i++)\n-          for(int j = 0; j < mf::MAX_V; j++)\n-            mf::residual_graph[i][j] = 0;\n-        \n-        for(edge t : g)\n-        {\n-            int from = std::get<0>(t);\n-            int to = std::get<1>(t);\n-            cost c = std::get<2>(t);\n-            mf::residual_graph[from][to] = c;\n-        }\n-\n-        mf::edmonds_karp();\n-        return 1;\n-   }  \n-}\n-\n-namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n-\n-void submit_ap()\n-{\n-    int m, w;\n-    whilescanf()\n-}\n"
                },
                {
                    "date": 1727262850800,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,7 +52,7 @@\n {\n     int m, w;\n     while(true)\n     {\n-        scanf(\"\")\n+        scanf(\"%d %d\", )\n     }\n }\n"
                },
                {
                    "date": 1727262856579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,58 @@\n+#include <vector>\n+#include <tuple>\n+#include <cstdio>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+\n+typedef int cost;\n+typedef std::tuple<int, int, cost> edge;\n+typedef std::vector<edge> graph;\n+\n+namespace mf = algorithms::graph::mf;\n+\n+   /** Minimum Cut problem\n+    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n+    *  source s ∈ S-component and sink t ∈ T-component.\n+    * The by-product of computing Max Flow is Min Cut! \n+    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n+    * from source s again. All reachable vertices from source s using positive weighted edges in \n+    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n+    * All edges connecting the S-component to the T-component belong to the cut-set of C */\n+   int minCost(int V, const graph& g)\n+   {\n+        mf::MAX_V = V;\n+        mf::source = 0;\n+        mf::sink = V - 1;\n+        mf::residual_graph.resize(mf::MAX_V);\n+        for(auto& x : mf::residual_graph)\n+          x.resize(mf::MAX_V);\n+\n+        for(int i = 0; i < mf::MAX_V; i++)\n+          for(int j = 0; j < mf::MAX_V; j++)\n+            mf::residual_graph[i][j] = 0;\n+        \n+        for(edge t : g)\n+        {\n+            int from = std::get<0>(t);\n+            int to = std::get<1>(t);\n+            cost c = std::get<2>(t);\n+            mf::residual_graph[from][to] = c;\n+        }\n+\n+        mf::edmonds_karp();\n+        return 1;\n+   }  \n+}\n+\n+namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n+\n+void submit_ap()\n+{\n+    int m, w;\n+    while(true)\n+    {\n+        scanf(\"%d %d\", m)\n+    }\n+}\n"
                },
                {
                    "date": 1727262864109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,65 +52,8 @@\n {\n     int m, w;\n     while(true)\n     {\n-        scanf(\"%d %d\", m)\n+        scanf(\"%d %d\", &m, &w);\n+        if()\n     }\n }\n-#include <vector>\n-#include <tuple>\n-#include <cstdio>\n-#include \"../edmonds_karp.cpp\"\n-\n-namespace algorithms::graph::onlinejudge::angry_programmer\n-{\n-\n-typedef int cost;\n-typedef std::tuple<int, int, cost> edge;\n-typedef std::vector<edge> graph;\n-\n-namespace mf = algorithms::graph::mf;\n-\n-   /** Minimum Cut problem\n-    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n-    *  source s ∈ S-component and sink t ∈ T-component.\n-    * The by-product of computing Max Flow is Min Cut! \n-    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n-    * from source s again. All reachable vertices from source s using positive weighted edges in \n-    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n-    * All edges connecting the S-component to the T-component belong to the cut-set of C */\n-   int minCost(int V, const graph& g)\n-   {\n-        mf::MAX_V = V;\n-        mf::source = 0;\n-        mf::sink = V - 1;\n-        mf::residual_graph.resize(mf::MAX_V);\n-        for(auto& x : mf::residual_graph)\n-          x.resize(mf::MAX_V);\n-\n-        for(int i = 0; i < mf::MAX_V; i++)\n-          for(int j = 0; j < mf::MAX_V; j++)\n-            mf::residual_graph[i][j] = 0;\n-        \n-        for(edge t : g)\n-        {\n-            int from = std::get<0>(t);\n-            int to = std::get<1>(t);\n-            cost c = std::get<2>(t);\n-            mf::residual_graph[from][to] = c;\n-        }\n-\n-        mf::edmonds_karp();\n-        return 1;\n-   }  \n-}\n-\n-namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n-\n-void submit_ap()\n-{\n-    int m, w;\n-    while(true)\n-    {\n-        scanf(\"%d %d\", )\n-    }\n-}\n"
                },
                {
                    "date": 1727262873092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,7 +53,8 @@\n     int m, w;\n     while(true)\n     {\n         scanf(\"%d %d\", &m, &w);\n-        if()\n+        if(m == 0 && w == 0)\n+          break;\n     }\n }\n"
                },
                {
                    "date": 1727262878401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,6 +54,8 @@\n     while(true)\n     {\n         scanf(\"%d %d\", &m, &w);\n         if(m == 0 && w == 0) break;\n+\n+        \n     }\n }\n"
                },
                {
                    "date": 1727262995552,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+#include <vector>\n+#include <tuple>\n+#include <cstdio>\n+#include \"../edmonds_karp.cpp\"\n+\n+namespace algorithms::graph::onlinejudge::angry_programmer\n+{\n+\n+typedef int cost;\n+typedef std::tuple<int, int, cost> edge;\n+typedef std::vector<edge> graph;\n+\n+namespace mf = algorithms::graph::mf;\n+\n+   /** Minimum Cut problem\n+    *  Let’s define an s-t cut C = (S-component, T-component) as a partition of V ∈ G such that\n+    *  source s ∈ S-component and sink t ∈ T-component.\n+    * The by-product of computing Max Flow is Min Cut! \n+    * After Max Flow algorithm stops, we run graph traversal (DFS/BFS)\n+    * from source s again. All reachable vertices from source s using positive weighted edges in \n+    * the residual graph belong to the S-component. All other unreachable vertices belong to the T-component (i.e. vertex 1 and 3). \n+    * All edges connecting the S-component to the T-component belong to the cut-set of C */\n+   int minCost(int V, const graph& g)\n+   {\n+        mf::MAX_V = V;\n+        mf::source = 0;\n+        mf::sink = V - 1;\n+        mf::residual_graph.resize(mf::MAX_V);\n+        for(auto& x : mf::residual_graph)\n+          x.resize(mf::MAX_V);\n+\n+        for(int i = 0; i < mf::MAX_V; i++)\n+          for(int j = 0; j < mf::MAX_V; j++)\n+            mf::residual_graph[i][j] = 0;\n+        \n+        for(edge t : g)\n+        {\n+            int from = std::get<0>(t);\n+            int to = std::get<1>(t);\n+            cost c = std::get<2>(t);\n+            mf::residual_graph[from][to] = c;\n+        }\n+\n+        mf::edmonds_karp();\n+        return 1;\n+   }  \n+}\n+\n+typedef std::vector<std::pair<int, int>> \n+namespace ap = algorithms::graph::onlinejudge::angry_programmer;\n+\n+void submit_ap()\n+{\n+    int m, w;\n+    while(true)\n+    {\n+        scanf(\"%d %d\", &m, &w);\n+        if(m == 0 && w == 0) break;\n+        \n+        std::\n+        int c = m  - 2;\n+        while()\n+    }\n+}\n"
                }
            ],
            "date": 1727260761817,
            "name": "Commit-0",
            "content": "\n\n\n"
        }
    ]
}