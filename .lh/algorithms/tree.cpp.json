{
    "sourceFile": "algorithms/tree.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 15,
            "patches": [
                {
                    "date": 1715581270944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1715581297643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n \n+#include <vector>\n \n  struct TreeNode \n  {\n     int val;\n@@ -177,7 +178,6 @@\n     }\n }\n \n int deepestLeavesSum(TreeNode* root) \n-{\n-           \n+{          \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718774570558,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,9 @@\n+ struct TreeNode \n+ {\n+    int val;\n+    TreeNode *left;\n+    TreeNode *right;\n+    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n+    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n+    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n+ };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718774580676,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,192 +1,11 @@\n+ #pragma once\n+ \n  struct TreeNode \n  {\n     int val;\n     TreeNode *left;\n     TreeNode *right;\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n- };\n-\n-#include <vector>\n-\n- struct TreeNode \n- {\n-    int val;\n-    TreeNode *left;\n-    TreeNode *right;\n-    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n-    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n-    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n- };\n-  \n-std::vector<int> treePath(TreeNode* root)\n-{\n-   \n-  auto findPathSums = [](auto&& findPathSums, TreeNode* node, int currentSum, std::vector<int>& pathSums) \n-  {\n-    if (node == nullptr)\n-        return; // If the node is null, return\n-    currentSum += node->val; // Add the current node's value to the path sum\n-    // If this is a leaf node (no children), store the path sum\n-    if (node->left == nullptr && \n-        node->right == nullptr) \n-    {\n-        pathSums.push_back(currentSum);\n-    } else \n-    {\n-        // Recursively find path sums for left and right children\n-        findPathSums(findPathSums, node->left, currentSum, pathSums);\n-        findPathSums(findPathSums, node->right, currentSum, pathSums);\n-    }\n-  };\n-\n-  std::vector<int> paths = {};\n-  findPathSums(findPathSums, root, 0, paths);\n-  return paths;\n-}\n-\n-int minDepth(TreeNode* root)\n-{\n-    auto findPaths = [](auto&& findPathSums, TreeNode* node, int currentSum, std::vector<int>& paths) \n-  {\n-    if (node == nullptr)\n-        return; // If the node is null, return\n-    currentSum += 1; // Add the current node's value to the path sum\n-    // If this is a leaf node (no children), store the path sum\n-    if (node->left == nullptr &&\n-        node->right == nullptr) \n-    {\n-        paths.push_back(currentSum);\n-    } else \n-    {\n-        // Recursively find path sums for left and right children\n-        findPathSums(findPathSums, node->left, currentSum, paths);\n-        findPathSums(findPathSums, node->right, currentSum, paths);\n-    }\n-  };\n-\n-  std::vector<int> paths = {};\n-  findPaths(findPaths, root, 0, paths);\n-  std::min_element(paths.begin(), paths.end());\n-  return 1;\n-}\n-\n-vector<int> inorderTraversal(TreeNode* root)\n-{\n-    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n-    {\n-        if (node == nullptr)\n-          return;\n-        else if(node->left == nullptr && \n-                node->right == nullptr)\n-          xs.push_back(node->val);\n-        else\n-        {\n-           traverse(traverse, node->left, xs);\n-           xs.push_back(node->val);\n-           traverse(traverse, node->right, xs);\n-        }  \n-    };\n-    std::vector<int> xs = {};\n-    traverse(traverse, root, xs);\n-    return xs;\n-}\n-\n-vector<int> postorderTraversal(TreeNode* root)\n-{\n-    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n-    {\n-        if (node == nullptr)\n-          return;\n-        else if(node->left == nullptr && \n-                node->right == nullptr)\n-          xs.push_back(node->val);\n-        else\n-        {\n-           traverse(traverse, node->left, xs);\n-           traverse(traverse, node->right, xs);\n-           xs.push_back(node->val);\n-        }  \n-    };\n-    std::vector<int> xs = {};\n-    traverse(traverse, root, xs);\n-    return xs;\n-}\n-\n-vector<int> preorderTraversal(TreeNode* root)\n-{\n-    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n-    {\n-        if (node == nullptr)\n-          return;\n-        else if(node->left == nullptr && \n-                node->right == nullptr)\n-          xs.push_back(node->val);\n-        else\n-        {\n-           xs.push_back(node->val);\n-           traverse(traverse, node->left, xs);\n-           traverse(traverse, node->right, xs);\n-        }  \n-    };\n-    std::vector<int> xs = {};\n-    traverse(traverse, root, xs);\n-    return xs;\n-}\n-\n-bool treesEquality(TreeNode* first, TreeNode* second)\n-{\n-    if(first == nullptr && \n-       second == nullptr)\n-       return true;\n-    else \n-    {\n-        return first->val == second->val && \n-               treesEquality(first->left, second->left) && \n-               treesEquality(first->right, second->right);\n-    }\n-}\n-\n-bool isSubtree(TreeNode* root, TreeNode* sub)\n-{\n-    if(root == nullptr)\n-      return false;\n-    else if(treesEquality(root, sub))\n-      return true;\n-    else\n-      return isSubtree(root->left, sub) || \n-             isSubtree(root->right, sub);\n-}\n-\n-int diameterOfBinaryTree(TreeNode* root, int& diameter)\n-{\n-    if(root == nullptr)\n-      return 0;\n-    else \n-    {\n-        auto left = diameterOfBinaryTree(root->left, diameter);\n-        auto right  = diameterOfBinaryTree(root->right, diameter);\n-        diameter = max(diameter, left + right);\n-        return 1 + max(left, right);\n-    } \n-}\n-\n-TreeNode* invertTree(TreeNode* root) \n-{\n-    if(root == nullptr)\n-      return nullptr;\n-    else\n-    {\n-        auto tmp = root->left;\n-        root->left = root->right;\n-        root->right = tmp;\n-        invertTree(root->left);\n-        invertTree(root->right);\n-        return root;\n-    }\n-}\n-\n-int deepestLeavesSum(TreeNode* root) \n\\ No newline at end of file\n-{          \n-}\n+ };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718776069929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,5 +7,22 @@\n     TreeNode *right;\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n+\n+    void printBT(const std::string& prefix, const BSTNode* node, bool isLeft)\n+{\n+    if( node != nullptr )\n+    {\n+        std::cout << prefix;\n+\n+        std::cout << (isLeft ? \"├──\" : \"└──\" );\n+\n+        // print the value of the node\n+        std::cout << node->m_val << std::endl;\n+\n+        // enter the next tree level - left and right branch\n+        printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_left, true);\n+        printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_right, false);\n+    }\n+}\n  };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718776075474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,20 +9,20 @@\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n \n     void printBT(const std::string& prefix, const BSTNode* node, bool isLeft)\n-{\n-    if( node != nullptr )\n     {\n-        std::cout << prefix;\n+        if( node != nullptr )\n+        {\n+            std::cout << prefix;\n \n-        std::cout << (isLeft ? \"├──\" : \"└──\" );\n+            std::cout << (isLeft ? \"├──\" : \"└──\" );\n \n-        // print the value of the node\n-        std::cout << node->m_val << std::endl;\n+            // print the value of the node\n+            std::cout << node->m_val << std::endl;\n \n-        // enter the next tree level - left and right branch\n-        printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_left, true);\n-        printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_right, false);\n-    }\n+            // enter the next tree level - left and right branch\n+            printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_left, true);\n+            printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_right, false);\n+        }\n }\n  };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718776085746,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n  #pragma once\n  \n+ \n  struct TreeNode \n  {\n     int val;\n     TreeNode *left;\n@@ -8,9 +9,9 @@\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n \n-    void printBT(const std::string& prefix, const BSTNode* node, bool isLeft)\n+    void printBT(const std::string& prefix, const TreeNode* node, bool isLeft)\n     {\n         if( node != nullptr )\n         {\n             std::cout << prefix;\n"
                },
                {
                    "date": 1718776093579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n  #pragma once\n- \n- \n+ #include <ios\n+\n  struct TreeNode \n  {\n     int val;\n     TreeNode *left;\n"
                },
                {
                    "date": 1718776102384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n  #pragma once\n- #include <ios\n+ #include <iostream>\n+ #include <str\n \n  struct TreeNode \n  {\n     int val;\n"
                },
                {
                    "date": 1718776151239,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n  #pragma once\n  #include <iostream>\n- #include <str\n+ #include <string>\n \n  struct TreeNode \n  {\n     int val;\n@@ -19,9 +19,9 @@\n \n             std::cout << (isLeft ? \"├──\" : \"└──\" );\n \n             // print the value of the node\n-            std::cout << node->m_val << std::endl;\n+            std::cout << node->val << std::endl;\n \n             // enter the next tree level - left and right branch\n             printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_left, true);\n             printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_right, false);\n"
                },
                {
                    "date": 1718776157586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n             // print the value of the node\n             std::cout << node->val << std::endl;\n \n             // enter the next tree level - left and right branch\n-            printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_left, true);\n+            printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->, true);\n             printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_right, false);\n         }\n }\n  };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718776167689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n             // print the value of the node\n             std::cout << node->val << std::endl;\n \n             // enter the next tree level - left and right branch\n-            printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->, true);\n-            printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->m_right, false);\n+            printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->left, true);\n+            printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->right, false);\n         }\n }\n  };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718776235191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n \n-    void printBT(const std::string& prefix, const TreeNode* node, bool isLeft)\n+    void printTree(const std::string& prefix, const TreeNode* node, bool isLeft)\n     {\n         if( node != nullptr )\n         {\n             std::cout << prefix;\n"
                },
                {
                    "date": 1718776279605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n             // print the value of the node\n             std::cout << node->val << std::endl;\n \n             // enter the next tree level - left and right branch\n-            printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->left, true);\n-            printBT( prefix + (isLeft ? \"│   \" : \"    \"), node->right, false);\n+            printTree( prefix + (isLeft ? \"│   \" : \"    \"), node->left, true);\n+            printTree( prefix + (isLeft ? \"│   \" : \"    \"), node->right, false);\n         }\n }\n  };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718776297587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n \n-    public void printTree(const std::string& prefix, const TreeNode* node, bool isLeft)\n+    public printTree(const std::string& prefix, const TreeNode* node, bool isLeft)\n     {\n         if( node != nullptr )\n         {\n             std::cout << prefix;\n"
                },
                {
                    "date": 1718776313499,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n \n-\n+public:\n     public printTree(const std::string& prefix, const TreeNode* node, bool isLeft)\n     {\n         if( node != nullptr )\n         {\n"
                }
            ],
            "date": 1715581270944,
            "name": "Commit-0",
            "content": "\n\n struct TreeNode \n {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n };\n  \nstd::vector<int> treePath(TreeNode* root)\n{\n   \n  auto findPathSums = [](auto&& findPathSums, TreeNode* node, int currentSum, std::vector<int>& pathSums) \n  {\n    if (node == nullptr)\n        return; // If the node is null, return\n    currentSum += node->val; // Add the current node's value to the path sum\n    // If this is a leaf node (no children), store the path sum\n    if (node->left == nullptr && \n        node->right == nullptr) \n    {\n        pathSums.push_back(currentSum);\n    } else \n    {\n        // Recursively find path sums for left and right children\n        findPathSums(findPathSums, node->left, currentSum, pathSums);\n        findPathSums(findPathSums, node->right, currentSum, pathSums);\n    }\n  };\n\n  std::vector<int> paths = {};\n  findPathSums(findPathSums, root, 0, paths);\n  return paths;\n}\n\nint minDepth(TreeNode* root)\n{\n    auto findPaths = [](auto&& findPathSums, TreeNode* node, int currentSum, std::vector<int>& paths) \n  {\n    if (node == nullptr)\n        return; // If the node is null, return\n    currentSum += 1; // Add the current node's value to the path sum\n    // If this is a leaf node (no children), store the path sum\n    if (node->left == nullptr &&\n        node->right == nullptr) \n    {\n        paths.push_back(currentSum);\n    } else \n    {\n        // Recursively find path sums for left and right children\n        findPathSums(findPathSums, node->left, currentSum, paths);\n        findPathSums(findPathSums, node->right, currentSum, paths);\n    }\n  };\n\n  std::vector<int> paths = {};\n  findPaths(findPaths, root, 0, paths);\n  std::min_element(paths.begin(), paths.end());\n  return 1;\n}\n\nvector<int> inorderTraversal(TreeNode* root)\n{\n    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n    {\n        if (node == nullptr)\n          return;\n        else if(node->left == nullptr && \n                node->right == nullptr)\n          xs.push_back(node->val);\n        else\n        {\n           traverse(traverse, node->left, xs);\n           xs.push_back(node->val);\n           traverse(traverse, node->right, xs);\n        }  \n    };\n    std::vector<int> xs = {};\n    traverse(traverse, root, xs);\n    return xs;\n}\n\nvector<int> postorderTraversal(TreeNode* root)\n{\n    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n    {\n        if (node == nullptr)\n          return;\n        else if(node->left == nullptr && \n                node->right == nullptr)\n          xs.push_back(node->val);\n        else\n        {\n           traverse(traverse, node->left, xs);\n           traverse(traverse, node->right, xs);\n           xs.push_back(node->val);\n        }  \n    };\n    std::vector<int> xs = {};\n    traverse(traverse, root, xs);\n    return xs;\n}\n\nvector<int> preorderTraversal(TreeNode* root)\n{\n    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n    {\n        if (node == nullptr)\n          return;\n        else if(node->left == nullptr && \n                node->right == nullptr)\n          xs.push_back(node->val);\n        else\n        {\n           xs.push_back(node->val);\n           traverse(traverse, node->left, xs);\n           traverse(traverse, node->right, xs);\n        }  \n    };\n    std::vector<int> xs = {};\n    traverse(traverse, root, xs);\n    return xs;\n}\n\nbool treesEquality(TreeNode* first, TreeNode* second)\n{\n    if(first == nullptr && \n       second == nullptr)\n       return true;\n    else \n    {\n        return first->val == second->val && \n               treesEquality(first->left, second->left) && \n               treesEquality(first->right, second->right);\n    }\n}\n\nbool isSubtree(TreeNode* root, TreeNode* sub)\n{\n    if(root == nullptr)\n      return false;\n    else if(treesEquality(root, sub))\n      return true;\n    else\n      return isSubtree(root->left, sub) || \n             isSubtree(root->right, sub);\n}\n\nint diameterOfBinaryTree(TreeNode* root, int& diameter)\n{\n    if(root == nullptr)\n      return 0;\n    else \n    {\n        auto left = diameterOfBinaryTree(root->left, diameter);\n        auto right  = diameterOfBinaryTree(root->right, diameter);\n        diameter = max(diameter, left + right);\n        return 1 + max(left, right);\n    } \n}\n\nTreeNode* invertTree(TreeNode* root) \n{\n    if(root == nullptr)\n      return nullptr;\n    else\n    {\n        auto tmp = root->left;\n        root->left = root->right;\n        root->right = tmp;\n        invertTree(root->left);\n        invertTree(root->right);\n        return root;\n    }\n}\n\nint deepestLeavesSum(TreeNode* root) \n{\n           \n}"
        }
    ]
}