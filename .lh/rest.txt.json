{
    "sourceFile": "rest.txt",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1729351719987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1729351719987,
            "name": "Commit-0",
            "content": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nnamespace algorithms::dp::leetcode::boxes\n{\n\nstruct Box\n{\n    int count;\n    int left;\n    int right;\n};\n\n\n#define loop(x, s, n) for(int x = s; x < n; x++)\n#define back_loop(x, s, n) for(int x = s; x > n; x--)\ntypedef std::vector<int> vi;\ntypedef std::vector<vi> vvi;\ntypedef std::vector<std::pair<int, int>> vp;\ntypedef std::vector<std::vector<int>> table;\ntypedef std::vector<Box> vbox;\n\n    // https://leetcode.com/problems/remove-boxes\n    /** You are given several boxes with different colors represented by different positive numbers.\n     *  You may experience several rounds to remove boxes until there is no box left. \n     *  Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k >= 1), \n     *  remove them and get k * k points. Return the maximum points you can get. \n     *  objective function: f(i, j) = n \n     *  some shrewd observation drawn from https://medium.com/@haohsiangchung/leetcode-remove-boxes-ae7f2d1e1c90 */\n    int BOX_SIZE;\n    Box getBox(const vi& boxes, int p, int r)\n    {\n        int l = 0;\n        int cnt_l = 0, cnt_r = 0;\n        int i = p - 1;\n        // left\n        while(i >= l && boxes[i] == boxes[p]) { ++cnt_l; --i; }\n        // right\n        int j = p + 1;\n        while(j < r && boxes[j] == boxes[p]) { ++cnt_r; ++j; }\n        return Box{ 1 + cnt_r + cnt_l, ++i, --j };\n    }\n\n    vbox getBoxes(const vi& boxes, int pos, int r)\n    {\n        vbox xs;\n        int target = boxes[pos];\n        loop(i, pos + 1, r) \n          if(boxes[i] == target)\n          {\n             Box b = getBox(boxes, i, r);\n             i = b.right + 1;\n             xs.push_back(b);\n          }\n        return xs;\n    }\n\n    int getMax(const vi& boxes, int l, int r, table& memo)\n    {\n        if(l >= r) return 0;\n\n        int &streak = memo[l][r];\n        if(~streak) return memo[l][r];\n\n        streak = 0;\n        loop(i, l, r)\n        {\n            Box box = getBox(boxes, i, r);\n            int local = 0;\n            int acc_in = 0;\n            int acc_cnt = box.count;\n            Box prev = box;\n            vbox bs = getBoxes(boxes, box.right, r);\n            for(auto b : bs)\n            {\n                int in = getMax(boxes, box.right + 1, b.left, memo);\n                int left = getMax(boxes, b.right + 1, r, memo);\n                int cnt = box.count + b.count;\n                acc_cnt += b.count;\n                acc_in += getMax(boxes, prev.right + 1, b.left, memo);\n                prev = b;\n                local = std::max(local, std::max(cnt * cnt + in + left, acc_cnt * acc_cnt + acc_in + left));\n            }\n            streak = std::max(streak, std::max(local, box.count * box.count + getMax(boxes, box.right + 1, r, memo)));\n            i = box.right + 1;\n        }\n        return memo[l][r] = streak;\n    }\n    int removeBoxes(const vi& boxes) \n    { BOX_SIZE = boxes.size(); table memo = vvi(BOX_SIZE + 1, vi(BOX_SIZE + 1, -1)); return getMax(boxes, 0, BOX_SIZE, memo); }\n}"
        }
    ]
}