{
    "sourceFile": ".history/language/main_20240605081003.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1717590242532,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1717590242532,
            "name": "Commit-0",
            "content": "#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <vector>\n#include <optional>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <set>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\n\n// function selectionSort(arr):\n//     n = length of arr  // Length of the array\n    \n//     for i from 0 to n - 2:  // Outer loop from the first element to the second-to-last\n//         minIndex = i  // Assume the first element of the unsorted section is the minimum\n        \n//         // Find the smallest element in the unsorted section\n//         for j from i + 1 to n - 1:\n//             if arr[j] < arr[minIndex]:  // Find a smaller element\n//                 minIndex = j  // Update the index of the smallest element\n                \n//         // Swap the smallest element with the first element of the unsorted section\n//         if minIndex != i:  // Only swap if the smallest element is not already in place\n//             swap(arr[i], arr[minIndex])\n\nvoid selection(std::vector<int>& array) {\n    size_t length = array.size();\n    for (size_t i = 0; i < length - 1; i++)\n    {\n        size_t minIndex = i;\n        for (size_t j = i + 1; j < length; j++)\n        {\n            if (array[j] < array[minIndex])\n            {\n                minIndex = j;\n            }\n            \n        }\n        if(minIndex != i)\n        {\n            std::swap(array[i], array[minIndex]);\n        }\n    }\n}\n\nvoid merge_sort(std::vector<int>& array, size_t l, size_t r) \n{\n\n    auto merge = [](std::vector<int>& array, size_t l, size_t m, size_t r) \n    {\n        size_t left_length = m - l + 1;\n        size_t right_length = r - m;\n        int left_tmp[left_length];\n        int right_tmp[right_length];\n\n        for (size_t i = 0; i < left_length; i++)\n        {\n            left_tmp[i] = array[l + i];\n        }\n        \n        for (size_t j = 0; j < right_length; j++)\n        {\n            right_tmp[j] = array[m + 1 + j];\n        }\n\n        size_t i = 0; // left array\n        size_t j = 0; // right array\n        size_t k = l;\n\n        while(i < left_length && j < right_length)\n        {\n            if(left_tmp[i] <= right_tmp[j])\n            {\n                array[k] = left_tmp[i];\n                i++;\n\n            }\n            else {\n                array[k] = right_tmp[j];\n                j++;\n            }\n            k++;\n        }\n\n        while(i < left_length) \n        {\n            array[k] = left_tmp[i];\n            i++;\n            k++;   \n        }\n\n        while(j < right_length) \n        {\n            array[k] = right_tmp[j];\n            j++;\n            k++;   \n        }\n    };\n\n    if(l >= r) \n    {\n        return;\n    } else \n    {\n        size_t q = (int)floor((l + r) / 2); // divide step\n        merge_sort(array, l, q); // sub-problem of size n/2\n        merge_sort(array, q + 1, r); // sub-problem of size n/2\n        merge(array, l, q, r); // combine step\n    }\n}\n\n\nvoid recursive_insertion_sort(std::vector<int>& array, size_t n) \n{\n    if(n == 0)\n    {\n        return;\n    }\n    else\n    {\n        recursive_insertion_sort(array, n - 1); // recursive call\n        size_t k = n - 1;\n        while(k > 0)\n        {\n            if(array[k - 1] > array[k])\n            {\n                std::swap(array[k - 1], array[k]);\n                k--;\n            }\n            else \n            {\n                break;\n            }\n        }\n    }\n}\n\n\nbool palindrome_number(int n)\n{\n    auto reverseNumber = [](int n) \n    {\n        int reversed = 0;\n        while (n > 0) \n        {\n          int digit = n % 10;  // Extract the last digit\n          reversed = reversed * 10 + digit;  // Add the digit to the reversed number\n          n /= 10;  // Remove the last digit\n        }\n        return reversed;\n    };\n    if (n < 0) {\n        return false;  // Negative numbers are not palindromes due to the negative sign\n    }\n\n    int reversed = reverseNumber(n);\n    return reversed == n;\n}\n\nint binary_search(std::vector<int> array, size_t l, size_t r, int v)\n{\n    if(l >= r)\n      return -1;\n    else \n    {\n        size_t m = floor((l + r) / 2);\n        if(array[m] == v)\n          return m;\n        else if(array[m] > v)\n          return binary_search(array, l, m, v); // T(n/2)\n        else\n          return binary_search(array, m + 1, r, v); // T(n/2)\n    }\n}\n\n// given a set S of n integers and another integer v\n// determines whether S contains two elements that sum to exactly v\n// time complexity should be logarithmic -> n * lgn\nstd::optional<std::tuple<size_t, size_t>> sumOfTwoNumbers(const std::vector<int>& array, int target)\n{\n    std::unordered_map<int, int> map;\n    for (int i = 0; i < array.size(); ++i) {\n        int complement = target - array[i];\n        if (map.find(complement) != map.end()) {\n            return std::make_tuple(map[complement], i);\n        }\n        map[array[i]] = i;\n    }\n    return std::nullopt;\n}\n\nstruct ListNode \n{\n  int val;\n  ListNode *next;\n  ListNode() : val(0), next(nullptr) {}\n  ListNode(int x) : val(x), next(nullptr) {}\n  ListNode(int x, ListNode *next) : val(x), next(next) {}\n  public:\n    void print()\n    {\n        auto ptr = this;\n        do\n        {\n            std::cout << ptr->val << (ptr->next == nullptr ? \" \" : \" -> \");\n            ptr = ptr->next;\n            \n        }while(ptr != nullptr);\n    }\n};\n \nListNode* mergeTwoLists(ListNode* list1, ListNode* list2)\n{\n    if(list1 == nullptr && list2 == nullptr)\n      return nullptr;\n    else \n    {\n      ListNode* fst_ptr = list1;\n      ListNode* snd_ptr = list2;\n      ListNode* list = new ListNode();\n      ListNode* tmp = list;\n      \n      while(fst_ptr != nullptr &&\n            snd_ptr != nullptr)\n      {\n        if(fst_ptr->val <= snd_ptr->val)\n        {\n            tmp->val = fst_ptr->val;\n            tmp->next = new ListNode();\n            tmp = tmp->next;\n            fst_ptr = fst_ptr->next;\n        }\n        else\n        {\n            tmp->val = snd_ptr->val;\n            tmp->next = new ListNode();\n            tmp = tmp->next;\n            snd_ptr = snd_ptr->next;\n        }\n      }\n\n      if(fst_ptr != nullptr)\n      {\n        tmp->val = fst_ptr->val;\n        tmp->next = fst_ptr->next;\n      }\n        \n      if(snd_ptr != nullptr)\n      {\n        tmp->val = snd_ptr->val;\n        tmp->next = snd_ptr->next;\n      }\n\n      return list;\n    }\n}\n\nint removeDuplicates(vector<int>& nums)\n{\n    auto curr = nums.begin();\n    auto ptr = nums.begin();\n    int cnt = 1;\n    while(++curr != nums.end())\n    {\n        if(*curr != *ptr)\n        {\n            *(++ptr) = *curr;\n            ++cnt;\n        }\n    }\n\n    return cnt;\n}\n\n\n// [7,1,5,3,6,4]\n// buy on the first day (7), sell on the second day(1): -6, \n// buy on the first day (7), sell on the third day(5): -2, \n// buy on the first day (7), sell on the fourth day(3): -4,\n// buy on the first day (7), sell on the fifth day(6): -1,\n// buy on the first day (7), sell on the sixth day(4): -3,\n// max profit if buy on the first day and sell on fifth day\n// straightforward solution: pick up an element from an outer loop, traverse beginning from the next element to the left and collect max\nstd::optional<std::tuple<int, int>> maxProfitStraightforward(vector<int>& prices) \n{\n    int max_profit = 0;\n    int buy_day;\n    int sell_day;\n    for (size_t i = 0; i < prices.size(); i++)\n    {\n        for (size_t j = i + 1; j < prices.size(); j++)\n        {\n            if(max_profit < prices[j] - prices[i])\n            {\n                max_profit = max(max_profit, prices[j] - prices[i]);\n                buy_day = i + 1;\n                sell_day = j + 1;\n            }\n        }\n    }\n    return max_profit > 0 ? std::make_optional(std::make_tuple(buy_day, sell_day)) : std::nullopt;\n}\n\n\n// [7,1,5,3,6,4]\n// left: [7, 1, 5]\n// right: [3, 6, 4]\n// middle: [5, 3]\n// base case 0, 1\n// f = max(f(right)) f(left))\nstd::optional<std::tuple<int, int>> maxProfitRecursive(vector<int>& prices)\n{\n    return std::nullopt;\n}\n\nint removeElement(vector<int>& nums, int val)\n{\n    int forward_ptr = 0;\n    int backward_ptr = nums.size() - 1;\n    while(nums.size() > 0 && \n        forward_ptr <= backward_ptr)\n    {\n        if(nums[forward_ptr] == val)\n        {\n            while(backward_ptr >= forward_ptr && \n                nums[backward_ptr] == val)\n                backward_ptr--;\n            if(backward_ptr > forward_ptr)\n            { std::swap(nums[forward_ptr], nums[backward_ptr]); \n              forward_ptr++; \n            }\n        }\n        else \n        { forward_ptr++; }\n    }\n    return forward_ptr == 0 ? forward_ptr : forward_ptr;\n}\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \n{\n}\n\n struct TreeNode \n {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n };\n  \nstd::vector<int> treePath(TreeNode* root)\n{\n   \n  auto findPathSums = [](auto&& findPathSums, TreeNode* node, int currentSum, std::vector<int>& pathSums) \n  {\n    if (node == nullptr)\n        return; // If the node is null, return\n    currentSum += node->val; // Add the current node's value to the path sum\n    // If this is a leaf node (no children), store the path sum\n    if (node->left == nullptr && \n        node->right == nullptr) \n    {\n        pathSums.push_back(currentSum);\n    } else \n    {\n        // Recursively find path sums for left and right children\n        findPathSums(findPathSums, node->left, currentSum, pathSums);\n        findPathSums(findPathSums, node->right, currentSum, pathSums);\n    }\n  };\n\n  std::vector<int> paths = {};\n  findPathSums(findPathSums, root, 0, paths);\n  return paths;\n}\n\nint minDepth(TreeNode* root)\n{\n    auto findPaths = [](auto&& findPathSums, TreeNode* node, int currentSum, std::vector<int>& paths) \n  {\n    if (node == nullptr)\n        return; // If the node is null, return\n    currentSum += 1; // Add the current node's value to the path sum\n    // If this is a leaf node (no children), store the path sum\n    if (node->left == nullptr &&\n        node->right == nullptr) \n    {\n        paths.push_back(currentSum);\n    } else \n    {\n        // Recursively find path sums for left and right children\n        findPathSums(findPathSums, node->left, currentSum, paths);\n        findPathSums(findPathSums, node->right, currentSum, paths);\n    }\n  };\n\n  std::vector<int> paths = {};\n  findPaths(findPaths, root, 0, paths);\n  std::min_element(paths.begin(), paths.end());\n  return 1;\n}\n\nvector<int> inorderTraversal(TreeNode* root)\n{\n    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n    {\n        if (node == nullptr)\n          return;\n        else if(node->left == nullptr && \n                node->right == nullptr)\n          xs.push_back(node->val);\n        else\n        {\n           traverse(traverse, node->left, xs);\n           xs.push_back(node->val);\n           traverse(traverse, node->right, xs);\n        }  \n    };\n    std::vector<int> xs = {};\n    traverse(traverse, root, xs);\n    return xs;\n}\n\nvector<int> postorderTraversal(TreeNode* root)\n{\n    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n    {\n        if (node == nullptr)\n          return;\n        else if(node->left == nullptr && \n                node->right == nullptr)\n          xs.push_back(node->val);\n        else\n        {\n           traverse(traverse, node->left, xs);\n           traverse(traverse, node->right, xs);\n           xs.push_back(node->val);\n        }  \n    };\n    std::vector<int> xs = {};\n    traverse(traverse, root, xs);\n    return xs;\n}\n\nvector<int> preorderTraversal(TreeNode* root)\n{\n    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n    {\n        if (node == nullptr)\n          return;\n        else if(node->left == nullptr && \n                node->right == nullptr)\n          xs.push_back(node->val);\n        else\n        {\n           xs.push_back(node->val);\n           traverse(traverse, node->left, xs);\n           traverse(traverse, node->right, xs);\n        }  \n    };\n    std::vector<int> xs = {};\n    traverse(traverse, root, xs);\n    return xs;\n}\n\nbool treesEquality(TreeNode* first, TreeNode* second)\n{\n    if(first == nullptr && \n       second == nullptr)\n       return true;\n    else \n    {\n        return first->val == second->val && \n               treesEquality(first->left, second->left) && \n               treesEquality(first->right, second->right);\n    }\n}\n\nbool isSubtree(TreeNode* root, TreeNode* sub)\n{\n    if(root == nullptr)\n      return false;\n    else if(treesEquality(root, sub))\n      return true;\n    else\n      return isSubtree(root->left, sub) || \n             isSubtree(root->right, sub);\n}\n\nint diameterOfBinaryTree(TreeNode* root, int& diameter)\n{\n    if(root == nullptr)\n      return 0;\n    else \n    {\n        auto left = diameterOfBinaryTree(root->left, diameter);\n        auto right  = diameterOfBinaryTree(root->right, diameter);\n        diameter = max(diameter, left + right);\n        return 1 + max(left, right);\n    } \n}\n\nTreeNode* invertTree(TreeNode* root) \n{\n    if(root == nullptr)\n      return nullptr;\n    else\n    {\n        auto tmp = root->left;\n        root->left = root->right;\n        root->right = tmp;\n        invertTree(root->left);\n        invertTree(root->right);\n        return root;\n    }\n}\n\nint treeDepth(TreeNode* root)\n{\n    if(root == nullptr)\n      return 0;\n    else\n    {\n        auto left = 1 + treeDepth(root->left);\n        auto right = 1 + treeDepth(root->right);\n        return max(left, right);\n    }\n}\n\nvoid deepestLeavesSum(TreeNode* root, int depth, int& sum, int level)\n{\n    if(root == nullptr)\n      return;\n\n    if(level == depth)\n      sum += root->val;\n\n    deepestLeavesSum(root->left, depth, sum, level + 1);\n    deepestLeavesSum(root->right, depth, sum, level + 1);\n}\n\n// https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/\nstd::tuple<int, int> averageOfSubtree(TreeNode* root, int& x)\n{\n    if(root == nullptr)\n      return std::make_tuple(0, 0);\n\n    auto left = averageOfSubtree(root->left, x);\n    auto right = averageOfSubtree(root->right, x);\n    auto val = root->val + std::get<0>(left) + std::get<0>(right);\n    auto cnt = 1 + std::get<1>(left) + std::get<1>(right);\n    if (floor(val / cnt) == root->val)\n      x += 1;\n    return std::make_tuple(val, cnt);\n}\n\n// https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/description/\nvoid bstToGstHelper(TreeNode* root, int& curr)\n{\n    if(root == nullptr)\n      return;\n    bstToGstHelper(root->right, curr);\n    auto tmp = root->val;\n    root->val += curr;\n    curr += tmp;\n    bstToGstHelper(root->left, curr);  \n}\n\nTreeNode* bstToGst(TreeNode* root) \n{\n    int node_val = 0;\n    bstToGstHelper(root, node_val);\n    return root;\n}\n\n// https://leetcode.com/problems/delete-leaves-with-a-given-value/\n\n// tree: 1 -> 2. target: 2\n// what is on node 2:\n//  nullptr = removeLeafNodesHelper(nullptr, 2) --> left \n//  nullptr = removeLeafNodesHelper(nullptr, 2) --> right\n//  thus the call on node 2 returns nullptr\n//  we are certain that this call produces nullptr -> removeLeafNodesHelper(2, 2)\n\nTreeNode* removeLeafNodesHelper(TreeNode* root, int target)\n{\n    if(root == nullptr)\n      return nullptr;  \n    auto left_node = removeLeafNodesHelper(root->left, target);\n    auto right_node = removeLeafNodesHelper(root->right, target);\n    if(left_node == nullptr &&\n       right_node == nullptr &&\n       root->val == target)\n      return nullptr;\n    else \n    {\n        root->left = left_node;\n        root->right = right_node;\n        return root;\n    }\n}\n\n// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \n{\n    if(root == nullptr)\n      return nullptr;\n    if(root->val == p->val || \n       root->val == q->val)\n      return root;\n    auto right = lowestCommonAncestor(root->right, p, q);\n    auto left = lowestCommonAncestor(root->left, p, q);\n    if(right != nullptr && \n        left != nullptr)\n      return root;\n    else if(right != nullptr && \n            left == nullptr)\n      return right;\n    else if(right == nullptr &&\n             left != nullptr) \n      return left;\n    else return nullptr;\n}\n\n// https://leetcode.com/problems/move-zeroes/description\nvoid moveZeroes(vector<int>& nums) \n{\n    int ptr_to_zero = 0;\n    while(ptr_to_zero < nums.size() && \n          nums[ptr_to_zero] != 0)\n      ptr_to_zero++;    \n\n    int ptr_to_non_zero = ptr_to_zero;\n    while(ptr_to_non_zero < nums.size() && \n          nums[ptr_to_non_zero] == 0)\n      ptr_to_non_zero++;    \n\n    while(ptr_to_non_zero < nums.size())\n    {\n        std::swap(nums[ptr_to_zero], nums[ptr_to_non_zero]);\n        while(nums[ptr_to_zero] != 0) \n          ptr_to_zero++;\n        while(nums[ptr_to_non_zero] == 0) \n          ptr_to_non_zero++;\n    }\n}\n\n// https://leetcode.com/problems/majority-element/description\nint majorityElement(vector<int>& nums) \n{\n    return 0;        \n}\n\n\n// backtracking algorithm\n// https://leetcode.com/problems/binary-tree-paths\nvector<string> binaryTreePathsHelper(TreeNode* root)\n{\n    if(root == nullptr)\n     return {};\n    auto left_s = binaryTreePathsHelper(root->left);\n    auto right_s = binaryTreePathsHelper(root->right);\n    if(root->left == nullptr && root->right == nullptr)\n      return {std::to_string(root->val)};\n    \n    std::for_each(left_s.begin(), left_s.end(), [&root](string& s) { s = std::to_string(root->val) + \"->\" + s; } );\n    std::for_each(right_s.begin(), right_s.end(), [&root](string& s) { s = std::to_string(root->val) + \"->\" + s; } );\n    std::vector<string> merged(left_s.size() + right_s.size());\n    std::merge(left_s.begin(), left_s.end(), right_s.begin(), right_s.end(), merged.begin());\n    return merged;\n}\n\n// https://leetcode.com/problems/permutations/description/\n// performance is confoundedly low!!\nstd::vector<std::vector<int>> permuteHelper(std::vector<int> xs)\n{\n    if(xs.size() == 0)\n       return {{}};\n    std::vector<std::vector<int>> acc_x = {};\n    for (size_t i = 0; i < xs.size(); i++)\n    {\n      auto tmp = xs;\n      tmp.erase(tmp.begin() + i);\n      auto yys = permuteHelper(tmp);\n      std::for_each(\n        yys.begin(), \n        yys.end(),\n        [xs, i, &acc_x](std::vector<int>& ys)\n        { ys.insert(ys.begin(), xs[i]);\n          acc_x.push_back(ys);\n        } );\n    }\n    return acc_x;\n}\n\n\n// https://leetcode.com/problems/combination-sum\n/*\nStep-by-Step Approach\nSort the Array (Optional):\n\n1 (optional) Sorting the array can help in pruning branches early if you decide to skip further exploration when the current sum exceeds the target.\n\n2 Define the Backtracking Function:\n  Create a recursive function that takes the current combination, \n  the remaining target, the start index, and the original array as arguments.\n\n  - Base Cases:\n      If the remaining target is zero, add the current combination to the list of results.\n      If the remaining target is less than zero or if the start index is out of bounds, return without adding the combination.\n\n  - Recursive Exploration:\n      Iterate over the array starting from the current index.\n      Include the current element in the combination and recursively call the function with the updated combination and target.\n      Exclude the current element and move to the next index.\n\n3 Backtracking: After exploring with the current element, remove it from the combination to explore other possibilities.\n*/\nvoid combinationSumHelper(size_t idx, vector<int> xs, int& target, vector<int>& ys, vector<vector<int>>& acc)\n{\n    auto n = xs.size();\n    if(target == 0)\n      acc.push_back(ys);\n    else if(target < 0)\n      return;\n    else if (idx == n)\n      return;\n    else\n    { \n        // Include the current element in the combination and \n        // recursively call the function with the updated combination and target.\n        ys.push_back(xs[idx]);\n        target -= xs[idx];\n        combinationSumHelper(idx, xs, target, ys, acc);\n        // Exclude the current element and move to the next index.\n        ys.pop_back();\n        target += xs[idx];\n        combinationSumHelper(idx + 1, xs, target, ys, acc);\n    }\n}\n\nvector<vector<int>> combinationSum(vector<int>& candidates, int target)\n{\n    std::sort(candidates.begin(), candidates.end());\n    vector<vector<int>> combinationXs = {};\n    for (size_t i = 0; i < candidates.size(); i++)\n    {\n      vector<int> ys = {candidates[i]};\n      int val = target - candidates[i];\n      combinationSumHelper(i, candidates, val, ys, combinationXs);\n    }\n    return combinationXs;\n}\n\n// https://leetcode.com/problems/3sum\n/*\nTo solve the problem of finding all unique triplets in an array that sum to zero, we can use a combination of sorting and the two-pointer technique. \nThe basic idea is to first sort the array, and then use three nested loops \nwhere the innermost loop is optimized using two pointers to avoid unnecessary comparisons. \nThis approach ensures that we can find the solution in 𝑂(𝑛2) time complexity.\n\nthere are steps:\n\n1 Sort the array: Sorting helps to easily avoid duplicates and also allows us to use the two-pointer technique efficiently.\n\n2 Iterate through the array: For each element in the array, treat it as a fixed element and try to find a pair of elements \nin the remaining part of the array which sums up to the negative of the fixed element.\n\n3 Two-pointer technique: For the remaining elements after the fixed element, use two pointers to find pairs that sum up to the required value. \nAdjust the pointers based on whether the current sum is less than or greater than the required sum.\nAvoid duplicates: After finding a valid triplet, move the pointers to skip over any duplicate elements to ensure that each triplet is unique.\n*/\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums)\n{\n    auto n = nums.size();\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> res = {};\n    for (size_t i = 0; nums[i] <= 0; i++)\n    {\n        if(i > 0 && nums[i] == nums[i - 1])\n          continue;\n        size_t left = i + 1;\n        size_t right = n - 1;\n        int target = -nums[i];\n\n        while (left < right) {\n            int sum = nums[left] + nums[right];\n            if (sum == target) {\n                res.push_back({nums[i], nums[left], nums[right]});\n                // Move left and right pointers and skip duplicates\n                while (left < right && \n                       nums[left] == nums[left + 1]) \n                  ++left;\n                while (left < right && \n                       nums[right] == nums[right - 1]) \n                  --right;\n                ++left;\n                --right;\n            } else if (sum < target) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return res;\n}\n\n// https://leetcode.com/problems/product-of-array-except-self\n// array: [1, 2, 3, 4, 5]\n// prefix product array: P = [1, 2, 6, 24, 120]\n// P[0] = A[0] = 1\n// P[1] = P[0] * A[1] = 1 * 2 = 2\n// P[2] = P[1] * A[2] = 2 * 3 = 6\n// P[3] = P[2] * A[3] = 6 * 4 = 24\n// P[4] = P[3] * A[4] = 24 * 5 = 120\n// suffix product array: S = [120, 120, 60, 20, 5]\n// S[4] = A[4] = 5\n// S[3] = S[4] * A[3] = 5 * 4 = 20\n// S[2] = S[3] * A[2] = 20 * 3 = 60\n// S[1] = S[2] * A[1] = 60 * 2 = 120\n// S[0] = S[1] * A[0] = 120 * 1 = 120\n// r(i) = P(i - 1) * S(i + 1)\n// if i > size -> S(sie) == 1\n// if i == 0 -> P(0) = 1\n// r(0) = 1 * S(1) -> 120\n// r(4) = P(3) * 1 -> 24\n// r(1) = P(0) * S(2) -> 1 * 60 -> 60\n// r(2) = P(1) * S(3) -> 2 * 20 -> 40\nvector<int> computeSuffixProduct(const vector<int>& xs) {\n    int n = xs.size();\n    vector<int> s(n);\n    s[n - 1] = xs[n - 1];\n    for (int i = n - 2; i >= 0; --i) {\n        s[i] = s[i + 1] * xs[i];\n    }\n    return s;\n}\n\nvector<int> computePrefixProduct(const vector<int>& xs) {\n    int n = xs.size();\n    vector<int> p(n);\n    p[0] = xs[0];\n    for (int i = 1; i < n; ++i) {\n        p[i] = p[i - 1] * xs[i];\n    }\n    return p;\n}\n\nvector<int> productExceptSelf(vector<int>& nums)\n{\n    vector<int> prefixXs = computePrefixProduct(nums); // O(n) <- extra space for prefix products\n    vector<int> suffixXs = computeSuffixProduct(nums); // O(n) <- extra space for suffix products\n    vector<int> res = {};\n    for (size_t i = 0; i < nums.size(); i++)\n    {\n        auto prefix = i == 0 ? 1 : prefixXs[i - 1];\n        auto suffix = i + 1 == nums.size() ? 1 : suffixXs[i + 1];\n        auto tmp = prefix * suffix;\n        res.push_back(tmp);\n    }\n    return res;\n}\n\n\n// https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage\nint garbageCollection(vector<string>& garbage, vector<int>& travel) \n{\n    return 0;\n}\n\n// https://leetcode.com/problems/find-the-score-of-all-prefixes-of-an-array\nvector<long long> findPrefixScore(vector<int>& nums) \n{\n    return {};\n}\n\nint maxSubArray(vector<int>& nums, int i, int& best)\n{\n    if(i == 0)\n      return nums[0];\n    auto el = nums[i];\n    auto curr_sum = maxSubArray(nums, i - 1, best);\n    auto sum = std::max(el, curr_sum + el);\n    best = std::max(best, sum);\n    return sum;\n}\n\n\n// matrix multiplication, straightforward solution O(n^3)\nusing matrix = std::vector<std::vector<int>>;\nvoid matrixMultiply(matrix a, matrix b, matrix& c, size_t row)\n{\n    for (size_t i = 0; i < row; i++)\n    {\n        for (size_t j = 0; j < row; j++)\n        {\n            for (size_t k = 0; k < row; k++)\n            {\n                c[i][j] += a[i][k] * b[k][j];\n            }\n        }\n        \n    }   \n}\n\nvoid matrixMultiplyRecursive(matrix a, matrix b, matrix& c, size_t row)\n{\n}\n\n// https://leetcode.com/problems/subsets/description\nstd::vector<std::vector<int>> generateAllSubset(std::vector<int> xs)\n{\n    if(xs.size() == 0)\n      return {{}};\n    auto xs_copy = xs;\n    xs_copy.erase(xs_copy.begin());  \n    auto xxs = generateAllSubset(xs_copy);\n    auto xxs_copy = xxs;\n    std::for_each(\n      xxs.begin(), \n      xxs.end(), \n      [xs](std::vector<int>& ys) \n      { ys.insert(ys.begin(), xs[0]); } \n    );\n    xxs_copy.insert(xxs_copy.end(), xxs.begin(), xxs.end());\n    return xxs_copy;\n}\n\n\n// https://leetcode.com/problems/longest-continuous-increasing-subsequence\nint findLengthOfLCIS(vector<int>& nums) \n{\n    int i = 0;\n    int j = 0;\n    int max_seq = 0;\n\n    while(++j < nums.size())\n    {\n        if(nums[j - 1] < nums[j])\n          continue;\n        else\n        {\n            max_seq = std::max(max_seq, j - i);\n            i = j;\n        }\n    }\n    return std::max(j - i, max_seq);\n}\n\n\n// https://leetcode.com/problems/merge-intervals\nvector<vector<int>> mergeIntervals(vector<vector<int>>& intervals) \n{\n    std::sort(intervals.begin(), intervals.end());\n    auto interim_interval = intervals[0];\n    vector<vector<int>> res = {};\n    for (size_t i = 1; i < intervals.size(); i++)\n    {\n        if (intervals[i][0] <= interim_interval[1]) {\n            // Overlapping intervals, merge them\n            interim_interval[1] = std::max(interim_interval[1], intervals[i][1]);\n        }\n        else\n        {\n            // Non-overlapping interval, add to merged list  \n            res.push_back(interim_interval);\n            interim_interval = intervals[i];\n        }\n    }\n    res.push_back(interim_interval);\n    return res;\n}\n\n// https://leetcode.com/problems/insert-interval\nvector<vector<int>> insertInterval(vector<vector<int>>& xs, vector<int>& x) \n{\n    // find the position where new interval start time is between two intervals\n    auto iter = std::lower_bound(xs.begin(), xs.end(), x, [](vector<int> x, vector<int> y) { return x[1] < y[0]; } );\n    auto idx = iter - xs.begin();\n    xs.insert(xs.begin() + idx, x);\n    return mergeIntervals(xs);\n}\n\n// https://leetcode.com/problems/sort-colors\nvoid sortColors(vector<int>& nums) \n{\n    vector<int> tmp = vector<int>(3);\n    for(size_t i = 0; i < nums.size(); i++)\n        tmp[nums[i]]++;\n\n    size_t idx = 0;\n    for (size_t i = 0; i < tmp[0]; i++)\n      nums[idx++] = 0;\n    for (size_t i = 0; i < tmp[1]; i++)\n      nums[idx++] = 1;\n    for (size_t i = 0; i < tmp[2]; i++)\n      nums[idx++] = 2;\n}\n\n// https://leetcode.com/problems/interval-list-intersections\nvector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) \n{\n    return {};\n}\n\n// https://leetcode.com/problems/container-with-most-water\n//\nint maxAreaHelper(vector<int>& xs, int left, int right, int volume)\n{\n    if(left >= right)\n      return volume;\n\n    if(xs[left] < xs[right])\n    {\n       int left_tmp = left;\n       while(++left_tmp < right && \n          xs[left] > xs[left_tmp]);\n      int volume_left = (right - left_tmp) * std::min(xs[right], xs[left_tmp]);\n      return maxAreaHelper(xs, left_tmp, right, std::max(volume, volume_left));\n    }\n    else if(xs[left] > xs[right])\n    {\n        int right_tmp = right;\n        while(--right_tmp >= left &&\n          xs[right] > xs[right_tmp]);\n        int volume_right = (right_tmp - left) * std::min(xs[right_tmp], xs[left]);\n        return maxAreaHelper(xs, left, right_tmp, std::max(volume, volume_right));\n\n    }\n    else // both left and right are equal\n    {\n        int left_tmp = left;\n        while(++left_tmp < right && \n          xs[left] > xs[left_tmp]);\n\n        int right_tmp = right;\n        while(--right_tmp >= left &&\n          xs[right] > xs[right_tmp]);\n        \n        int l_r_volume = (right_tmp - left_tmp) * std::min(xs[right_tmp], xs[left_tmp]);\n        return maxAreaHelper(xs, left_tmp, right_tmp, std::max(volume, l_r_volume));\n    }\n}\n\nint maxArea(vector<int>& height)\n{\n     int init_volume = (height.size() - 1) * std::min(height[0], height[height.size() - 1]);\n     return maxAreaHelper(height, 0, height.size() - 1, init_volume);\n}\n\n// https://leetcode.com/problems/gas-station\n/*\nTo solve this problem, you can use a greedy approach with the following steps:\n\nCheck if the total gas available is greater than or equal to the total cost. If not, return -1.\nUse a greedy method to find the starting station:\n  - Traverse the gas stations and keep track of the current surplus of gas.\n  - If the surplus drops below zero, reset the surplus and set the next station as the new starting point.\n*/\nint canCompleteCircuit(vector<int>& gas, vector<int>& cost) \n{\n     int diff = 0;\n     int tank = 0;\n     int petrol_station = 0;\n\n     for (size_t i = 0; i < gas.size(); i++)\n     {\n         tank += gas[i];\n         if(tank - cost[i] < 0)\n         {\n             diff += tank - cost[i];\n             tank = 0;\n             petrol_station = i + 1; \n         }\n         else tank -= cost[i];\n     }\n\n     return tank - (-1) * diff >= 0 ? petrol_station : -1;\n}\n\n// https://leetcode.com/problems/climbing-stairs\n// You are climbing a staircase. It takes n steps to reach the top.\n// Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n/*\n1 step =1 way,\n2 steps =2 ways,\n3 steps =3 ways,\n4 steps =5 ways,\n5 steps =8 ways, \n6 steps =13 ways\n7 steps =21 ways\n8 steps =34 ways\n9 steps =55 ways\n10 steps =89 ways\n11 steps =144 ways\n12 steps =233 ways\n13 steps =377 ways\n*/\nint climbStairsSolve(int n, vector<int>& memo)\n{\n    if(n == 1)\n      return 1;\n    if(n == 2)\n      return 2;\n    if(memo[n] != -1)\n      return memo[n];  \n    auto ways = climbStairsSolve(n - 1, memo) + climbStairsSolve(n - 2, memo);\n    memo[n] = ways;\n    return ways;\n}\n\nint climbStairs(int n) \n{\n    auto memo = vector<int>(n + 1, -1);\n    return climbStairsSolve(n, memo); \n}\n\n// https://leetcode.com/problems/unique-paths\n// base case solve(0, 0) = 0\n// recursive case: \n//    solve(y, x) =\n//    solve(y - 1, x) +  <--- when we approach (y, x) from above\n//    solve(y, x - 1)    <-- when we approach (y, x) from left\n// for we have a negative index when 0 is applied we should write base cases for: solve(0, x), solve(y, 0)\n// solve(0, x) = 0\n// solve(y, 0) = 0\nint uniquePathsSolve(int m, int n, vector<vector<int>>& memo)\n{\n     if(m == 1 && n == 1)\n       return 1;\n     if(m == 0 && n != 0)\n       return 0;\n     if(m != 0 && n == 0)\n       return 0;\n     if(memo[m][n] != -1)\n       return memo[m][n];\n     int paths = uniquePathsSolve(m - 1, n, memo) + uniquePathsSolve(m, n - 1, memo);\n     memo[m][n] = paths;\n     return paths;\n}\n\nint uniquePaths(int m, int n) \n{\n    vector<vector<int>> memo = vector<vector<int>>(m + 1, vector<int>(n + 1, -1));\n    return uniquePathsSolve(m, n, memo);\n}\n\n// https://leetcode.com/problems/house-robber\nint robHelper(vector<int>& xs, int i, vector<int>& memo)\n{\n    if(i >= xs.size())\n      return 0;\n    if(memo[i] != -1)\n      return memo[i]; \n    int maxBooty = 0;\n    for (size_t j = i + 2; j < xs.size(); j++) {\n      int local = robHelper(xs, j, memo);\n      memo[j] = local;\n      maxBooty = std::max(maxBooty, local);\n    }\n    return xs[i] + maxBooty;\n}\n\nint solveHouseRobber(vector<int>& nums) \n{\n    vector<int> memo = vector<int>(nums.size() + 1, -1);\n    int maxBooty = 0;\n    for (size_t i = 0; i < nums.size(); i++)\n      maxBooty = std::max(maxBooty, robHelper(nums, i, memo));\n    return maxBooty;\n}\n\n// https://leetcode.com/problems/house-robber-ii\nint solveHouseRobber2(vector<int>& nums) { return 0; }\n\n// https://leetcode.com/problems/unique-paths-ii\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) { return 0; } \n\n// https://leetcode.com/problems/burst-balloons\nint burstBalloons(vector<int>& nums) { return 0; }\n\n// https://leetcode.com/problems/rotate-array\nvoid rotateArray(vector<int>& xs, int k) \n{\n     auto r = k > xs.size() ? k % xs.size() : k;\n\n     std::reverse(xs.begin(), xs.end());\n     // left part \n     int left = 0;\n     int right = r - 1;\n     while(left < right)\n     {\n         std::swap(xs[left], xs[right]);\n         left++;\n         right--;\n     }\n     // right part\n     left = r;\n     right = xs.size() - 1;\n     while(left < right)\n     {\n         std::swap(xs[left], xs[right]);\n         left++;\n         right--;\n     }\n}\n\nint longestIncreasingSubsequence(vector<int>& xs)\n{\n    auto length = vector<int>(xs.size(), 1);\n    for (size_t i = 0; i < xs.size(); i++)\n    {\n        for (size_t j = 0; j < i; j++)\n        {\n            if(xs[j] < xs[i])\n              length[i] = std::max(length[i], length[j] + 1);\n        }\n    }\n    return *std::max_element(length.begin(), length.end());\n}\n\n\nstd::optional<int> binarySearchJump(vector<int> xs, int target)\n{\n     return std::make_optional(0);\n}\n\n\n// https://leetcode.com/problems/coin-change\n/*\nThe length of the memoization table is amount + 1 because we need to store results for all possible values from 0 up to the target amount. Here’s a detailed explanation:\n\nRange of Subproblems\nIn the coin change problem, we need to determine the minimum number of coins required for every sub-amount from 0 to the given amount. This includes:\n\nBase Case: The minimum number of coins required to make up 0 amount is 0.\nSub-Amounts: For every amount from 1 to amount, we need to compute the minimum number of coins required.\nMemoization Table\nTo efficiently store and retrieve the results of these subproblems, we use a memoization table. The index of this table represents the sub-amount, and the value at each index represents the minimum number of coins needed to make up that amount.\n\nIndex 0: Corresponds to amount 0.\nIndex 1: Corresponds to amount 1.\n...\nIndex amount: Corresponds to the given target amount.\nBy having a table of size amount + 1, we ensure that we can store results for all amounts from 0 to amount.\n\nExample\nConsider the given amount is 11. The memoization table needs to store results for amounts ranging from 0 to 11. Thus, we need 12 slots in the table:\n\nmemo[0]: Minimum coins to make amount 0 (which is 0).\nmemo[1]: Minimum coins to make amount 1.\n...\nmemo[11]: Minimum coins to make amount 11.\nIf the table were of size amount (which would be 11 in this case), it would only have slots from 0 to 10, and we wouldn't be able to store the result for the target amount itself.\n\nCorrectness\nThe memoization table of size amount + 1 ensures that:\n\nAll Subproblems Are Covered: We can store results for all amounts from 0 up to amount.\nDirect Access: We can directly access and update the result for any sub-amount using its value as the index.\n*/\nint coinChangeSolve(vector<int>& coins, int amount, vector<int>& memo, vector<int>& lastCoin)\n{\n     if(amount < 0)\n       return INT_MAX;\n     if(amount == 0)\n       return 0;\n     if(memo[amount] != -1)\n       return memo[amount];\n\n     int minCoins = INT_MAX;\n     for(auto c : coins) {\n        int tmp = coinChangeSolve(coins, amount - c, memo, lastCoin);\n        if (tmp != INT_MAX && tmp + 1 < minCoins) {\n            minCoins = tmp + 1;\n            lastCoin[amount] = c;  // Track the coin used\n        }\n     }\n\n     memo[amount] = minCoins;\n     return minCoins;\n}\n\nstd::pair<int, vector<int>> coinChange(vector<int>& coins, int amount)\n{ \n   auto memo = vector<int>(amount + 1, -1);\n   auto lastCoin = vector<int>(amount + 1, -1);\n   vector<int> resultCoins = {};\n   auto res = coinChangeSolve(coins, amount, memo, lastCoin);\n\n   // Reconstruct the coins used to form the amount\n    int tempAmount = amount;\n    while (tempAmount > 0) {\n        int coin = lastCoin[tempAmount];\n        resultCoins.push_back(coin);\n        tempAmount -= coin;\n    }\n\n   return std::make_pair(res == INT_MAX ? -1 : res, resultCoins);\n}\n\nconst int MOD = 1e9 + 7; // Example modulus\n\nint coinAllSolutions(vector<int>& coins, int amount, vector<int>& memo)\n{\n    if(amount < 0)\n      return 0;\n    if(amount == 0)\n      return 1;\n    \n    if(memo[amount] != -1)\n      return memo[amount];\n\n    int solutions = 0;\n    for(auto c : coins)\n      solutions += coinAllSolutions(coins, amount - c, memo);\n\n    solutions %= MOD;\n    memo[amount] = solutions;\n    return solutions;\n}\n\n\n// https://leetcode.com/problems/minimum-cost-for-tickets\nint mincostTickets(vector<int>& days, vector<int>& costs) \n{\n    return 0;\n}\n\n// maximum path in a grid\nvoid maxPathInGridSolve(vector<vector<int>> grid, vector<vector<int>>& sum)\n{    \n   for (int y = 1; y < 5; y++)\n     for (int x = 1; x < 5; x++)\n       sum[y][x] = max(sum[y][x-1],sum[y-1][x])+ grid[y][x];\n}\n\nint maxPathInGrid(vector<vector<int>> grid) {\n\n  vector<vector<int>> sum = { {grid[0][0], 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0} };\n      // Initialize the first row\n    for (int j = 1; j < 5; ++j) {\n        sum[0][j] = sum[0][j - 1] + grid[0][j];\n    }\n\n    // Initialize the first column\n    for (int i = 1; i < 5; ++i) {\n        sum[i][0] = sum[i - 1][0] + grid[i][0];\n    }\n  maxPathInGridSolve(grid, sum);\n  return sum[4][4];\n}\n\n// https://leetcode.com/problems/contains-duplicate\nbool containsDuplicate(vector<int>& nums) \n{\n    std::sort(nums.begin(), nums.end());\n    auto curr_ptr = 0;\n    auto next_ptr = 1;\n    auto res = false;\n    while(next_ptr < nums.size())\n    {\n        if(nums[curr_ptr] == nums[next_ptr])\n        {\n           res = true;\n           break;\n        }\n        curr_ptr++;\n        next_ptr++;\n    }\n    return res;\n}\n\n// https://leetcode.com/problems/generate-parentheses\nvector<string> generateParenthesis(int n) \n{\n     return {};        \n}\n\n// https://leetcode.com/problems/linked-list-cycle\n/*\nTo check if a linked list has a cycle, you can use Floyd's Tortoise and Hare algorithm, which is a two-pointer technique. \nThis approach involves using two pointers that traverse the list at different speeds. \nIf there is a cycle, the faster pointer will eventually meet the slower pointer\n*/\nbool hasCycle(ListNode *head) \n{\n     auto one_step_ptr = head;\n     auto two_step_ptr = head->next;\n     auto isCycle = false;\n     while(two_step_ptr != nullptr)\n     {\n        if(one_step_ptr == two_step_ptr)\n        {\n            isCycle = true;\n            break;\n        }\n        one_step_ptr = one_step_ptr->next;\n        two_step_ptr = two_step_ptr->next != nullptr ? two_step_ptr->next->next : nullptr;\n     }\n\n     return isCycle;\n}\n\n// https://leetcode.com/problems/middle-of-the-linked-list\nListNode* middleNode(ListNode* head) \n{\n     auto one_step_ptr = head;\n     auto two_step_ptr = head->next;\n     while(two_step_ptr != nullptr)\n     {\n        one_step_ptr = one_step_ptr->next;\n        two_step_ptr = two_step_ptr->next != nullptr ? two_step_ptr->next->next : nullptr;\n     }\n     return one_step_ptr;\n}\n\n// https://leetcode.com/problems/longest-consecutive-sequence\nint longestConsecutive(vector<int>& nums) { return 0; }\n\n\n// Given a list of weights [w1,w2,...,wn], determine all sums that can be constructed using the weights\n// possible(x,k)=possible(x−wk,k−1) or possible(x,k−1)\nvector<vector<bool>> makePossibility(vector<int> nums, int m)\n{\n      vector<vector<bool>> possibilities = vector<vector<bool>>(m + 1, vector<bool>(nums.size(), false));\n      possibilities[0][0] = true;\n      for (int x = 0; x <= m; m++) {\n        for (int k = 1; k <= nums.size(); k++) { \n          if (x-nums[k] >= 0)\n          {\n              possibilities[x][k] = possibilities[x][k] | possibilities[x-nums[k]][k-1];\n          }\n          possibilities[x][k] = possibilities[x][k] | possibilities[x][k-1];\n        }\n      }\n      return possibilities;\n}\n\ntemplate<class T>\nvoid printVector(vector<T> xs) \n{ \n    for (auto x : xs) { std::cout << x << \" \"; }\n    std::cout << std::endl;\n}\n\nint main()\n{\n    std::vector<int> array_1 = {78, 34, 67, 1111, 7, 6, -9, 11};\n\n    // selection(array_1);\n    recursive_insertion_sort(array_1, array_1.size());\n\n    for (int i = 0; i < array_1.size(); i++) {  // Iterate through the array\n        std::cout << array_1[i] << \" \";  // Print each element\n    }\n    std::cout << std::endl;  // End the line\n\n    std::vector<int> array_2 = {1, 2, 4, 5, 7, 9};\n    std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n\n    std::vector<int> twoSum_array = {3, 3};\n    auto opt = sumOfTwoNumbers(twoSum_array, 67);\n    std::cout << (opt.has_value() ? std::to_string(std::get<1>(opt.value())) : \"null\");\n\n    std::cout << std::endl;\n\n    auto list = mergeTwoLists(new ListNode(1, new ListNode(2, new ListNode(4))), new ListNode(1, new ListNode(3, new ListNode(4))));\n    list->print();\n\n    std::cout << std::endl;\n\n    std::vector<int> duplicate_array = {0,0,1,1,1,2,2,3,3,4};    \n    std::cout << removeDuplicates(duplicate_array);\n\n    std::cout << std::endl; \n    \n    std::vector<int> prices = {7,1,5,3,6,4};\n    // std::vector<int> prices_no_profit = {7,6,4,3,1};\n\n    auto profits_days = maxProfitStraightforward(prices);\n    std::cout << (profits_days.has_value() ? \"buy: \" + std::to_string(std::get<0>(profits_days.value())) + \", sell: \" + std::to_string(std::get<1>(profits_days.value())) : \"no profit\");\n\n    std::cout << std::endl;\n\n    std::vector<int> removeElement_array = {4, 5};\n    std::cout << removeElement(removeElement_array, 4);\n\n\n    std::cout << std::endl;\n\n    std::vector<int> nums1 = {1,2,4,5,6,0};\n    std::vector<int> nums2 = {3};\n    merge(nums1, 5, nums2, 1);\n\n    for (int i = 0; i < nums1.size(); i++) {  // Iterate through the array\n        std::cout << nums1[i] << \" \";  // Print each element\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- removeLeafNodes ---\\n\";\n\n    auto test_tree = new TreeNode(1, new TreeNode(2), nullptr);\n\n    auto tree = removeLeafNodesHelper(test_tree, 2);\n    auto tree_xs = preorderTraversal(tree);\n    for (int i = 0; i < tree_xs.size(); i++) {  // Iterate through the array\n      std::cout << tree_xs[i] << \" \";  // Print each element\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- matrix multiplication ---\\n\";\n\n    matrix a = { {1, 1}, {2, 2} };\n    matrix b = { {1, 1}, {2, 2} };\n    matrix c = {{0, 0}, {0, 0}};\n    matrixMultiply(a, b, c, 2);\n\n    for ( const auto &row : c )\n    {\n      for ( const auto &s : row ) std::cout << s << ' ';\n      std::cout << std::endl;\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- all subsets  ---\\n\";\n\n    std::vector<int> set = {1, 2, 3};\n    auto subsets = generateAllSubset(set);\n\n    for ( const auto &row : subsets )\n    {\n      for ( const auto &s : row ) \n        std::cout << s << ' ';\n      std::cout << std::endl;\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- all permutations  ---\\n\";\n    \n    std::vector<int> permutationXs = {1, 2, 3, 4, 5, 6};\n    // std::vector<std::vector<int>> allPermutations = {};\n    // std::vector<std::vector<int>> acc = {};\n    auto acc = permuteHelper(permutationXs);\n\n    for ( const auto &row : acc )\n    {\n      for ( const auto &s : row ) \n        std::cout << s << ' ';\n      std::cout << std::endl;\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- move zeros  ---\\n\";\n\n   std::vector<int> moveZeroesXs = {0, 0};\n   moveZeroes(moveZeroesXs);\n\n   for (int i = 0; i < moveZeroesXs.size(); i++) {  // Iterate through the array\n        std::cout << moveZeroesXs[i] << \" \";  // Print each element\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"---  longest Continuous Increasing Subsequence  ---\\n\";\n\n    std::vector<int> maxSeqXs = {1,3,5,4,7};\n    std::cout << findLengthOfLCIS(maxSeqXs);\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"---  /////  ---\\n\";\n  \n    std::vector<int> maxSubArrayXs = {-1, 2, 4, -3, 5, 2, -5, 2};\n    int best = 0;\n    maxSubArray(maxSubArrayXs, maxSubArrayXs.size() - 1, best);\n    std::cout << best;\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"---  combinationSum  ---\\n\";\n\n    // [[2,2,2,2,2],[2,2,2,4],[2,8],[2,4,4],[5,5]]\n    std::vector<int> combinationSumXs = {26,21,39,38,24,16,30,7,5,4,9,29,8,35,3,17,19,11,34};\n    auto combinationSumYs = combinationSum(combinationSumXs, 29);\n   \n    for ( const auto &row : combinationSumYs )\n    {\n      for ( const auto &s : row ) std::cout << s << ' ';\n      std::cout << std::endl;\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"---  product of Array Except Self  ---\\n\";\n\n    vector<int> productExceptSelfXs = {-1,1,0,-3,3};\n    auto productExceptSelfRes = productExceptSelf(productExceptSelfXs);\n \n    for (int i = 0; i < productExceptSelfRes.size(); i++) {  // Iterate through the array\n        std::cout << productExceptSelfRes[i] << \" \";  // Print each element\n    }\n\n   \n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"---  three sum  ---\\n\";\n\n    // [[-1,-1,2],[-1,0,1]]\n    // {-4, -1, -1, 0, 1, 2}\n    // vector<int> threeSumXs = {-1, 0, 1, 2, -1, -4};\n    // vector<int> threeSumXs = {0, 1, 1};\n    vector<int> threeSumXs = {0, 0, 0};\n    // vector<int> threeSumXs = {-1, 0, 1, 0};\n    // [-5,1,4]\n    // [-4,0,4]\n    // [-4,1,3]\n    // [-2,-2,4]\n    // [-2,1,1]\n    // [0,0,0]\n    // vector<int> threeSumXs = {-4, -2, 1, -5, -4, -4, 4, -2, 0, 4, 0, -2, 3, 1, -5, 0};\n    auto threeSumRes = threeSum(threeSumXs);\n\n    for ( const auto &row : threeSumRes )\n    {\n      for ( const auto &s : row ) std::cout << s << ' ';\n      std::cout << std::endl;\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- sort colours  ---\\n\";\n\n    vector<int> sortColorsXs = {2, 0, 2, 1, 1, 0, 1, 1};\n    sortColors(sortColorsXs);\n\n    for (int i = 0; i < sortColorsXs.size(); i++) {  // Iterate through the array\n        std::cout << sortColorsXs[i] << \" \";  // Print each element\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- merge intervals  ---\\n\";\n\n    // vector<vector<int>> intervalsXs = { {1, 3}, {2, 6}, {8, 10}, {15, 18} };\n    // vector<vector<int>> intervalsXs = { {1, 4}, {4, 5} };\n    vector<vector<int>> intervalsXs = { {1, 4}, {1, 5} };\n    auto intervalsYs = mergeIntervals(intervalsXs);\n \n    for ( const auto &row : intervalsYs )\n    {\n      for ( const auto &s : row ) std::cout << s << ' ';\n      std::cout << std::endl;\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- insert interval  ---\\n\";\n\n    vector<vector<int>> insertIntervalsXs = { {1, 3}, {6, 9} };\n    // vector<vector<int>> insertIntervalsXs = { {1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16} };\n    vector<int> newInterval = {2, 5};\n    auto insertIntervalsYs = insertInterval(insertIntervalsXs, newInterval);\n\n    for ( const auto &row : insertIntervalsYs )\n    {\n      for ( const auto &s : row ) std::cout << s << ' ';\n      std::cout << std::endl;\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- rotate array  ---\\n\";\n    \n    // vector<int> rotateArrayXs = {1, 2, 3, 4, 5, 6, 7};\n    vector<int> rotateArrayXs = {1, 2};\n    // vector<int> rotateArrayXs = {1, 2, 3};\n    rotateArray(rotateArrayXs, 3);\n\n    for (int i = 0; i < rotateArrayXs.size(); i++) {  // Iterate through the array\n        std::cout << rotateArrayXs[i] << \" \";  // Print each element\n    }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- binary search (jumps approach)  ---\\n\";\n     \n    vector<int> binarySearchJumpXs = {1, 3, 3, 4, 6, 6, 7}; \n    std::cout << binarySearchJump(binarySearchJumpXs, 4).value();\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- Container With Most Water ---\\n\";\n\n    // vector<int> maxAreaXs = {1, 8, 6, 2, 5, 4, 8, 3, 7 };\n    // vector<int> maxAreaXs = {1, 2};\n    // vector<int> maxAreaXs = { 1, 8, 6, 2, 5, 4, 8, 25, 7 };\n    // vector<int> maxAreaXs = {2, 1};\n    // vector<int> maxAreaXs = { 2, 3, 10, 5, 7, 8, 9 }; // expected: 36, got: 15\n    // vector<int> maxAreaXs = { 1, 2, 3, 4, 5, 6 }; // // expected: 9, got: 8\n    // vector<int> maxAreaXs =  { 6, 5, 4, 3, 2, 1 };\n    // vector<int> maxAreaXs = { 1, 2, 1 };\n    vector<int> maxAreaXs = \n       { 76,155,15,188,180,154,84,34,187,142,22,5,27,183,111,128,50,58,2,\n         112,179,2,100,111,115,76,134,120,118,103,31,146,58,198,134,38,104,\n         170,25,92,112,199,49,140,135,160,20,185,171,23,98,150,177,198,61,92,\n         26,147,164,144,51,196,42,109,194,177,100,99,99,125,143,12,76,192,152,\n         11,152,124,197,123,147,95,73,124,45,86,168,24,34,133,120,85,81,163,146,\n         75,92,198,126,191 };\n    std::cout << maxArea(maxAreaXs);\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- Coin Change ---\\n\";\n     \n    vector<int> coinChangeXs = { 1, 2, 5 };\n    std::cout << \" min: \" << std::get<0>(coinChange(coinChangeXs, 11 ));\n    \n    std::cout << std::endl;\n\n    std::cout << \" coins used: \";\n    printVector(std::get<1>(coinChange(coinChangeXs, 11 )));\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- Coin All Solutions ---\\n\";\n\n    vector<int> coinAllSolutionsXs = {1, 3, 4};\n    vector<int> coinAllSolutionsMemo = vector<int>(INT32_MAX, -1);\n    std::cout << coinAllSolutions(coinAllSolutionsXs, 6, coinAllSolutionsMemo);\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- Gas Station ---\\n\";\n    \n    // vector<int> gas = { 1, 2, 3, 4, 5 };\n    // vector<int> cost = { 3, 4, 5, 1, 2 };\n    \n    vector<int> gas = { 2, 3, 4 };\n    vector<int> cost = { 3, 4, 3 };\n\n    std::cout << canCompleteCircuit(gas, cost);\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- Longest subsequence ---\\n\";\n\n    vector<int> longestIncreasingSubsequenceXs = { 6, 2, 5, 1, 7, 4, 8, 3 };\n    std::cout << longestIncreasingSubsequence(longestIncreasingSubsequenceXs);\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- Climb stairs ---\\n\";\n    std::cout << climbStairs(9);\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- Maximum path in a grid ---\\n\";\n\n    vector<vector<int>> grid = \n       { {3, 7, 9, 2, 7},\n         {9, 8, 3, 5, 5},\n         {1, 7, 9, 8, 5},\n         {3, 8, 6, 4, 10},\n         {6, 3, 9, 7, 8}\n       };\n    \n    std::cout << maxPathInGrid(grid);\n\n    // std::cout << std::endl;\n    // std::cout << std::endl;\n    // std::cout << \"--- all possibilities ---\\n\";\n\n    // vector<int> possibilityXs = {1, 3};\n    // auto possibilityYs = makePossibility(possibilityXs, 4);\n\n    // for ( const auto &row : possibilityYs )\n    // {\n    //   for ( const auto &s : row ) std::cout << s << ' ';\n    //   std::cout << std::endl;\n    // }\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- Unique Paths ---\\n\";\n    \n    std::cout << uniquePaths(134, 78);\n\n    std::cout << std::endl;\n    std::cout << std::endl;\n    std::cout << \"--- House Robber ---\\n\";\n    \n    vector<int> robXs = {2,7,9,3,1,7};\n    std::cout << solveHouseRobber(robXs);\n}"
        }
    ]
}