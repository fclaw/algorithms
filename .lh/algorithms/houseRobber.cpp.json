{
    "sourceFile": "algorithms/houseRobber.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1718530222010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1718530231710,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,45 +1,45 @@\n namespace leetcode::dp\n {\n     // https://leetcode.com/problems/house-robber\n-int robHelper(vector<int>& xs, int i, vector<int>& memo)\n-{\n-    if(i >= xs.size())\n-      return 0;\n-    if(memo[i] != -1)\n-      return memo[i]; \n-    int maxBooty = 0;\n-    for (size_t j = i + 2; j < xs.size(); j++) {\n-      int local = robHelper(xs, j, memo);\n-      memo[j] = local;\n-      maxBooty = std::max(maxBooty, local);\n+    int robHelper(vector<int>& xs, int i, vector<int>& memo)\n+    {\n+        if(i >= xs.size())\n+        return 0;\n+        if(memo[i] != -1)\n+        return memo[i]; \n+        int maxBooty = 0;\n+        for (size_t j = i + 2; j < xs.size(); j++) {\n+        int local = robHelper(xs, j, memo);\n+        memo[j] = local;\n+        maxBooty = std::max(maxBooty, local);\n+        }\n+        return xs[i] + maxBooty;\n     }\n-    return xs[i] + maxBooty;\n-}\n \n-int solveHouseRobber(vector<int>& nums) \n-{\n-    vector<int> memo = vector<int>(nums.size() + 1, -1);\n-    int maxBooty = 0;\n-    for (size_t i = 0; i < nums.size(); i++)\n-      maxBooty = std::max(maxBooty, robHelper(nums, i, memo));\n-    return maxBooty;\n-}\n+    int solveHouseRobber(vector<int>& nums) \n+    {\n+        vector<int> memo = vector<int>(nums.size() + 1, -1);\n+        int maxBooty = 0;\n+        for (size_t i = 0; i < nums.size(); i++)\n+        maxBooty = std::max(maxBooty, robHelper(nums, i, memo));\n+        return maxBooty;\n+    }\n \n-// https://leetcode.com/problems/house-robber-ii\n-// Since House[1] and House[n] are adjacent, they cannot be robbed together. \n-// Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], \n-// depending on which choice offers more money.\n-int solveHouseRobber2(vector<int>& nums) \n-{\n-  if(nums.size() == 1)\n-    return nums[0];\n+    // https://leetcode.com/problems/house-robber-ii\n+    // Since House[1] and House[n] are adjacent, they cannot be robbed together. \n+    // Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], \n+    // depending on which choice offers more money.\n+    int solveHouseRobber2(vector<int>& nums) \n+    {\n+    if(nums.size() == 1)\n+        return nums[0];\n \n-  auto last_house = *(nums.end() - 1);\n-  nums.pop_back();\n-  int maxBootyNoLast = solveHouseRobber(nums);\n-  nums.erase(nums.begin());\n-  nums.push_back(last_house);\n-  int maxBootyNoFirst = solveHouseRobber(nums);\n-  return std::max(maxBootyNoLast, maxBootyNoFirst);\n-}\n+    auto last_house = *(nums.end() - 1);\n+    nums.pop_back();\n+    int maxBootyNoLast = solveHouseRobber(nums);\n+    nums.erase(nums.begin());\n+    nums.push_back(last_house);\n+    int maxBootyNoFirst = solveHouseRobber(nums);\n+    return std::max(maxBootyNoLast, maxBootyNoFirst);\n+    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718530254228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,16 +30,16 @@\n     // Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], \n     // depending on which choice offers more money.\n     int solveHouseRobber2(vector<int>& nums) \n     {\n-    if(nums.size() == 1)\n-        return nums[0];\n+        if(nums.size() == 1)\n+            return nums[0];\n \n-    auto last_house = *(nums.end() - 1);\n-    nums.pop_back();\n-    int maxBootyNoLast = solveHouseRobber(nums);\n-    nums.erase(nums.begin());\n-    nums.push_back(last_house);\n-    int maxBootyNoFirst = solveHouseRobber(nums);\n-    return std::max(maxBootyNoLast, maxBootyNoFirst);\n+        auto last_house = *(nums.end() - 1);\n+        nums.pop_back();\n+        int maxBootyNoLast = solveHouseRobber(nums);\n+        nums.erase(nums.begin());\n+        nums.push_back(last_house);\n+        int maxBootyNoFirst = solveHouseRobber(nums);\n+        return std::max(maxBootyNoLast, maxBootyNoFirst);\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718530273560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,7 @@\n+#include <vector>\n+#include <algorithm>\n+\n namespace leetcode::dp\n {\n     // https://leetcode.com/problems/house-robber\n     int robHelper(vector<int>& xs, int i, vector<int>& memo)\n"
                },
                {
                    "date": 1718530281471,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n \n namespace leetcode::dp\n {\n     // https://leetcode.com/problems/house-robber\n-    int robHelper(vector<int>& xs, int i, vector<int>& memo)\n+    int robHelper(std::vector<int>& xs, int i, vector<int>& memo)\n     {\n         if(i >= xs.size())\n         return 0;\n         if(memo[i] != -1)\n"
                },
                {
                    "date": 1718530287348,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n         }\n         return xs[i] + maxBooty;\n     }\n \n-    int solveHouseRobber(vector<int>& nums) \n+    int solveHouseRobber(std::vvector<int>& nums) \n     {\n         vector<int> memo = vector<int>(nums.size() + 1, -1);\n         int maxBooty = 0;\n         for (size_t i = 0; i < nums.size(); i++)\n"
                },
                {
                    "date": 1718530293055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     // https://leetcode.com/problems/house-robber-ii\n     // Since House[1] and House[n] are adjacent, they cannot be robbed together. \n     // Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], \n     // depending on which choice offers more money.\n-    int solveHouseRobber2(vector<int>& nums) \n+    int solveHouseRobber2(std::vector<int>& nums) \n     {\n         if(nums.size() == 1)\n             return nums[0];\n \n"
                },
                {
                    "date": 1718530300296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,11 +18,11 @@\n         }\n         return xs[i] + maxBooty;\n     }\n \n-    int solveHouseRobber(std::vvector<int>& nums) \n+    int solveHouseRobber(std::vector<int>& nums) \n     {\n-        vector<int> memo = vector<int>(nums.size() + 1, -1);\n+        vector<int> memo = std::vector<int>(nums.size() + 1, -1);\n         int maxBooty = 0;\n         for (size_t i = 0; i < nums.size(); i++)\n         maxBooty = std::max(maxBooty, robHelper(nums, i, memo));\n         return maxBooty;\n"
                },
                {
                    "date": 1718530305344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,48 @@\n+#include <vector>\n+#include <algorithm>\n+\n+namespace leetcode::dp\n+{\n+    // https://leetcode.com/problems/house-robber\n+    int robHelper(std::vector<int>& xs, int i, vector<int>& memo)\n+    {\n+        if(i >= xs.size())\n+        return 0;\n+        if(memo[i] != -1)\n+        return memo[i]; \n+        int maxBooty = 0;\n+        for (size_t j = i + 2; j < xs.size(); j++) {\n+        int local = robHelper(xs, j, memo);\n+        memo[j] = local;\n+        maxBooty = std::max(maxBooty, local);\n+        }\n+        return xs[i] + maxBooty;\n+    }\n+\n+    int solveHouseRobber(std::vector<int>& nums) \n+    {\n+        std::vector<int> memo = std::vector<int>(nums.size() + 1, -1);\n+        int maxBooty = 0;\n+        for (size_t i = 0; i < nums.size(); i++)\n+        maxBooty = std::max(maxBooty, robHelper(nums, i, memo));\n+        return maxBooty;\n+    }\n+\n+    // https://leetcode.com/problems/house-robber-ii\n+    // Since House[1] and House[n] are adjacent, they cannot be robbed together. \n+    // Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], \n+    // depending on which choice offers more money.\n+    int solveHouseRobber2(std::vector<int>& nums) \n+    {\n+        if(nums.size() == 1)\n+            return nums[0];\n+\n+        auto last_house = *(nums.end() - 1);\n+        nums.pop_back();\n+        int maxBootyNoLast = solveHouseRobber(nums);\n+        nums.erase(nums.begin());\n+        nums.push_back(last_house);\n+        int maxBootyNoFirst = solveHouseRobber(nums);\n+        return std::max(maxBootyNoLast, maxBootyNoFirst);\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718530311798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n \n namespace leetcode::dp\n {\n     // https://leetcode.com/problems/house-robber\n-    int robHelper(std::vector<int>& xs, int i, vector<int>& memo)\n+    int robHelper(std::vector<int>& xs, int i, std::vector<int>& memo)\n     {\n         if(i >= xs.size())\n         return 0;\n         if(memo[i] != -1)\n@@ -44,53 +44,5 @@\n         nums.push_back(last_house);\n         int maxBootyNoFirst = solveHouseRobber(nums);\n         return std::max(maxBootyNoLast, maxBootyNoFirst);\n     }\n-}\n-#include <vector>\n-#include <algorithm>\n-\n-namespace leetcode::dp\n-{\n-    // https://leetcode.com/problems/house-robber\n-    int robHelper(std::vector<int>& xs, int i, vector<int>& memo)\n-    {\n-        if(i >= xs.size())\n-        return 0;\n-        if(memo[i] != -1)\n-        return memo[i]; \n-        int maxBooty = 0;\n-        for (size_t j = i + 2; j < xs.size(); j++) {\n-        int local = robHelper(xs, j, memo);\n-        memo[j] = local;\n-        maxBooty = std::max(maxBooty, local);\n-        }\n-        return xs[i] + maxBooty;\n-    }\n-\n-    int solveHouseRobber(std::vector<int>& nums) \n-    {\n-        vector<int> memo = std::vector<int>(nums.size() + 1, -1);\n-        int maxBooty = 0;\n-        for (size_t i = 0; i < nums.size(); i++)\n-        maxBooty = std::max(maxBooty, robHelper(nums, i, memo));\n-        return maxBooty;\n-    }\n-\n-    // https://leetcode.com/problems/house-robber-ii\n-    // Since House[1] and House[n] are adjacent, they cannot be robbed together. \n-    // Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], \n-    // depending on which choice offers more money.\n-    int solveHouseRobber2(std::vector<int>& nums) \n-    {\n-        if(nums.size() == 1)\n-            return nums[0];\n-\n-        auto last_house = *(nums.end() - 1);\n-        nums.pop_back();\n-        int maxBootyNoLast = solveHouseRobber(nums);\n-        nums.erase(nums.begin());\n-        nums.push_back(last_house);\n-        int maxBootyNoFirst = solveHouseRobber(nums);\n-        return std::max(maxBootyNoLast, maxBootyNoFirst);\n-    }\n }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1718530222010,
            "name": "Commit-0",
            "content": "namespace leetcode::dp\n{\n    // https://leetcode.com/problems/house-robber\nint robHelper(vector<int>& xs, int i, vector<int>& memo)\n{\n    if(i >= xs.size())\n      return 0;\n    if(memo[i] != -1)\n      return memo[i]; \n    int maxBooty = 0;\n    for (size_t j = i + 2; j < xs.size(); j++) {\n      int local = robHelper(xs, j, memo);\n      memo[j] = local;\n      maxBooty = std::max(maxBooty, local);\n    }\n    return xs[i] + maxBooty;\n}\n\nint solveHouseRobber(vector<int>& nums) \n{\n    vector<int> memo = vector<int>(nums.size() + 1, -1);\n    int maxBooty = 0;\n    for (size_t i = 0; i < nums.size(); i++)\n      maxBooty = std::max(maxBooty, robHelper(nums, i, memo));\n    return maxBooty;\n}\n\n// https://leetcode.com/problems/house-robber-ii\n// Since House[1] and House[n] are adjacent, they cannot be robbed together. \n// Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], \n// depending on which choice offers more money.\nint solveHouseRobber2(vector<int>& nums) \n{\n  if(nums.size() == 1)\n    return nums[0];\n\n  auto last_house = *(nums.end() - 1);\n  nums.pop_back();\n  int maxBootyNoLast = solveHouseRobber(nums);\n  nums.erase(nums.begin());\n  nums.push_back(last_house);\n  int maxBootyNoFirst = solveHouseRobber(nums);\n  return std::max(maxBootyNoLast, maxBootyNoFirst);\n}\n}"
        }
    ]
}