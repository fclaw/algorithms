{
    "sourceFile": "algorithms/graph/leetcode/findLadders.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 80,
            "patches": [
                {
                    "date": 1724995756999,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1724995763653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,6 @@\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+    \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724995784771,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,7 @@\n+#include <string>\n+#include <vector>\n \n-\n namespace algorithms::graph::leetcode::find_ladders\n {\n-    \n-}\n \n\\ No newline at end of file\n-\n-namespace algorithms::graph::leetcode::f\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724995799041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,6 +2,6 @@\n #include <vector>\n \n namespace algorithms::graph::leetcode::find_ladders\n {\n-\n+    (std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724995806684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,6 +2,6 @@\n #include <vector>\n \n namespace algorithms::graph::leetcode::find_ladders\n {\n-    (std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724995813322,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,6 +2,6 @@\n #include <vector>\n \n namespace algorithms::graph::leetcode::find_ladders\n {\n-    findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724995822609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,6 +2,9 @@\n #include <vector>\n \n namespace algorithms::graph::leetcode::find_ladders\n {\n+\n+using ladders = \n+\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724995833015,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,13 @@\n+#include <string>\n+#include <vector>\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+using ladders = std::vector<std::string>;\n+\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        return {};\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724995848447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,19 +5,12 @@\n {\n \n using ladders = std::vector<std::string>;\n \n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     */\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         return {};\n     }\n-}\n-#include <string>\n-#include <vector>\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-using ladders = \n-\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1724995875275,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,14 @@\n using ladders = std::vector<std::string>;\n \n     /**\n      * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+\n+Every adjacent pair of words differs by a single letter.\n+Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n+sk == endWord\n+Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk]\n      */\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         return {};\n"
                },
                {
                    "date": 1724995883355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,10 @@\n using ladders = std::vector<std::string>;\n \n     /**\n      * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n \n Every adjacent pair of words differs by a single letter.\n Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n sk == endWord\n"
                },
                {
                    "date": 1724995888827,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,10 +9,9 @@\n     /**\n      * https://leetcode.com/problems/word-ladder-ii\n      * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n      * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-\n-Every adjacent pair of words differs by a single letter.\n+     * Every adjacent pair of words differs by a single letter.\n Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n sk == endWord\n Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk]\n      */\n"
                },
                {
                    "date": 1724995896006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,10 +10,9 @@\n      * https://leetcode.com/problems/word-ladder-ii\n      * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n      * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n      * Every adjacent pair of words differs by a single letter.\n-Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n-sk == endWord\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk]\n      */\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n"
                },
                {
                    "date": 1724995904796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,10 @@\n      * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n      * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n      * Every adjacent pair of words differs by a single letter.\n      * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk]\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk]\n      */\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         return {};\n"
                },
                {
                    "date": 1724995913236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,11 @@\n      * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n      * Every adjacent pair of words differs by a single letter.\n      * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n      * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk]\n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk]\n      */\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         return {};\n"
                },
                {
                    "date": 1724995919377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,23 @@\n+#include <string>\n+#include <vector>\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        return {};\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007486877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,9 @@\n #include <string>\n #include <vector>\n-\n+#include <map>\n+#include <queue>\n+#include <unordered_set>\n namespace algorithms::graph::leetcode::find_ladders\n {\n \n using ladders = std::vector<std::string>;\n@@ -19,29 +21,5 @@\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         return {};\n     }\n-}\n-#include <string>\n-#include <vector>\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk]\n-     */\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        return {};\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007494635,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,10 @@\n #include <string>\n #include <vector>\n-#include <map>\n #include <queue>\n #include <unordered_set>\n+\n+\n namespace algorithms::graph::leetcode::find_ladders\n {\n \n using ladders = std::vector<std::string>;\n"
                },
                {
                    "date": 1725007502308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,12 @@\n \n namespace algorithms::graph::leetcode::find_ladders\n {\n \n+\n+using dist = std::unordered_map<std::string, int>;\n+using graph = std::map<std::string, std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n using ladders = std::vector<std::string>;\n \n     /**\n      * https://leetcode.com/problems/word-ladder-ii\n"
                },
                {
                    "date": 1725007517289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,8 @@\n {\n \n \n using dist = std::unordered_map<std::string, int>;\n-using graph = std::map<std::string, std::vector<std::string>>;\n using words = std::unordered_set<std::string>;\n using ladders = std::vector<std::string>;\n \n     /**\n"
                },
                {
                    "date": 1725007529458,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n namespace algorithms::graph::leetcode::find_ladders\n {\n \n \n-using dist = std::unordered_map<std::string, int>;\n+using  = std::unordered_map<std::string, int>;\n using words = std::unordered_set<std::string>;\n using ladders = std::vector<std::string>;\n \n     /**\n"
                },
                {
                    "date": 1725007535547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,29 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using depth = std::unordered_map<std::string, int>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        return {};\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007541634,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,29 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::unordered_map<std::string, int>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        return {};\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007553030,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n namespace algorithms::graph::leetcode::find_ladders\n {\n \n \n-using graph = std::unordered_map<std::string, int>;\n+using graph = std::vector<>\n using words = std::unordered_set<std::string>;\n using ladders = std::vector<std::string>;\n \n     /**\n@@ -25,63 +25,5 @@\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         return {};\n     }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using depth = std::unordered_map<std::string, int>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        return {};\n-    }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using  = std::unordered_map<std::string, int>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        return {};\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007561155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n namespace algorithms::graph::leetcode::find_ladders\n {\n \n \n-using graph = std::vector<>\n+using graph = std::vector<std::vector<std::string>>;\n using words = std::unordered_set<std::string>;\n using ladders = std::vector<std::string>;\n \n     /**\n"
                },
                {
                    "date": 1725007581551,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,8 +21,43 @@\n      * Given two words, beginWord and endWord, and a dictionary wordList, \n      * return all the shortest transformation sequences from beginWord to endWord, \n      * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n      * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    int ans = 0;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+            {\n+              finished = true;\n+              ans = dist;\n+              break;\n+            }\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                    }\n+            }\n+            ws.erase(word);\n+        }\n+    }\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         return {};\n     }\n"
                },
                {
                    "date": 1725007602277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,9 @@\n     const int end = 122;\n     bool finished = false;\n     std::string tmp;\n     int ans = 0;\n+    \n     void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n     {\n         while(!q.empty() && \n               !finished)\n"
                },
                {
                    "date": 1725007616926,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,7 +59,11 @@\n         }\n     }\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n-        return {};\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        return ans;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007631131,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n     const int end = 122;\n     bool finished = false;\n     std::string tmp;\n     int ans = 0;\n-    \n+    graph \n     void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n     {\n         while(!q.empty() && \n               !finished)\n"
                },
                {
                    "date": 1725007706173,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n     const int end = 122;\n     bool finished = false;\n     std::string tmp;\n     int ans = 0;\n-    graph \n+    graph g;\n     void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n     {\n         while(!q.empty() && \n               !finished)\n@@ -45,8 +45,9 @@\n             }\n            auto it = ws.find(word);  \n            if(it != ws.end() && !finished)\n             {\n+                std::vector<std::string> xs;\n                 for(int i = 0; i < word.size(); i++)\n                   for(int j = start; j <= end; j++)\n                     if((char)j != word[i])\n                     {\n"
                },
                {
                    "date": 1725007725243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,8 +53,9 @@\n                     {\n                       tmp = word;\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n+                      xs\n                     }\n             }\n             ws.erase(word);\n         }\n"
                },
                {
                    "date": 1725007744625,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n                     {\n                       tmp = word;\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n-                      xs\n+                      xs.push_back(tmp);\n                     }\n             }\n             ws.erase(word);\n         }\n"
                },
                {
                    "date": 1725007766052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,8 +55,9 @@\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n                       xs.push_back(tmp);\n                     }\n+                    \n             }\n             ws.erase(word);\n         }\n     }\n"
                },
                {
                    "date": 1725007780629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,8 @@\n     const int start = 97;\n     const int end = 122;\n     bool finished = false;\n     std::string tmp;\n-    int ans = 0;\n     graph g;\n     void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n     {\n         while(!q.empty() && \n@@ -55,9 +54,9 @@\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n                       xs.push_back(tmp);\n                     }\n-                    \n+                g.push_back(xs);    \n             }\n             ws.erase(word);\n         }\n     }\n"
                },
                {
                    "date": 1725007787893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,11 +36,9 @@\n             q.pop();\n             std::string word = v.first;\n             int dist = v.second;\n             if(word == sink)\n-            {\n               finished = true;\n-              ans = dist;\n               break;\n             }\n            auto it = ws.find(word);  \n            if(it != ws.end() && !finished)\n"
                },
                {
                    "date": 1725007799836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,10 +37,8 @@\n             std::string word = v.first;\n             int dist = v.second;\n             if(word == sink)\n               finished = true;\n-              break;\n-            }\n            auto it = ws.find(word);  \n            if(it != ws.end() && !finished)\n             {\n                 std::vector<std::string> xs;\n@@ -63,7 +61,7 @@\n         std::queue<std::pair<std::string, int>> q;\n         words ws(wordList.begin(), wordList.end());\n         q.push({endWord, 1});\n         bfs(ws, beginWord, q);\n-        return ans;\n+        return ;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007808293,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,7 +61,8 @@\n         std::queue<std::pair<std::string, int>> q;\n         words ws(wordList.begin(), wordList.end());\n         q.push({endWord, 1});\n         bfs(ws, beginWord, q);\n+        dfs()\n         return ;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007818369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,8 +61,9 @@\n         std::queue<std::pair<std::string, int>> q;\n         words ws(wordList.begin(), wordList.end());\n         q.push({endWord, 1});\n         bfs(ws, beginWord, q);\n+        \n         dfs()\n         return ;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007825084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,69 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::vector<std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                std::vector<std::string> xs;\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      xs.push_back(tmp);\n+                    }\n+                g.push_back(xs);    \n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        dfs()\n+        return ;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007831112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,69 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::vector<std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                std::vector<std::string> xs;\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      xs.push_back(tmp);\n+                    }\n+                g.push_back(xs);    \n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        dfs(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725007844288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,70 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::vector<std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                std::vector<std::string> xs;\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      xs.push_back(tmp);\n+                    }\n+                g.push_back(xs);    \n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore()\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        dfs(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725008379527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,212 +66,5 @@\n         ladders ans;\n         dfs(ans);\n         return ans;\n     }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::vector<std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g;\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                std::vector<std::string> xs;\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      xs.push_back(tmp);\n-                    }\n-                g.push_back(xs);    \n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        dfs(ans);\n-        return ans;\n-    }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::vector<std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g;\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                std::vector<std::string> xs;\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      xs.push_back(tmp);\n-                    }\n-                g.push_back(xs);    \n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        dfs()\n-        return ;\n-    }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::vector<std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g;\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                std::vector<std::string> xs;\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      xs.push_back(tmp);\n-                    }\n-                g.push_back(xs);    \n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        \n-        dfs()\n-        return ;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725008384727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,70 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::vector<std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                std::vector<std::string> xs;\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      xs.push_back(tmp);\n+                    }\n+                g.push_back(xs);    \n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore()\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        dfs(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725008390008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n             }\n             ws.erase(word);\n         }\n     }\n-    void restore()\n+    void restore(ladders)\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         std::queue<std::pair<std::string, int>> q;\n         words ws(wordList.begin(), wordList.end());\n@@ -66,75 +66,5 @@\n         ladders ans;\n         dfs(ans);\n         return ans;\n     }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::vector<std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g;\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                std::vector<std::string> xs;\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      xs.push_back(tmp);\n-                    }\n-                g.push_back(xs);    \n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    void restore()\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        dfs(ans);\n-        return ans;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725008395571,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,70 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::vector<std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                std::vector<std::string> xs;\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      xs.push_back(tmp);\n+                    }\n+                g.push_back(xs);    \n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore(ladders& ans) {}\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        dfs(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725008403987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,70 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::vector<std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                std::vector<std::string> xs;\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      xs.push_back(tmp);\n+                    }\n+                g.push_back(xs);    \n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore_paths(ladders& ans) {}\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        dfs(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725008413340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,156 +55,16 @@\n             }\n             ws.erase(word);\n         }\n     }\n-    void restore_paths(ladders& ans) {}\n+    void restore_ladders(ladders& ans) {}\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         std::queue<std::pair<std::string, int>> q;\n         words ws(wordList.begin(), wordList.end());\n         q.push({endWord, 1});\n         bfs(ws, beginWord, q);\n         ladders ans;\n-        dfs(ans);\n+        restore_ladders(ans);\n         return ans;\n     }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::vector<std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g;\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                std::vector<std::string> xs;\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      xs.push_back(tmp);\n-                    }\n-                g.push_back(xs);    \n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    void restore(ladders& ans) {}\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        dfs(ans);\n-        return ans;\n-    }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::vector<std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g;\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                std::vector<std::string> xs;\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      xs.push_back(tmp);\n-                    }\n-                g.push_back(xs);    \n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    void restore(ladders)\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        dfs(ans);\n-        return ans;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725008422778,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n                       xs.push_back(tmp);\n                     }\n-                g.push_back(xs);    \n+                g.push_back(xs);\n             }\n             ws.erase(word);\n         }\n     }\n"
                },
                {
                    "date": 1725008628618,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,73 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::vector<std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                std::vector<std::string> xs;\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      xs.push_back(tmp);\n+                    }\n+                g.push_back(xs);\n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore_ladders(ladders& ans) \n+    {\n+        for()\n+    }\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        restore_ladders(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725008638394,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,9 @@\n         }\n     }\n     void restore_ladders(ladders& ans) \n     {\n-        for()\n+        for(auto )\n     }\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         std::queue<std::pair<std::string, int>> q;\n@@ -69,75 +69,5 @@\n         ladders ans;\n         restore_ladders(ans);\n         return ans;\n     }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::vector<std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g;\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                std::vector<std::string> xs;\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      xs.push_back(tmp);\n-                    }\n-                g.push_back(xs);\n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    void restore_ladders(ladders& ans) {}\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        restore_ladders(ans);\n-        return ans;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725008657848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,13 @@\n         }\n     }\n     void restore_ladders(ladders& ans) \n     {\n-        for(auto )\n+        for(auto xs : g)\n+        {\n+            for(auto x : xs)\n+              cout << \"\"\n+        }\n     }\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         std::queue<std::pair<std::string, int>> q;\n"
                },
                {
                    "date": 1725008666034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,9 +60,10 @@\n     {\n         for(auto xs : g)\n         {\n             for(auto x : xs)\n-              cout << \"\"\n+              cout << x << \" \";\n+            cout << \"\\n\";  \n         }\n     }\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n"
                },
                {
                    "date": 1725009600492,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,9 @@\n     const int start = 97;\n     const int end = 122;\n     bool finished = false;\n     std::string tmp;\n-    graph g;\n+    graph g();\n     void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n     {\n         while(!q.empty() && \n               !finished)\n"
                },
                {
                    "date": 1725009609495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,9 @@\n     const int start = 97;\n     const int end = 122;\n     bool finished = false;\n     std::string tmp;\n-    graph g();\n+    graph g(1000);\n     void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n     {\n         while(!q.empty() && \n               !finished)\n"
                },
                {
                    "date": 1725009653434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,8 +50,9 @@\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n                       xs.push_back(tmp);\n                     }\n+                    \n                 g.push_back(xs);\n             }\n             ws.erase(word);\n         }\n"
                },
                {
                    "date": 1725009660042,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,10 +49,9 @@\n                       tmp = word;\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n                       xs.push_back(tmp);\n-                    }\n-                    \n+                    }    \n                 g.push_back(xs);\n             }\n             ws.erase(word);\n         }\n"
                },
                {
                    "date": 1725009666304,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,78 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::vector<std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g(1000);\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                std::vector<std::string> xs;\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      xs.push_back(tmp);\n+                    }    \n+                g[dist + 1].push_back(xs);\n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore_ladders(ladders& ans) \n+    {\n+        for(auto xs : g)\n+        {\n+            for(auto x : xs)\n+              cout << x << \" \";\n+            cout << \"\\n\";  \n+        }\n+    }\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        restore_ladders(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725009677592,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n                       xs.push_back(tmp);\n                     }    \n-                g[dist + 1].push_back(xs);\n+                g[dist + 1]).push_back(xs);\n             }\n             ws.erase(word);\n         }\n     }\n@@ -74,83 +74,5 @@\n         ladders ans;\n         restore_ladders(ans);\n         return ans;\n     }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::vector<std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g(1000);\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                std::vector<std::string> xs;\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      xs.push_back(tmp);\n-                    }    \n-                g.push_back(xs);\n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    void restore_ladders(ladders& ans) \n-    {\n-        for(auto xs : g)\n-        {\n-            for(auto x : xs)\n-              cout << x << \" \";\n-            cout << \"\\n\";  \n-        }\n-    }\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        restore_ladders(ans);\n-        return ans;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725009690816,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n                       xs.push_back(tmp);\n                     }    \n-                g[dist + 1]).push_back(xs);\n+                (g[dist + 1];\n             }\n             ws.erase(word);\n         }\n     }\n"
                },
                {
                    "date": 1725009699557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n                       xs.push_back(tmp);\n                     }    \n-                (g[dist + 1];\n+                g[dist + 1].push_back();\n             }\n             ws.erase(word);\n         }\n     }\n"
                },
                {
                    "date": 1725009716503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n                       xs.push_back(tmp);\n                     }    \n-                g[dist + 1].push_back();\n+                g[dist + 1]push_back();\n             }\n             ws.erase(word);\n         }\n     }\n"
                },
                {
                    "date": 1725009724002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n                       xs.push_back(tmp);\n                     }    \n-                g[dist + 1]push_back();\n+                g[dist + 1].push_back();\n             }\n             ws.erase(word);\n         }\n     }\n"
                },
                {
                    "date": 1725009731633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,77 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::vector<std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g(1000);\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                std::vector<std::string> xs;\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      xs.push_back(tmp);\n+                    }\n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore_ladders(ladders& ans) \n+    {\n+        for(auto xs : g)\n+        {\n+            for(auto x : xs)\n+              cout << x << \" \";\n+            cout << \"\\n\";  \n+        }\n+    }\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        restore_ladders(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725009741590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,77 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::vector<std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g(1000);\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                std::vector<std::string> xs;\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      g[dist + 1].push_back();\n+                    }\n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore_ladders(ladders& ans) \n+    {\n+        for(auto xs : g)\n+        {\n+            for(auto x : xs)\n+              cout << x << \" \";\n+            cout << \"\\n\";  \n+        }\n+    }\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        restore_ladders(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725009834643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,9 @@\n     const int start = 97;\n     const int end = 122;\n     bool finished = false;\n     std::string tmp;\n-    graph g(1000);\n+    graph g(160);\n     void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n     {\n         while(!q.empty() && \n               !finished)\n@@ -40,17 +40,16 @@\n               finished = true;\n            auto it = ws.find(word);  \n            if(it != ws.end() && !finished)\n             {\n-                std::vector<std::string> xs;\n                 for(int i = 0; i < word.size(); i++)\n                   for(int j = start; j <= end; j++)\n                     if((char)j != word[i])\n                     {\n                       tmp = word;\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n-                      g[dist + 1].push_back();\n+                      g[dist + 1].push_back(tmp);\n                     }\n             }\n             ws.erase(word);\n         }\n@@ -73,160 +72,5 @@\n         ladders ans;\n         restore_ladders(ans);\n         return ans;\n     }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::vector<std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g(1000);\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                std::vector<std::string> xs;\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      xs.push_back(tmp);\n-                    }\n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    void restore_ladders(ladders& ans) \n-    {\n-        for(auto xs : g)\n-        {\n-            for(auto x : xs)\n-              cout << x << \" \";\n-            cout << \"\\n\";  \n-        }\n-    }\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        restore_ladders(ans);\n-        return ans;\n-    }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::vector<std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g(1000);\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                std::vector<std::string> xs;\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      xs.push_back(tmp);\n-                    }    \n-                g[dist + 1].push_back();\n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    void restore_ladders(ladders& ans) \n-    {\n-        for(auto xs : g)\n-        {\n-            for(auto x : xs)\n-              cout << x << \" \";\n-            cout << \"\\n\";  \n-        }\n-    }\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        restore_ladders(ans);\n-        return ans;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725009875340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n                     {\n                       tmp = word;\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n-                      g[dist + 1].push_back(tmp);\n+                      g[dist].push_back(tmp);\n                     }\n             }\n             ws.erase(word);\n         }\n"
                },
                {
                    "date": 1725009989156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,10 @@\n #include <string>\n #include <vector>\n #include <queue>\n #include <unordered_set>\n+#include <\n \n-\n namespace algorithms::graph::leetcode::find_ladders\n {\n \n \n"
                },
                {
                    "date": 1725010004738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,15 @@\n #include <string>\n #include <vector>\n #include <queue>\n #include <unordered_set>\n-#include <\n+#include <map>\n \n namespace algorithms::graph::leetcode::find_ladders\n {\n \n \n-using graph = std::vector<std::vector<std::string>>;\n+using graph = std::map<std::string, std::vector<std::string>>;\n using words = std::unordered_set<std::string>;\n using ladders = std::vector<std::string>;\n \n     /**\n"
                },
                {
                    "date": 1725010016905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,9 @@\n     const int start = 97;\n     const int end = 122;\n     bool finished = false;\n     std::string tmp;\n-    graph g(160);\n+    graph g;\n     void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n     {\n         while(!q.empty() && \n               !finished)\n"
                },
                {
                    "date": 1725010023710,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n                     {\n                       tmp = word;\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n-                      g[dist].push_back(tmp);\n+                      g[].push_back(tmp);\n                     }\n             }\n             ws.erase(word);\n         }\n"
                },
                {
                    "date": 1725010031403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,76 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+#include <map>\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::map<std::string, std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      g[word].push_back(tmp);\n+                    }\n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore_ladders(ladders& ans) \n+    {\n+        for(auto xs : g)\n+        {\n+            for(auto x : xs)\n+              cout << x << \" \";\n+            cout << \"\\n\";  \n+        }\n+    }\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        restore_ladders(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725010040403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,9 @@\n     void restore_ladders(ladders& ans) \n     {\n         for(auto xs : g)\n         {\n-            for(auto x : xs)\n+            for(auto x : xs.)\n               cout << x << \" \";\n             cout << \"\\n\";  \n         }\n     }\n@@ -72,81 +72,5 @@\n         ladders ans;\n         restore_ladders(ans);\n         return ans;\n     }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-#include <map>\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::map<std::string, std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g;\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      g[].push_back(tmp);\n-                    }\n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    void restore_ladders(ladders& ans) \n-    {\n-        for(auto xs : g)\n-        {\n-            for(auto x : xs)\n-              cout << x << \" \";\n-            cout << \"\\n\";  \n-        }\n-    }\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        restore_ladders(ans);\n-        return ans;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725010048218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,10 @@\n     void restore_ladders(ladders& ans) \n     {\n         for(auto xs : g)\n         {\n-            for(auto x : xs.)\n+            \n+            for(auto x : xs.second)\n               cout << x << \" \";\n             cout << \"\\n\";  \n         }\n     }\n"
                },
                {
                    "date": 1725010058681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,9 @@\n     void restore_ladders(ladders& ans) \n     {\n         for(auto xs : g)\n         {\n-            \n+            cout << \"node: \" << xs.first << \"\"\n             for(auto x : xs.second)\n               cout << x << \" \";\n             cout << \"\\n\";  \n         }\n"
                },
                {
                    "date": 1725010066108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,77 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+#include <map>\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::map<std::string, std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      g[word].push_back(tmp);\n+                    }\n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore_ladders(ladders& ans) \n+    {\n+        for(auto xs : g)\n+        {\n+            cout << xs.first << \": \";\n+            for(auto x : xs.second)\n+              cout << x << \" \";\n+            cout << \"\\n\";  \n+        }\n+    }\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        restore_ladders(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725010154193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,15 +55,8 @@\n         }\n     }\n     void restore_ladders(ladders& ans) \n     {\n-        for(auto xs : g)\n-        {\n-            cout << xs.first << \": \";\n-            for(auto x : xs.second)\n-              cout << x << \" \";\n-            cout << \"\\n\";  \n-        }\n     }\n     ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n     {\n         std::queue<std::pair<std::string, int>> q;\n@@ -73,82 +66,5 @@\n         ladders ans;\n         restore_ladders(ans);\n         return ans;\n     }\n-}\n-#include <string>\n-#include <vector>\n-#include <queue>\n-#include <unordered_set>\n-#include <map>\n-\n-namespace algorithms::graph::leetcode::find_ladders\n-{\n-\n-\n-using graph = std::map<std::string, std::vector<std::string>>;\n-using words = std::unordered_set<std::string>;\n-using ladders = std::vector<std::string>;\n-\n-    /**\n-     * https://leetcode.com/problems/word-ladder-ii\n-     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n-     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n-     * Every adjacent pair of words differs by a single letter.\n-     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n-     * Given two words, beginWord and endWord, and a dictionary wordList, \n-     * return all the shortest transformation sequences from beginWord to endWord, \n-     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n-     * [beginWord, s1, s2, ..., sk] */\n-    const int start = 97;\n-    const int end = 122;\n-    bool finished = false;\n-    std::string tmp;\n-    graph g;\n-    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n-    {\n-        while(!q.empty() && \n-              !finished)\n-        {\n-            auto v = q.front();\n-            q.pop();\n-            std::string word = v.first;\n-            int dist = v.second;\n-            if(word == sink)\n-              finished = true;\n-           auto it = ws.find(word);  \n-           if(it != ws.end() && !finished)\n-            {\n-                for(int i = 0; i < word.size(); i++)\n-                  for(int j = start; j <= end; j++)\n-                    if((char)j != word[i])\n-                    {\n-                      tmp = word;\n-                      tmp[i] = (char)j;\n-                      q.push({tmp, dist + 1});\n-                      g[word].push_back(tmp);\n-                    }\n-            }\n-            ws.erase(word);\n-        }\n-    }\n-    void restore_ladders(ladders& ans) \n-    {\n-        for(auto xs : g)\n-        {\n-            cout << \"node: \" << xs.first << \"\"\n-            for(auto x : xs.second)\n-              cout << x << \" \";\n-            cout << \"\\n\";  \n-        }\n-    }\n-    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n-    {\n-        std::queue<std::pair<std::string, int>> q;\n-        words ws(wordList.begin(), wordList.end());\n-        q.push({endWord, 1});\n-        bfs(ws, beginWord, q);\n-        ladders ans;\n-        restore_ladders(ans);\n-        return ans;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725010436865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n namespace algorithms::graph::leetcode::find_ladders\n {\n \n \n-using graph = std::map<std::string, std::vector<std::string>>;\n+using graph = std::map<std::vector<std::string>>;\n using words = std::unordered_set<std::string>;\n using ladders = std::vector<std::string>;\n \n     /**\n"
                },
                {
                    "date": 1725010447403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n namespace algorithms::graph::leetcode::find_ladders\n {\n \n \n-using graph = std::map<std::vector<std::string>>;\n+using graph = std::vector<std::vector<std::string>>;\n using words = std::unordered_set<std::string>;\n using ladders = std::vector<std::string>;\n \n     /**\n"
                },
                {
                    "date": 1725010463793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,8 @@\n #include <string>\n #include <vector>\n #include <queue>\n #include <unordered_set>\n-#include <map>\n \n namespace algorithms::graph::leetcode::find_ladders\n {\n \n@@ -47,9 +46,9 @@\n                     {\n                       tmp = word;\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n-                      g[word].push_back(tmp);\n+                      g[].push_back(tmp);\n                     }\n             }\n             ws.erase(word);\n         }\n"
                },
                {
                    "date": 1725010470208,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n                     {\n                       tmp = word;\n                       tmp[i] = (char)j;\n                       q.push({tmp, dist + 1});\n-                      g[dist].push_back(tmp);\n+                      g[word].push_back(tmp);\n                     }\n             }\n             ws.erase(word);\n         }\n"
                },
                {
                    "date": 1725010514674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,71 @@\n+#include <string>\n+#include <vector>\n+#include <queue>\n+#include <unordered_set>\n+#include <map>\n+\n+namespace algorithms::graph::leetcode::find_ladders\n+{\n+\n+\n+using graph = std::map<std::string, std::vector<std::string>>;\n+using words = std::unordered_set<std::string>;\n+using ladders = std::vector<std::string>;\n+\n+    /**\n+     * https://leetcode.com/problems/word-ladder-ii\n+     * A transformation sequence from word beginWord to word endWord using a dictionary wordList \n+     * is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n+     * Every adjacent pair of words differs by a single letter.\n+     * Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord\n+     * Given two words, beginWord and endWord, and a dictionary wordList, \n+     * return all the shortest transformation sequences from beginWord to endWord, \n+     * or an empty list if no such sequence exists. Each sequence should be returned as a list of the words \n+     * [beginWord, s1, s2, ..., sk] */\n+    const int start = 97;\n+    const int end = 122;\n+    bool finished = false;\n+    std::string tmp;\n+    graph g;\n+    void bfs(words& ws, const std::string& sink, std::queue<std::pair<std::string, int>>& q)\n+    {\n+        while(!q.empty() && \n+              !finished)\n+        {\n+            auto v = q.front();\n+            q.pop();\n+            std::string word = v.first;\n+            int dist = v.second;\n+            if(word == sink)\n+              finished = true;\n+           auto it = ws.find(word);  \n+           if(it != ws.end() && !finished)\n+            {\n+                for(int i = 0; i < word.size(); i++)\n+                  for(int j = start; j <= end; j++)\n+                    if((char)j != word[i])\n+                    {\n+                      tmp = word;\n+                      tmp[i] = (char)j;\n+                      q.push({tmp, dist + 1});\n+                      g[word].push_back(tmp);\n+                    }\n+            }\n+            ws.erase(word);\n+        }\n+    }\n+    void restore_ladders(ladders& ans) \n+    {\n+        \n+    }\n+    ladders findLadders(std::string beginWord, std::string endWord, const std::vector<std::string>& wordList)\n+    {\n+        std::queue<std::pair<std::string, int>> q;\n+        words ws(wordList.begin(), wordList.end());\n+        q.push({endWord, 1});\n+        bfs(ws, beginWord, q);\n+        ladders ans;\n+        restore_ladders(ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1724995756999,
            "name": "Commit-0",
            "content": "\n\nnamespace algorithms::graph::leetcode::f"
        }
    ]
}