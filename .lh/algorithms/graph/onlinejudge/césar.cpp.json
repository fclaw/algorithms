{
    "sourceFile": "algorithms/graph/onlinejudge/césar.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 133,
            "patches": [
                {
                    "date": 1727432247083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1727432252581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,3 +1,3 @@\n \n \n-namesp\n\\ No newline at end of file\n+namespace César\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727432265364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,3 +1,3 @@\n \n \n-namespace César\n\\ No newline at end of file\n+namespace algorithms::graph::onlinejudge::césar\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727432313735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,3 +1,6 @@\n \n \n-namespace algorithms::graph::onlinejudge::césar\n\\ No newline at end of file\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+    \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727432940661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n+#include \"../lp_dag.cpp\"\n \n \n namespace algorithms::graph::onlinejudge::césar\n {\n-    \n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727432954852,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,5 +3,8 @@\n \n namespace algorithms::graph::onlinejudge::césar\n {\n \n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727432960454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,5 +6,8 @@\n \n typedef std::vector<int> table;\n namespace lp = algorithms::graph::lp_dag;\n \n+    \n+\n+\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727432971522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,8 @@\n \n typedef std::vector<int> table;\n namespace lp = algorithms::graph::lp_dag;\n \n-    \n+    longestPath\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727432998068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,8 @@\n \n typedef std::vector<int> table;\n namespace lp = algorithms::graph::lp_dag;\n \n-    longestPath\n+    longestPath(const lp::adj& graph, const std::vector<int>& sinks)\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433004995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,11 @@\n \n typedef std::vector<int> table;\n namespace lp = algorithms::graph::lp_dag;\n \n-    longestPath(const lp::adj& graph, const std::vector<int>& sinks)\n+    int longestPath(const lp::adj& graph, const std::vector<int>& sinks)\n+    {\n+        \n+    }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433017014,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n namespace lp = algorithms::graph::lp_dag;\n \n     int longestPath(const lp::adj& graph, const std::vector<int>& sinks)\n     {\n-        \n+        table dp(graph.size(), 0);\n     }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433043452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,9 @@\n namespace lp = algorithms::graph::lp_dag;\n \n     int longestPath(const lp::adj& graph, const std::vector<int>& sinks)\n     {\n+        lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n         table dp(graph.size(), 0);\n     }\n \n \n"
                },
                {
                    "date": 1727433052338,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,9 @@\n     int longestPath(const lp::adj& graph, const std::vector<int>& sinks)\n     {\n         lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n         table dp(graph.size(), 0);\n+        for()\n     }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433062304,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,11 @@\n     int longestPath(const lp::adj& graph, const std::vector<int>& sinks)\n     {\n         lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n         table dp(graph.size(), 0);\n-        for()\n+                for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] += dp[v];\n     }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433071932,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,11 +10,11 @@\n     int longestPath(const lp::adj& graph, const std::vector<int>& sinks)\n     {\n         lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n         table dp(graph.size(), 0);\n-                for(auto v : vertices)\n+        for(auto v : vertices)\n           for(auto u : graph[v])\n-            dp[u] += dp[v];\n+            dp[u] = std::max( dp[v];\n     }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433077841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n         lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n-            dp[u] = std::max( dp[v];\n+            dp[u] = std::max(dp[u], 1 + dp[v];\n     }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433084590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,10 @@\n         lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v];\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+            \n     }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433090703,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-            \n+        return dp[]    \n     }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433096184,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return dp[]    \n+        return dp[vertices.]    \n     }\n \n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433122192,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,16 +6,15 @@\n \n typedef std::vector<int> table;\n namespace lp = algorithms::graph::lp_dag;\n \n-    int longestPath(const lp::adj& graph, const std::vector<int>& sinks)\n+    int longestPath(const lp::adj& graph, )\n     {\n         lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return dp[vertices.]    \n+        return dp[vertices.back()];    \n     }\n \n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433129599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n \n typedef std::vector<int> table;\n namespace lp = algorithms::graph::lp_dag;\n \n-    int longestPath(const lp::adj& graph, )\n+    int longestPath(int start, const lp::adj& graph)\n     {\n         lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n"
                },
                {
                    "date": 1727433134868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n namespace lp = algorithms::graph::lp_dag;\n \n     int longestPath(int start, const lp::adj& graph)\n     {\n-        lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n+        lp::vs vertices = lp::topological_sort(graph.size(), , graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n"
                },
                {
                    "date": 1727433143455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,9 @@\n namespace lp = algorithms::graph::lp_dag;\n \n     int longestPath(int start, const lp::adj& graph)\n     {\n+        auto s = std::make+_o\n         lp::vs vertices = lp::topological_sort(graph.size(), , graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n"
                },
                {
                    "date": 1727433149262,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n namespace lp = algorithms::graph::lp_dag;\n \n     int longestPath(int start, const lp::adj& graph)\n     {\n-        auto s = std::make+_o\n+        auto s = std::\n         lp::vs vertices = lp::topological_sort(graph.size(), , graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n"
                },
                {
                    "date": 1727433157257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n namespace lp = algorithms::graph::lp_dag;\n \n     int longestPath(int start, const lp::adj& graph)\n     {\n-        auto s = std::\n+        auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(graph.size(), , graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n"
                },
                {
                    "date": 1727433367513,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,13 +9,13 @@\n \n     int longestPath(int start, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(graph.size(), , graph);\n+        lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return dp[vertices.back()];    \n+        return dp[vertices.front()];    \n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433387603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,8 +14,8 @@\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return dp[vertices.front()];    \n+        return dp[vertices.];    \n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433399634,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,12 +10,15 @@\n     int longestPath(int start, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n+\n+        for(auto v : vertices)\n+\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return dp[vertices.];    \n+        return dp[vertices.back()];    \n     }\n \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433407998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,10 @@\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n \n-        for(auto v : vertices)\n+        for(auto v : vertices) cout << v << \" \";\n+        cout << \"\\n\"l;\n \n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n"
                },
                {
                    "date": 1727433518100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,12 +9,12 @@\n \n     int longestPath(int start, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n+        lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n \n         for(auto v : vertices) cout << v << \" \";\n-        cout << \"\\n\"l;\n+        cout << \"\\n\";\n \n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n"
                },
                {
                    "date": 1727433612062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n \n     int longestPath(int start, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(graph.size(), std::nullopt, graph);\n+        lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n \n         for(auto v : vertices) cout << v << \" \";\n         cout << \"\\n\";\n \n"
                },
                {
                    "date": 1727433645233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,11 +11,8 @@\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n \n-        for(auto v : vertices) cout << v << \" \";\n-        cout << \"\\n\";\n-\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n"
                },
                {
                    "date": 1727433653266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,25 @@\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+    int longestPath(int start, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n+        table dp(graph.size(), 0);\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        return dp[vertices.back()];    \n+    }\n+\n+\n+    \n+    \n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433659796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,30 +18,8 @@\n         return dp[vertices.back()];    \n     }\n \n \n-    \n-    \n+    s\n \n-}\n-#include \"../lp_dag.cpp\"\n \n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-    int longestPath(int start, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n-\n-        table dp(graph.size(), 0);\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return dp[vertices.back()];    \n-    }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433673044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,8 +18,6 @@\n         return dp[vertices.back()];    \n     }\n \n \n-    s\n-\n-\n+void submit_wl(std::optional<char*> file)\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433680622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+\n #include \"../lp_dag.cpp\"\n \n \n namespace algorithms::graph::onlinejudge::césar\n@@ -18,6 +19,6 @@\n         return dp[vertices.back()];    \n     }\n \n \n-void submit_wl(std::optional<char*> file)\n+    void submit_wl(std::optional<char*> file)\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433686954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-\n+#include <vec\n #include \"../lp_dag.cpp\"\n \n \n namespace algorithms::graph::onlinejudge::césar\n"
                },
                {
                    "date": 1727433692890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n-#include <vec\n+#include <vector>\n+\n #include \"../lp_dag.cpp\"\n \n \n namespace algorithms::graph::onlinejudge::césar\n"
                },
                {
                    "date": 1727433698146,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n #include <vector>\n-\n+#include <optional>\n #include \"../lp_dag.cpp\"\n \n \n namespace algorithms::graph::onlinejudge::césar\n"
                },
                {
                    "date": 1727433710134,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,8 @@\n #include <vector>\n #include <optional>\n+#include <iostream>\n+#include <cassert>\n #include \"../lp_dag.cpp\"\n \n \n namespace algorithms::graph::onlinejudge::césar\n"
                },
                {
                    "date": 1727433715435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,7 +21,9 @@\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         return dp[vertices.back()];    \n     }\n \n+    void submit_wl(std::optional<char*> file)\n+    {\n \n-    void submit_wl(std::optional<char*> file)\n+    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433727322,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,9 @@\n \n typedef std::vector<int> table;\n namespace lp = algorithms::graph::lp_dag;\n \n+     /** https://onlinejudge.org/external/100/10000.pdf */\n     int longestPath(int start, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n"
                },
                {
                    "date": 1727433783819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n typedef std::vector<int> table;\n namespace lp = algorithms::graph::lp_dag;\n \n      /** https://onlinejudge.org/external/100/10000.pdf */\n-    int longestPath(int start, const lp::adj& graph)\n+    int longestPath(int start, int V, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n         table dp(graph.size(), 0);\n"
                },
                {
                    "date": 1727433791853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n      /** https://onlinejudge.org/external/100/10000.pdf */\n     int longestPath(int start, int V, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(graph.size(), s, graph);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n@@ -24,7 +24,7 @@\n     }\n \n     void submit_wl(std::optional<char*> file)\n     {\n-\n+        \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433827460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,7 +24,7 @@\n     }\n \n     void submit_wl(std::optional<char*> file)\n     {\n-        \n+        int \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433835519,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,7 +24,8 @@\n     }\n \n     void submit_wl(std::optional<char*> file)\n     {\n-        int \n+        int V;\n+        while()\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433855366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,7 +25,11 @@\n \n     void submit_wl(std::optional<char*> file)\n     {\n         int V;\n-        while()\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+        }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433868114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,7 +29,8 @@\n         while(true)\n         {\n             std::cin >> V;\n             if(V == 0) break;\n+            int \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433879596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,8 +29,10 @@\n         while(true)\n         {\n             std::cin >> V;\n             if(V == 0) break;\n-            int \n+            int start;\n+            std::cin >> start;\n+            \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433892420,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,9 @@\n             std::cin >> V;\n             if(V == 0) break;\n             int start;\n             std::cin >> start;\n+            int from, to;\n             \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433900649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,8 +32,9 @@\n             if(V == 0) break;\n             int start;\n             std::cin >> start;\n             int from, to;\n-            \n+            do\n+            {}\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433909494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,11 @@\n             if(V == 0) break;\n             int start;\n             std::cin >> start;\n             int from, to;\n-            do\n-            {}\n+            while(true)\n+            {\n+                \n+            }\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433949009,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,11 +32,12 @@\n             if(V == 0) break;\n             int start;\n             std::cin >> start;\n             int from, to;\n+            lp::adj \n             while(true)\n             {\n-                \n+\n             }\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433955069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n             if(V == 0) break;\n             int start;\n             std::cin >> start;\n             int from, to;\n-            lp::adj \n+            lp::adj graph()\n             while(true)\n             {\n \n             }\n"
                },
                {
                    "date": 1727433970944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n             if(V == 0) break;\n             int start;\n             std::cin >> start;\n             int from, to;\n-            lp::adj graph()\n+            lp::adj graph(V, {});\n             while(true)\n             {\n \n             }\n"
                },
                {
                    "date": 1727433976027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n             int from, to;\n             lp::adj graph(V, {});\n             while(true)\n             {\n-\n+                \n             }\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433992855,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n             int from, to;\n             lp::adj graph(V, {});\n             while(true)\n             {\n-                \n+                std::cin >> from >> to;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727433999843,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,8 +36,9 @@\n             lp::adj graph(V, {});\n             while(true)\n             {\n                 std::cin >> from >> to;\n+                --from; --to;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434013840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,46 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    int longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(graph.size(), 0);\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        return dp[vertices.back()];    \n+    }\n+\n+    void submit_wl(std::optional<char*> file)\n+    {\n+        int V;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V, {});\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break\n+                --from; --to;\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434019303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,54 +37,12 @@\n             while(true)\n             {\n                 std::cin >> from >> to;\n                 if(from == 0 && to == 0)\n-                  break\n+                  break;\n                 --from; --to;\n+                \n             }\n-        }\n-    }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include \"../lp_dag.cpp\"\n \n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    int longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(graph.size(), 0);\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return dp[vertices.back()];    \n-    }\n-\n-    void submit_wl(std::optional<char*> file)\n-    {\n-        int V;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V, {});\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                --from; --to;\n-            }\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434024912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,9 @@\n                 std::cin >> from >> to;\n                 if(from == 0 && to == 0)\n                   break;\n                 --from; --to;\n-                \n+                graph[from]\n             }\n \n         }\n     }\n"
                },
                {
                    "date": 1727434031253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,9 @@\n                 std::cin >> from >> to;\n                 if(from == 0 && to == 0)\n                   break;\n                 --from; --to;\n-                graph[from]\n+                graph[from].push_back(to);\n             }\n \n         }\n     }\n"
                },
                {
                    "date": 1727434039282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,8 +41,9 @@\n                   break;\n                 --from; --to;\n                 graph[from].push_back(to);\n             }\n+            longestPath()\n \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434046596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n                   break;\n                 --from; --to;\n                 graph[from].push_back(to);\n             }\n-            longestPath()\n+            longestPath(start, V, )\n \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434052509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n                   break;\n                 --from; --to;\n                 graph[from].push_back(to);\n             }\n-            longestPath(start, V, )\n+            longestPath(start, V, graph)\n \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434087214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return dp[vertices.back()];    \n+        return dp[vertices.back()]; \n     }\n \n     void submit_wl(std::optional<char*> file)\n     {\n@@ -41,9 +41,9 @@\n                   break;\n                 --from; --to;\n                 graph[from].push_back(to);\n             }\n-            longestPath(start, V, graph)\n+            longestPath(start, V, graph);\n \n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434146281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,17 +11,17 @@\n typedef std::vector<int> table;\n namespace lp = algorithms::graph::lp_dag;\n \n      /** https://onlinejudge.org/external/100/10000.pdf */\n-    int longestPath(int start, int V, const lp::adj& graph)\n+    std::pair<int longestPath(int start, int V, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(V, s, graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return dp[vertices.back()]; \n+        return dp[vertices.back()];\n     }\n \n     void submit_wl(std::optional<char*> file)\n     {\n"
                },
                {
                    "date": 1727434155633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,12 +8,13 @@\n namespace algorithms::graph::onlinejudge::césar\n {\n \n typedef std::vector<int> table;\n+typedef \n namespace lp = algorithms::graph::lp_dag;\n \n      /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int longestPath(int start, int V, const lp::adj& graph)\n+    std::pair<int, std:: longestPath(int start, int V, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(V, s, graph);\n         table dp(graph.size(), 0);\n"
                },
                {
                    "date": 1727434180670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,8 @@\n namespace algorithms::graph::onlinejudge::césar\n {\n \n typedef std::vector<int> table;\n-typedef \n namespace lp = algorithms::graph::lp_dag;\n \n      /** https://onlinejudge.org/external/100/10000.pdf */\n     std::pair<int, std:: longestPath(int start, int V, const lp::adj& graph)\n"
                },
                {
                    "date": 1727434189517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,17 +11,17 @@\n typedef std::vector<int> table;\n namespace lp = algorithms::graph::lp_dag;\n \n      /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, std:: longestPath(int start, int V, const lp::adj& graph)\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(V, s, graph);\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return dp[vertices.back()];\n+        return {dp[vertices.back()];\n     }\n \n     void submit_wl(std::optional<char*> file)\n     {\n"
                },
                {
                    "date": 1727434195119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return {dp[vertices.back()];\n+        return {dp[vertices.back()], vertices.back()};\n     }\n \n     void submit_wl(std::optional<char*> file)\n     {\n"
                },
                {
                    "date": 1727434204263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,10 @@\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        return {dp[vertices.back()], vertices.back()};\n+        int place = vertices.back();    \n+        return {dp[vertices.back(], vertices.back()};\n     }\n \n     void submit_wl(std::optional<char*> file)\n     {\n"
                },
                {
                    "date": 1727434212975,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         int place = vertices.back();    \n-        return {dp[vertices.back(], vertices.back()};\n+        return {dp[place], place};\n     }\n \n     void submit_wl(std::optional<char*> file)\n     {\n"
                },
                {
                    "date": 1727434234163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,9 @@\n \n     void submit_wl(std::optional<char*> file)\n     {\n         int V;\n+        int case\n         while(true)\n         {\n             std::cin >> V;\n             if(V == 0) break;\n"
                },
                {
                    "date": 1727434240702,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(graph.size(), 0);\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        int place = vertices.back();    \n+        return {dp[place], place};\n+    }\n+\n+    void submit_wl(std::optional<char*> file)\n+    {\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V, {});\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            longestPath(start, V, graph);\n+\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434246401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,60 +43,9 @@\n                   break;\n                 --from; --to;\n                 graph[from].push_back(to);\n             }\n-            longestPath(start, V, graph);\n+            auto ans = longestPath(start, V, graph);\n \n         }\n     }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include \"../lp_dag.cpp\"\n-\n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(graph.size(), 0);\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-        int place = vertices.back();    \n-        return {dp[place], place};\n-    }\n-\n-    void submit_wl(std::optional<char*> file)\n-    {\n-        int V;\n-        int case\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V, {});\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            longestPath(start, V, graph);\n-\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434263873,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,8 +44,8 @@\n                 --from; --to;\n                 graph[from].push_back(to);\n             }\n             auto ans = longestPath(start, V, graph);\n-\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434277939,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n #include <vector>\n #include <optional>\n #include <iostream>\n #include <cassert>\n+#include <csd\n #include \"../lp_dag.cpp\"\n \n \n namespace algorithms::graph::onlinejudge::césar\n@@ -45,7 +46,8 @@\n                 graph[from].push_back(to);\n             }\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n+\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434294777,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n #include <vector>\n #include <optional>\n #include <iostream>\n #include <cassert>\n-#include <csd\n+#include <cstdio>\n #include \"../lp_dag.cpp\"\n \n \n namespace algorithms::graph::onlinejudge::césar\n@@ -46,8 +46,8 @@\n                 graph[from].push_back(to);\n             }\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n-\n+            printf(\"\")\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434304444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,8 +46,8 @@\n                 graph[from].push_back(to);\n             }\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n-            printf(\"\")\n+            printf(\"Case 1: The longest path from 1 has length 1, finishing at 2\")\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434309597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,8 +46,8 @@\n                 graph[from].push_back(to);\n             }\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n-            printf(\"Case 1: The longest path from 1 has length 1, finishing at 2\")\n+            printf(\"Case %d: The longest path from 1 has length 1, finishing at 2\")\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434315355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,8 +46,8 @@\n                 graph[from].push_back(to);\n             }\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n-            printf(\"Case %d: The longest path from 1 has length 1, finishing at 2\")\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at 2\")\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434322887,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,8 +46,9 @@\n                 graph[from].push_back(to);\n             }\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at 2\")\n+            \n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", )\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434328844,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n                 graph[from].push_back(to);\n             }\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n-            \n+            int place = ans.\n             printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", )\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434339007,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,10 @@\n                 graph[from].push_back(to);\n             }\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.\n+            int place = ans.second;\n+            int length = ans.\n             printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", )\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434345824,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n             }\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n             int place = ans.second;\n-            int length = ans.\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", )\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, )\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434351276,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,8 @@\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n             int place = ans.second;\n             int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, )\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start)\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434357226,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,55 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(graph.size(), 0);\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        int place = vertices.back();    \n+        return {dp[place], place};\n+    }\n+\n+    void submit_wl(std::optional<char*> file)\n+    {\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V, {});\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, le)\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434364247,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,63 +48,8 @@\n             auto ans = longestPath(start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n             int place = ans.second;\n             int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, le)\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n         }\n     }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <cstdio>\n-#include \"../lp_dag.cpp\"\n-\n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(graph.size(), 0);\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-        int place = vertices.back();    \n-        return {dp[place], place};\n-    }\n-\n-    void submit_wl(std::optional<char*> file)\n-    {\n-        int V;\n-        int c = 0;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V, {});\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            auto ans = longestPath(start, V, graph);\n-            // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.second;\n-            int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start)\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434401771,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,55 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(graph.size(), 0);\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        int place = vertices.back();    \n+        return {dp[place], place};\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V, {});\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434417344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n             if(V == 0) break;\n             int start;\n             std::cin >> start;\n             int from, to;\n-            lp::adj graph(V, {});\n+            lp::adj graph(V);\n             while(true)\n             {\n                 std::cin >> from >> to;\n                 if(from == 0 && to == 0)\n@@ -51,60 +51,5 @@\n             int length = ans.first;\n             printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n         }\n     }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <cstdio>\n-#include \"../lp_dag.cpp\"\n-\n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(graph.size(), 0);\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-        int place = vertices.back();    \n-        return {dp[place], place};\n-    }\n-\n-    void submit_wl(std::optional<char*> file)\n-    {\n-        int V;\n-        int c = 0;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V, {});\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            auto ans = longestPath(start, V, graph);\n-            // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.second;\n-            int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434542849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,10 @@\n         return {dp[place], place};\n     }\n \n     void submit(std::optional<char*> file)\n-    {\n+    {    if(file.has_value())\n+      assert(freopen(file.value(), \"r\", stdin) != NULL);\n         int V;\n         int c = 0;\n         while(true)\n         {\n"
                },
                {
                    "date": 1727434548983,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,10 +25,11 @@\n         return {dp[place], place};\n     }\n \n     void submit(std::optional<char*> file)\n-    {    if(file.has_value())\n-      assert(freopen(file.value(), \"r\", stdin) != NULL);\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n         int V;\n         int c = 0;\n         while(true)\n         {\n"
                },
                {
                    "date": 1727434652501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n         table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        int place = vertices.back();    \n+        int place = vertices.back();   \n         return {dp[place], place};\n     }\n \n     void submit(std::optional<char*> file)\n"
                },
                {
                    "date": 1727434662814,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(graph.size(), 0);\n+        table dp(graph.size(), 1);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         int place = vertices.back();   \n"
                },
                {
                    "date": 1727434674945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(graph.size(), 1);\n+        table dp(graph.size(), 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         int place = vertices.back();   \n"
                },
                {
                    "date": 1727434683512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,8 +17,9 @@\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(V, s, graph);\n         table dp(graph.size(), 0);\n+        dp[start]\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         int place = vertices.back();   \n"
                },
                {
                    "date": 1727434705652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,58 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(graph.size(), 0);\n+        dp[s] = 1;\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        int place = vertices.back();   \n+        return {dp[place], place};\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V);\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434711895,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,63 +54,5 @@\n             int length = ans.first;\n             printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n         }\n     }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <cstdio>\n-#include \"../lp_dag.cpp\"\n-\n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(graph.size(), 0);\n-        dp[start]\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-        int place = vertices.back();   \n-        return {dp[place], place};\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-        int V;\n-        int c = 0;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V);\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            auto ans = longestPath(start, V, graph);\n-            // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.second;\n-            int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434719885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,58 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(V, 0);\n+        dp[s] = 1;\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        int place = vertices.back();   \n+        return {dp[place], place};\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V);\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434730111,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,58 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(V, 0);\n+        dp[start] = 1;\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        int place = vertices.back();   \n+        return {dp[place], place};\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V);\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434761732,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,66 +21,10 @@\n         dp[start] = 1;\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        int place = vertices.back();   \n-        return {dp[place], place};\n-    }\n \n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-        int V;\n-        int c = 0;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V);\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            auto ans = longestPath(start, V, graph);\n-            // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.second;\n-            int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n-        }\n-    }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <cstdio>\n-#include \"../lp_dag.cpp\"\n-\n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(V, 0);\n-        dp[s] = 1;\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n+            \n         int place = vertices.back();   \n         return {dp[place], place};\n     }\n \n@@ -112,63 +56,5 @@\n             int length = ans.first;\n             printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n         }\n     }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <cstdio>\n-#include \"../lp_dag.cpp\"\n-\n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(graph.size(), 0);\n-        dp[s] = 1;\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-        int place = vertices.back();   \n-        return {dp[place], place};\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-        int V;\n-        int c = 0;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V);\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            auto ans = longestPath(start, V, graph);\n-            // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.second;\n-            int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434778100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,10 @@\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n \n-            \n+        for(int i = 0; i < ) \n+\n         int place = vertices.back();   \n         return {dp[place], place};\n     }\n \n"
                },
                {
                    "date": 1727434784026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,10 @@\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n \n-        for(int i = 0; i < ) \n+        for(int i = 0; i < V; i++)\n+          cout <<  \n \n         int place = vertices.back();   \n         return {dp[place], place};\n     }\n"
                },
                {
                    "date": 1727434791931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n \n         for(int i = 0; i < V; i++)\n-          cout <<  \n+          cout << \"i: \" << i << \", \" \n \n         int place = vertices.back();   \n         return {dp[place], place};\n     }\n"
                },
                {
                    "date": 1727434799390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,62 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(V, 0);\n+        dp[start] = 1;\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+\n+        for(int i = 0; i < V; i++)\n+          cout << \"i: \" << i << \", dp: \" << dp[i] <<  \n+\n+        int place = vertices.back();   \n+        return {dp[place], place};\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V);\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434812001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n \n         for(int i = 0; i < V; i++)\n-          cout << \"i: \" << i << \", dp: \" << dp[i] <<  \n+          cout << \"i: \" << i << \", dp: \" << dp[i] << \"\\n\" \n \n         int place = vertices.back();   \n         return {dp[place], place};\n     }\n@@ -58,67 +58,5 @@\n             int length = ans.first;\n             printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n         }\n     }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <cstdio>\n-#include \"../lp_dag.cpp\"\n-\n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(V, 0);\n-        dp[start] = 1;\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-\n-        for(int i = 0; i < V; i++)\n-          cout << \"i: \" << i << \", \" \n-\n-        int place = vertices.back();   \n-        return {dp[place], place};\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-        int V;\n-        int c = 0;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V);\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            auto ans = longestPath(start, V, graph);\n-            // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.second;\n-            int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434867289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,15 +17,14 @@\n     {\n         auto s = std::make_optional(start);\n         lp::vs vertices = lp::topological_sort(V, s, graph);\n         table dp(V, 0);\n-        dp[start] = 1;\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n \n         for(int i = 0; i < V; i++)\n-          cout << \"i: \" << i << \", dp: \" << dp[i] << \"\\n\" \n+          cout << \"i: \" << i << \", dp: \" << dp[i] << \"\\n\"; \n \n         int place = vertices.back();   \n         return {dp[place], place};\n     }\n"
                },
                {
                    "date": 1727434880993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n \n-        for(int i = 0; i < V; i++)\n+        for(auto )\n           cout << \"i: \" << i << \", dp: \" << dp[i] << \"\\n\"; \n \n         int place = vertices.back();   \n         return {dp[place], place};\n"
                },
                {
                    "date": 1727434894032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,60 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(V, 0);\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+\n+        for(auto v : vertices) cout << v << \" \"\n+\n+        int place = vertices.back();   \n+        return {dp[place], place};\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V);\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434899566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,10 @@\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n \n-        for(auto v : vertices) cout << v << \" \"\n+        for(auto v : vertices) cout << v << \" \";\n+        cout << \"\\n\";\n \n         int place = vertices.back();   \n         return {dp[place], place};\n     }\n@@ -56,66 +57,5 @@\n             int length = ans.first;\n             printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n         }\n     }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <cstdio>\n-#include \"../lp_dag.cpp\"\n-\n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(V, 0);\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-\n-        for(auto )\n-          cout << \"i: \" << i << \", dp: \" << dp[i] << \"\\n\"; \n-\n-        int place = vertices.back();   \n-        return {dp[place], place};\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-        int V;\n-        int c = 0;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V);\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            auto ans = longestPath(start, V, graph);\n-            // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.second;\n-            int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727434954373,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n                   break;\n                 --from; --to;\n                 graph[from].push_back(to);\n             }\n-            auto ans = longestPath(start, V, graph);\n+            auto ans = longestPath(--start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n             int place = ans.second;\n             int length = ans.first;\n             printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n"
                },
                {
                    "date": 1727434979330,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,12 +20,8 @@\n         table dp(V, 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-\n-        for(auto v : vertices) cout << v << \" \";\n-        cout << \"\\n\";\n-\n         int place = vertices.back();   \n         return {dp[place], place};\n     }\n \n"
                },
                {
                    "date": 1727434984751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(V, 0);\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        int place = vertices.back();\n+        return {dp[place], place};\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V);\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(--start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727435022432,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,65 +50,8 @@\n             auto ans = longestPath(--start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n             int place = ans.second;\n             int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start++, length, ++place);\n         }\n     }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <cstdio>\n-#include \"../lp_dag.cpp\"\n-\n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(V, 0);\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-        int place = vertices.back();   \n-        return {dp[place], place};\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-        int V;\n-        int c = 0;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V);\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            auto ans = longestPath(--start, V, graph);\n-            // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.second;\n-            int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start, length, ++place);\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727435089256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,8 +50,8 @@\n             auto ans = longestPath(--start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n             int place = ans.second;\n             int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\", ++c, start++, length, ++place);\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\\n\", ++c, ++start, length, ++place);\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727435107488,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,9 @@\n         table dp(V, 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n+            \n         int place = vertices.back();\n         return {dp[place], place};\n     }\n \n"
                },
                {
                    "date": 1727435117043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,60 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(V, 0);\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        /** For each test case you have to find the length of the longest path that begins at the starting place.\n+         *  You also have to print the number of the final place of such longest path. If there are several paths of\n+maximum length, print the final place with smallest number */    \n+        int place = vertices.back();\n+        return {dp[place], place};\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V);\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(--start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\\n\", ++c, ++start, length, ++place);\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727435122183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         /** For each test case you have to find the length of the longest path that begins at the starting place.\n          *  You also have to print the number of the final place of such longest path. If there are several paths of\n-maximum length, print the final place with smallest number */    \n+         *  maximum length, print the final place with smallest number */    \n         int place = vertices.back();\n         return {dp[place], place};\n     }\n \n@@ -56,63 +56,5 @@\n             int length = ans.first;\n             printf(\"Case %d: The longest path from %d has length %d, finishing at %d\\n\", ++c, ++start, length, ++place);\n         }\n     }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <cstdio>\n-#include \"../lp_dag.cpp\"\n-\n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(V, 0);\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n-            \n-        int place = vertices.back();\n-        return {dp[place], place};\n-    }\n-\n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-        int V;\n-        int c = 0;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V);\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            auto ans = longestPath(--start, V, graph);\n-            // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.second;\n-            int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\\n\", ++c, ++start, length, ++place);\n-        }\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727435132717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,10 +20,9 @@\n         table dp(V, 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        /** For each test case you have to find the length of the longest path that begins at the starting place.\n-         *  You also have to print the number of the final place of such longest path. If there are several paths of\n+        /** if there are several paths of\n          *  maximum length, print the final place with smallest number */    \n         int place = vertices.back();\n         return {dp[place], place};\n     }\n"
                },
                {
                    "date": 1727435139028,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,10 +20,9 @@\n         table dp(V, 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        /** if there are several paths of\n-         *  maximum length, print the final place with smallest number */    \n+        /** if there are several paths of maximum length, print the final place with smallest number */ \n         int place = vertices.back();\n         return {dp[place], place};\n     }\n \n"
                },
                {
                    "date": 1727435255590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,8 +51,8 @@\n             auto ans = longestPath(--start, V, graph);\n             // Case 1: The longest path from 1 has length 1, finishing at 2\n             int place = ans.second;\n             int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\\n\", ++c, ++start, length, ++place);\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\\n\\n\", ++c, ++start, length, ++place);\n         }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727435416848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,58 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(V, 0);\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        /** if there are several paths of maximum length, print the final place with smallest number */ \n+        int place = vertices.back();\n+        return {dp[place], place};\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V);\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(--start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\\n\\n\", ++c, ++start, length, ++place);\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727435423654,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,66 +20,11 @@\n         table dp(V, 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        /** if there are several paths of maximum length, print the final place with smallest number */ \n-        int place = vertices.back();\n-        return {dp[place], place};\n-    }\n \n-    void submit(std::optional<char*> file)\n-    {\n-        if(file.has_value())\n-          assert(freopen(file.value(), \"r\", stdin) != NULL);\n-        int V;\n-        int c = 0;\n-        while(true)\n-        {\n-            std::cin >> V;\n-            if(V == 0) break;\n-            int start;\n-            std::cin >> start;\n-            int from, to;\n-            lp::adj graph(V);\n-            while(true)\n-            {\n-                std::cin >> from >> to;\n-                if(from == 0 && to == 0)\n-                  break;\n-                --from; --to;\n-                graph[from].push_back(to);\n-            }\n-            auto ans = longestPath(--start, V, graph);\n-            // Case 1: The longest path from 1 has length 1, finishing at 2\n-            int place = ans.second;\n-            int length = ans.first;\n-            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\\n\\n\", ++c, ++start, length, ++place);\n-        }\n-    }\n-}\n-#include <vector>\n-#include <optional>\n-#include <iostream>\n-#include <cassert>\n-#include <cstdio>\n-#include \"../lp_dag.cpp\"\n+        for(0)\n \n-\n-namespace algorithms::graph::onlinejudge::césar\n-{\n-\n-typedef std::vector<int> table;\n-namespace lp = algorithms::graph::lp_dag;\n-\n-     /** https://onlinejudge.org/external/100/10000.pdf */\n-    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n-    {\n-        auto s = std::make_optional(start);\n-        lp::vs vertices = lp::topological_sort(V, s, graph);\n-        table dp(V, 0);\n-        for(auto v : vertices)\n-          for(auto u : graph[v])\n-            dp[u] = std::max(dp[u], 1 + dp[v]);\n         /** if there are several paths of maximum length, print the final place with smallest number */ \n         int place = vertices.back();\n         return {dp[place], place};\n     }\n"
                },
                {
                    "date": 1727435440513,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,10 @@\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n \n-        for(0)\n+        for(int i = 0; i < V; i++)\n+          cout << \"i: \" << i << \", \"\n \n         /** if there are several paths of maximum length, print the final place with smallest number */ \n         int place = vertices.back();\n         return {dp[place], place};\n"
                },
                {
                    "date": 1727435451390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n \n         for(int i = 0; i < V; i++)\n-          cout << \"i: \" << i << \", \"\n+          cout << \"i: \" << i << \", dp: \" << dp[i] << \"\\n\";\n \n         /** if there are several paths of maximum length, print the final place with smallest number */ \n         int place = vertices.back();\n         return {dp[place], place};\n"
                },
                {
                    "date": 1727435525115,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,12 +20,8 @@\n         table dp(V, 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-\n-        for(int i = 0; i < V; i++)\n-          cout << \"i: \" << i << \", dp: \" << dp[i] << \"\\n\";\n-\n         /** if there are several paths of maximum length, print the final place with smallest number */ \n         int place = vertices.back();\n         return {dp[place], place};\n     }\n"
                },
                {
                    "date": 1727435540307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n         table dp(V, 0);\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n-        /** if there are several paths of maximum length, print the final place with smallest number */ \n+        /** if there are several paths of maximum length, print the final place with smallest number */\n         int place = vertices.back();\n         return {dp[place], place};\n     }\n \n"
                },
                {
                    "date": 1727435551118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,8 +22,9 @@\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         /** if there are several paths of maximum length, print the final place with smallest number */\n         int place = vertices.back();\n+        i\n         return {dp[place], place};\n     }\n \n     void submit(std::optional<char*> file)\n"
                },
                {
                    "date": 1727435566163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,10 +21,9 @@\n         for(auto v : vertices)\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         /** if there are several paths of maximum length, print the final place with smallest number */\n-        int place = vertices.back();\n-        i\n+        int last = vertices.back();\n         return {dp[place], place};\n     }\n \n     void submit(std::optional<char*> file)\n"
                },
                {
                    "date": 1727435572627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,8 +22,9 @@\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         /** if there are several paths of maximum length, print the final place with smallest number */\n         int last = vertices.back();\n+        int max\n         return {dp[place], place};\n     }\n \n     void submit(std::optional<char*> file)\n"
                },
                {
                    "date": 1727435580956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n           for(auto u : graph[v])\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         /** if there are several paths of maximum length, print the final place with smallest number */\n         int last = vertices.back();\n-        int max\n+        int path = dp[place]; \n         return {dp[place], place};\n     }\n \n     void submit(std::optional<char*> file)\n"
                },
                {
                    "date": 1727435586420,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,10 +23,10 @@\n             dp[u] = std::max(dp[u], 1 + dp[v]);\n         /** if there are several paths of maximum length, print the final place with smallest number */\n         int last = vertices.back();\n         int path = dp[place];\n-        \n-         \n+        while()\n+\n         return {dp[place], place};\n     }\n \n     void submit(std::optional<char*> file)\n"
                },
                {
                    "date": 1727435600574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,62 @@\n+#include <vector>\n+#include <optional>\n+#include <iostream>\n+#include <cassert>\n+#include <cstdio>\n+#include \"../lp_dag.cpp\"\n+\n+\n+namespace algorithms::graph::onlinejudge::césar\n+{\n+\n+typedef std::vector<int> table;\n+namespace lp = algorithms::graph::lp_dag;\n+\n+     /** https://onlinejudge.org/external/100/10000.pdf */\n+    std::pair<int, int> longestPath(int start, int V, const lp::adj& graph)\n+    {\n+        auto s = std::make_optional(start);\n+        lp::vs vertices = lp::topological_sort(V, s, graph);\n+        table dp(V, 0);\n+        for(auto v : vertices)\n+          for(auto u : graph[v])\n+            dp[u] = std::max(dp[u], 1 + dp[v]);\n+        /** if there are several paths of maximum length, print the final place with smallest number */\n+        int last = vertices.back();\n+        int path = dp[place];\n+        int \n+        while()\n+\n+        return {dp[place], place};\n+    }\n+\n+    void submit(std::optional<char*> file)\n+    {\n+        if(file.has_value())\n+          assert(freopen(file.value(), \"r\", stdin) != NULL);\n+        int V;\n+        int c = 0;\n+        while(true)\n+        {\n+            std::cin >> V;\n+            if(V == 0) break;\n+            int start;\n+            std::cin >> start;\n+            int from, to;\n+            lp::adj graph(V);\n+            while(true)\n+            {\n+                std::cin >> from >> to;\n+                if(from == 0 && to == 0)\n+                  break;\n+                --from; --to;\n+                graph[from].push_back(to);\n+            }\n+            auto ans = longestPath(--start, V, graph);\n+            // Case 1: The longest path from 1 has length 1, finishing at 2\n+            int place = ans.second;\n+            int length = ans.first;\n+            printf(\"Case %d: The longest path from %d has length %d, finishing at %d\\n\\n\", ++c, ++start, length, ++place);\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1727432247083,
            "name": "Commit-0",
            "content": "\n\nnamesp"
        }
    ]
}