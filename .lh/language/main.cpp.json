{
    "sourceFile": "language/main.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1714752763019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1714752768377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -177,9 +177,9 @@\n \n // given a set S of n integers and another integer v\n // determines whether S contains two elements that sum to exactly v\n // time complexity should be logarithmic -> n * lgn\n-std:: std::tuple<size_t, size_t> sumOfTwoNumbers(const std::vector<int>& array, int target)\n+std::optionalstd::tuple<size_t, size_t> sumOfTwoNumbers(const std::vector<int>& array, int target)\n {\n     std::unordered_map<int, int> map;\n     for (int i = 0; i < array.size(); ++i) {\n         int complement = target - array[i];\n"
                },
                {
                    "date": 1714752788564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -177,9 +177,9 @@\n \n // given a set S of n integers and another integer v\n // determines whether S contains two elements that sum to exactly v\n // time complexity should be logarithmic -> n * lgn\n-std::optionalstd::tuple<size_t, size_t> sumOfTwoNumbers(const std::vector<int>& array, int target)\n+std::optional<std::tuple<size_t, size_t>> sumOfTwoNumbers(const std::vector<int>& array, int target)\n {\n     std::unordered_map<int, int> map;\n     for (int i = 0; i < array.size(); ++i) {\n         int complement = target - array[i];\n@@ -187,9 +187,9 @@\n             return {map[complement], i};\n         }\n         map[array[i]] = i;\n     }\n-    return {};\n+    return std::nullopt;\n }\n \n \n int main()\n"
                },
                {
                    "date": 1714752800942,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -207,7 +207,7 @@\n     std::vector<int> array_2 = {1, 2, 4, 5, 7, 9};\n     std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n \n     std::vector<int> twoSum_array = {3, 3};\n-    auto tpl = sumOfTwoNumbers(twoSum_array, 6);\n+    auto opt = sumOfTwoNumbers(twoSum_array, 6);\n     std::cout << std::get<1>(tpl);\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1714752808187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,6 +208,6 @@\n     std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n \n     std::vector<int> twoSum_array = {3, 3};\n     auto opt = sumOfTwoNumbers(twoSum_array, 6);\n-    std::cout << std::get<1>(tpl);\n+    std::cout << opt. std::get<1>(tpl);\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1714752819539,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,6 +208,6 @@\n     std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n \n     std::vector<int> twoSum_array = {3, 3};\n     auto opt = sumOfTwoNumbers(twoSum_array, 6);\n-    std::cout << opt. std::get<1>(tpl);\n+    std::cout << opt.has_value std::get<1>(tpl);\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1714752834186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,213 @@\n+#include <iostream>\n+#include <iterator>\n+#include <algorithm>\n+#include <vector>\n+#include <optional>\n+#include <cmath>\n+#include <tuple>\n+#include <unordered_map>\n+\n+using namespace std;\n+\n+\n+// function selectionSort(arr):\n+//     n = length of arr  // Length of the array\n+    \n+//     for i from 0 to n - 2:  // Outer loop from the first element to the second-to-last\n+//         minIndex = i  // Assume the first element of the unsorted section is the minimum\n+        \n+//         // Find the smallest element in the unsorted section\n+//         for j from i + 1 to n - 1:\n+//             if arr[j] < arr[minIndex]:  // Find a smaller element\n+//                 minIndex = j  // Update the index of the smallest element\n+                \n+//         // Swap the smallest element with the first element of the unsorted section\n+//         if minIndex != i:  // Only swap if the smallest element is not already in place\n+//             swap(arr[i], arr[minIndex])\n+\n+void selection(std::vector<int>& array) {\n+    size_t length = array.size();\n+    for (size_t i = 0; i < length - 1; i++)\n+    {\n+        size_t minIndex = i;\n+        for (size_t j = i + 1; j < length; j++)\n+        {\n+            if (array[j] < array[minIndex])\n+            {\n+                minIndex = j;\n+            }\n+            \n+        }\n+        if(minIndex != i)\n+        {\n+            std::swap(array[i], array[minIndex]);\n+        }\n+    }\n+}\n+\n+void merge_sort(std::vector<int>& array, size_t l, size_t r) \n+{\n+\n+    auto merge = [](std::vector<int>& array, size_t l, size_t m, size_t r) \n+    {\n+        size_t left_length = m - l + 1;\n+        size_t right_length = r - m;\n+        int left_tmp[left_length];\n+        int right_tmp[right_length];\n+\n+        for (size_t i = 0; i < left_length; i++)\n+        {\n+            left_tmp[i] = array[l + i];\n+        }\n+        \n+        for (size_t j = 0; j < right_length; j++)\n+        {\n+            right_tmp[j] = array[m + 1 + j];\n+        }\n+\n+        size_t i = 0; // left array\n+        size_t j = 0; // right array\n+        size_t k = l;\n+\n+        while(i < left_length && j < right_length)\n+        {\n+            if(left_tmp[i] <= right_tmp[j])\n+            {\n+                array[k] = left_tmp[i];\n+                i++;\n+\n+            }\n+            else {\n+                array[k] = right_tmp[j];\n+                j++;\n+            }\n+            k++;\n+        }\n+\n+        while(i < left_length) \n+        {\n+            array[k] = left_tmp[i];\n+            i++;\n+            k++;   \n+        }\n+\n+        while(j < right_length) \n+        {\n+            array[k] = right_tmp[j];\n+            j++;\n+            k++;   \n+        }\n+    };\n+\n+    if(l >= r) \n+    {\n+        return;\n+    } else \n+    {\n+        size_t q = (int)floor((l + r) / 2); // divide step\n+        merge_sort(array, l, q); // sub-problem of size n/2\n+        merge_sort(array, q + 1, r); // sub-problem of size n/2\n+        merge(array, l, q, r); // combine step\n+    }\n+}\n+\n+\n+void recursive_insertion_sort(std::vector<int>& array, size_t n) \n+{\n+    if(n == 0)\n+    {\n+        return;\n+    }\n+    else\n+    {\n+        recursive_insertion_sort(array, n - 1); // recursive call\n+        size_t k = n - 1;\n+        while(k > 0)\n+        {\n+            if(array[k - 1] > array[k])\n+            {\n+                std::swap(array[k - 1], array[k]);\n+                k--;\n+            }\n+            else \n+            {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+\n+bool palindrome_number(int n)\n+{\n+    auto reverseNumber = [](int n) \n+    {\n+        int reversed = 0;\n+        while (n > 0) \n+        {\n+          int digit = n % 10;  // Extract the last digit\n+          reversed = reversed * 10 + digit;  // Add the digit to the reversed number\n+          n /= 10;  // Remove the last digit\n+        }\n+        return reversed;\n+    };\n+    if (n < 0) {\n+        return false;  // Negative numbers are not palindromes due to the negative sign\n+    }\n+\n+    int reversed = reverseNumber(n);\n+    return reversed == n;\n+}\n+\n+int binary_search(std::vector<int> array, size_t l, size_t r, int v)\n+{\n+    if(l >= r)\n+      return -1;\n+    else \n+    {\n+        size_t m = floor((l + r) / 2);\n+        if(array[m] == v)\n+          return m;\n+        else if(array[m] > v)\n+          return binary_search(array, l, m, v); // T(n/2)\n+        else\n+          return binary_search(array, m + 1, r, v); // T(n/2)\n+    }\n+}\n+\n+// given a set S of n integers and another integer v\n+// determines whether S contains two elements that sum to exactly v\n+// time complexity should be logarithmic -> n * lgn\n+std::optional<std::tuple<size_t, size_t>> sumOfTwoNumbers(const std::vector<int>& array, int target)\n+{\n+    std::unordered_map<int, int> map;\n+    for (int i = 0; i < array.size(); ++i) {\n+        int complement = target - array[i];\n+        if (map.find(complement) != map.end()) {\n+            return {map[complement], i};\n+        }\n+        map[array[i]] = i;\n+    }\n+    return std::nullopt;\n+}\n+\n+\n+int main()\n+{\n+    std::vector<int> array_1 = {78, 34, 67, 1111, 7, 6, -9, 11};\n+\n+    // selection(array_1);\n+    recursive_insertion_sort(array_1, array_1.size());\n+\n+    for (int i = 0; i < array_1.size(); i++) {  // Iterate through the array\n+        std::cout << array_1[i] << \" \";  // Print each element\n+    }\n+    std::cout << std::endl;  // End the line\n+\n+    std::vector<int> array_2 = {1, 2, 4, 5, 7, 9};\n+    std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n+\n+    std::vector<int> twoSum_array = {3, 3};\n+    auto opt = sumOfTwoNumbers(twoSum_array, 6);\n+    std::cout << opt.has_value std::get<1>(tpl);\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1714752842080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,213 @@\n+#include <iostream>\n+#include <iterator>\n+#include <algorithm>\n+#include <vector>\n+#include <optional>\n+#include <cmath>\n+#include <tuple>\n+#include <unordered_map>\n+\n+using namespace std;\n+\n+\n+// function selectionSort(arr):\n+//     n = length of arr  // Length of the array\n+    \n+//     for i from 0 to n - 2:  // Outer loop from the first element to the second-to-last\n+//         minIndex = i  // Assume the first element of the unsorted section is the minimum\n+        \n+//         // Find the smallest element in the unsorted section\n+//         for j from i + 1 to n - 1:\n+//             if arr[j] < arr[minIndex]:  // Find a smaller element\n+//                 minIndex = j  // Update the index of the smallest element\n+                \n+//         // Swap the smallest element with the first element of the unsorted section\n+//         if minIndex != i:  // Only swap if the smallest element is not already in place\n+//             swap(arr[i], arr[minIndex])\n+\n+void selection(std::vector<int>& array) {\n+    size_t length = array.size();\n+    for (size_t i = 0; i < length - 1; i++)\n+    {\n+        size_t minIndex = i;\n+        for (size_t j = i + 1; j < length; j++)\n+        {\n+            if (array[j] < array[minIndex])\n+            {\n+                minIndex = j;\n+            }\n+            \n+        }\n+        if(minIndex != i)\n+        {\n+            std::swap(array[i], array[minIndex]);\n+        }\n+    }\n+}\n+\n+void merge_sort(std::vector<int>& array, size_t l, size_t r) \n+{\n+\n+    auto merge = [](std::vector<int>& array, size_t l, size_t m, size_t r) \n+    {\n+        size_t left_length = m - l + 1;\n+        size_t right_length = r - m;\n+        int left_tmp[left_length];\n+        int right_tmp[right_length];\n+\n+        for (size_t i = 0; i < left_length; i++)\n+        {\n+            left_tmp[i] = array[l + i];\n+        }\n+        \n+        for (size_t j = 0; j < right_length; j++)\n+        {\n+            right_tmp[j] = array[m + 1 + j];\n+        }\n+\n+        size_t i = 0; // left array\n+        size_t j = 0; // right array\n+        size_t k = l;\n+\n+        while(i < left_length && j < right_length)\n+        {\n+            if(left_tmp[i] <= right_tmp[j])\n+            {\n+                array[k] = left_tmp[i];\n+                i++;\n+\n+            }\n+            else {\n+                array[k] = right_tmp[j];\n+                j++;\n+            }\n+            k++;\n+        }\n+\n+        while(i < left_length) \n+        {\n+            array[k] = left_tmp[i];\n+            i++;\n+            k++;   \n+        }\n+\n+        while(j < right_length) \n+        {\n+            array[k] = right_tmp[j];\n+            j++;\n+            k++;   \n+        }\n+    };\n+\n+    if(l >= r) \n+    {\n+        return;\n+    } else \n+    {\n+        size_t q = (int)floor((l + r) / 2); // divide step\n+        merge_sort(array, l, q); // sub-problem of size n/2\n+        merge_sort(array, q + 1, r); // sub-problem of size n/2\n+        merge(array, l, q, r); // combine step\n+    }\n+}\n+\n+\n+void recursive_insertion_sort(std::vector<int>& array, size_t n) \n+{\n+    if(n == 0)\n+    {\n+        return;\n+    }\n+    else\n+    {\n+        recursive_insertion_sort(array, n - 1); // recursive call\n+        size_t k = n - 1;\n+        while(k > 0)\n+        {\n+            if(array[k - 1] > array[k])\n+            {\n+                std::swap(array[k - 1], array[k]);\n+                k--;\n+            }\n+            else \n+            {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+\n+bool palindrome_number(int n)\n+{\n+    auto reverseNumber = [](int n) \n+    {\n+        int reversed = 0;\n+        while (n > 0) \n+        {\n+          int digit = n % 10;  // Extract the last digit\n+          reversed = reversed * 10 + digit;  // Add the digit to the reversed number\n+          n /= 10;  // Remove the last digit\n+        }\n+        return reversed;\n+    };\n+    if (n < 0) {\n+        return false;  // Negative numbers are not palindromes due to the negative sign\n+    }\n+\n+    int reversed = reverseNumber(n);\n+    return reversed == n;\n+}\n+\n+int binary_search(std::vector<int> array, size_t l, size_t r, int v)\n+{\n+    if(l >= r)\n+      return -1;\n+    else \n+    {\n+        size_t m = floor((l + r) / 2);\n+        if(array[m] == v)\n+          return m;\n+        else if(array[m] > v)\n+          return binary_search(array, l, m, v); // T(n/2)\n+        else\n+          return binary_search(array, m + 1, r, v); // T(n/2)\n+    }\n+}\n+\n+// given a set S of n integers and another integer v\n+// determines whether S contains two elements that sum to exactly v\n+// time complexity should be logarithmic -> n * lgn\n+std::optional<std::tuple<size_t, size_t>> sumOfTwoNumbers(const std::vector<int>& array, int target)\n+{\n+    std::unordered_map<int, int> map;\n+    for (int i = 0; i < array.size(); ++i) {\n+        int complement = target - array[i];\n+        if (map.find(complement) != map.end()) {\n+            return {map[complement], i};\n+        }\n+        map[array[i]] = i;\n+    }\n+    return std::nullopt;\n+}\n+\n+\n+int main()\n+{\n+    std::vector<int> array_1 = {78, 34, 67, 1111, 7, 6, -9, 11};\n+\n+    // selection(array_1);\n+    recursive_insertion_sort(array_1, array_1.size());\n+\n+    for (int i = 0; i < array_1.size(); i++) {  // Iterate through the array\n+        std::cout << array_1[i] << \" \";  // Print each element\n+    }\n+    std::cout << std::endl;  // End the line\n+\n+    std::vector<int> array_2 = {1, 2, 4, 5, 7, 9};\n+    std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n+\n+    std::vector<int> twoSum_array = {3, 3};\n+    auto opt = sumOfTwoNumbers(twoSum_array, 6);\n+    std::cout << opt.has_value ? std::get<1>(tpl) : ;\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1714752847117,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,432 +208,6 @@\n     std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n \n     std::vector<int> twoSum_array = {3, 3};\n     auto opt = sumOfTwoNumbers(twoSum_array, 6);\n-    std::cout << opt.has_value ? std::get<1>(tpl) : ;\n-}\n-#include <iostream>\n-#include <iterator>\n-#include <algorithm>\n-#include <vector>\n-#include <optional>\n-#include <cmath>\n-#include <tuple>\n-#include <unordered_map>\n-\n-using namespace std;\n-\n-\n-// function selectionSort(arr):\n-//     n = length of arr  // Length of the array\n-    \n-//     for i from 0 to n - 2:  // Outer loop from the first element to the second-to-last\n-//         minIndex = i  // Assume the first element of the unsorted section is the minimum\n-        \n-//         // Find the smallest element in the unsorted section\n-//         for j from i + 1 to n - 1:\n-//             if arr[j] < arr[minIndex]:  // Find a smaller element\n-//                 minIndex = j  // Update the index of the smallest element\n-                \n-//         // Swap the smallest element with the first element of the unsorted section\n-//         if minIndex != i:  // Only swap if the smallest element is not already in place\n-//             swap(arr[i], arr[minIndex])\n-\n-void selection(std::vector<int>& array) {\n-    size_t length = array.size();\n-    for (size_t i = 0; i < length - 1; i++)\n-    {\n-        size_t minIndex = i;\n-        for (size_t j = i + 1; j < length; j++)\n-        {\n-            if (array[j] < array[minIndex])\n-            {\n-                minIndex = j;\n-            }\n-            \n-        }\n-        if(minIndex != i)\n-        {\n-            std::swap(array[i], array[minIndex]);\n-        }\n-    }\n-}\n-\n-void merge_sort(std::vector<int>& array, size_t l, size_t r) \n-{\n-\n-    auto merge = [](std::vector<int>& array, size_t l, size_t m, size_t r) \n-    {\n-        size_t left_length = m - l + 1;\n-        size_t right_length = r - m;\n-        int left_tmp[left_length];\n-        int right_tmp[right_length];\n-\n-        for (size_t i = 0; i < left_length; i++)\n-        {\n-            left_tmp[i] = array[l + i];\n-        }\n-        \n-        for (size_t j = 0; j < right_length; j++)\n-        {\n-            right_tmp[j] = array[m + 1 + j];\n-        }\n-\n-        size_t i = 0; // left array\n-        size_t j = 0; // right array\n-        size_t k = l;\n-\n-        while(i < left_length && j < right_length)\n-        {\n-            if(left_tmp[i] <= right_tmp[j])\n-            {\n-                array[k] = left_tmp[i];\n-                i++;\n-\n-            }\n-            else {\n-                array[k] = right_tmp[j];\n-                j++;\n-            }\n-            k++;\n-        }\n-\n-        while(i < left_length) \n-        {\n-            array[k] = left_tmp[i];\n-            i++;\n-            k++;   \n-        }\n-\n-        while(j < right_length) \n-        {\n-            array[k] = right_tmp[j];\n-            j++;\n-            k++;   \n-        }\n-    };\n-\n-    if(l >= r) \n-    {\n-        return;\n-    } else \n-    {\n-        size_t q = (int)floor((l + r) / 2); // divide step\n-        merge_sort(array, l, q); // sub-problem of size n/2\n-        merge_sort(array, q + 1, r); // sub-problem of size n/2\n-        merge(array, l, q, r); // combine step\n-    }\n-}\n-\n-\n-void recursive_insertion_sort(std::vector<int>& array, size_t n) \n-{\n-    if(n == 0)\n-    {\n-        return;\n-    }\n-    else\n-    {\n-        recursive_insertion_sort(array, n - 1); // recursive call\n-        size_t k = n - 1;\n-        while(k > 0)\n-        {\n-            if(array[k - 1] > array[k])\n-            {\n-                std::swap(array[k - 1], array[k]);\n-                k--;\n-            }\n-            else \n-            {\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-\n-bool palindrome_number(int n)\n-{\n-    auto reverseNumber = [](int n) \n-    {\n-        int reversed = 0;\n-        while (n > 0) \n-        {\n-          int digit = n % 10;  // Extract the last digit\n-          reversed = reversed * 10 + digit;  // Add the digit to the reversed number\n-          n /= 10;  // Remove the last digit\n-        }\n-        return reversed;\n-    };\n-    if (n < 0) {\n-        return false;  // Negative numbers are not palindromes due to the negative sign\n-    }\n-\n-    int reversed = reverseNumber(n);\n-    return reversed == n;\n-}\n-\n-int binary_search(std::vector<int> array, size_t l, size_t r, int v)\n-{\n-    if(l >= r)\n-      return -1;\n-    else \n-    {\n-        size_t m = floor((l + r) / 2);\n-        if(array[m] == v)\n-          return m;\n-        else if(array[m] > v)\n-          return binary_search(array, l, m, v); // T(n/2)\n-        else\n-          return binary_search(array, m + 1, r, v); // T(n/2)\n-    }\n-}\n-\n-// given a set S of n integers and another integer v\n-// determines whether S contains two elements that sum to exactly v\n-// time complexity should be logarithmic -> n * lgn\n-std::optional<std::tuple<size_t, size_t>> sumOfTwoNumbers(const std::vector<int>& array, int target)\n-{\n-    std::unordered_map<int, int> map;\n-    for (int i = 0; i < array.size(); ++i) {\n-        int complement = target - array[i];\n-        if (map.find(complement) != map.end()) {\n-            return {map[complement], i};\n-        }\n-        map[array[i]] = i;\n-    }\n-    return std::nullopt;\n-}\n-\n-\n-int main()\n-{\n-    std::vector<int> array_1 = {78, 34, 67, 1111, 7, 6, -9, 11};\n-\n-    // selection(array_1);\n-    recursive_insertion_sort(array_1, array_1.size());\n-\n-    for (int i = 0; i < array_1.size(); i++) {  // Iterate through the array\n-        std::cout << array_1[i] << \" \";  // Print each element\n-    }\n-    std::cout << std::endl;  // End the line\n-\n-    std::vector<int> array_2 = {1, 2, 4, 5, 7, 9};\n-    std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n-\n-    std::vector<int> twoSum_array = {3, 3};\n-    auto opt = sumOfTwoNumbers(twoSum_array, 6);\n-    std::cout << opt.has_value std::get<1>(tpl);\n-}\n-#include <iostream>\n-#include <iterator>\n-#include <algorithm>\n-#include <vector>\n-#include <optional>\n-#include <cmath>\n-#include <tuple>\n-#include <unordered_map>\n-\n-using namespace std;\n-\n-\n-// function selectionSort(arr):\n-//     n = length of arr  // Length of the array\n-    \n-//     for i from 0 to n - 2:  // Outer loop from the first element to the second-to-last\n-//         minIndex = i  // Assume the first element of the unsorted section is the minimum\n-        \n-//         // Find the smallest element in the unsorted section\n-//         for j from i + 1 to n - 1:\n-//             if arr[j] < arr[minIndex]:  // Find a smaller element\n-//                 minIndex = j  // Update the index of the smallest element\n-                \n-//         // Swap the smallest element with the first element of the unsorted section\n-//         if minIndex != i:  // Only swap if the smallest element is not already in place\n-//             swap(arr[i], arr[minIndex])\n-\n-void selection(std::vector<int>& array) {\n-    size_t length = array.size();\n-    for (size_t i = 0; i < length - 1; i++)\n-    {\n-        size_t minIndex = i;\n-        for (size_t j = i + 1; j < length; j++)\n-        {\n-            if (array[j] < array[minIndex])\n-            {\n-                minIndex = j;\n-            }\n-            \n-        }\n-        if(minIndex != i)\n-        {\n-            std::swap(array[i], array[minIndex]);\n-        }\n-    }\n-}\n-\n-void merge_sort(std::vector<int>& array, size_t l, size_t r) \n-{\n-\n-    auto merge = [](std::vector<int>& array, size_t l, size_t m, size_t r) \n-    {\n-        size_t left_length = m - l + 1;\n-        size_t right_length = r - m;\n-        int left_tmp[left_length];\n-        int right_tmp[right_length];\n-\n-        for (size_t i = 0; i < left_length; i++)\n-        {\n-            left_tmp[i] = array[l + i];\n-        }\n-        \n-        for (size_t j = 0; j < right_length; j++)\n-        {\n-            right_tmp[j] = array[m + 1 + j];\n-        }\n-\n-        size_t i = 0; // left array\n-        size_t j = 0; // right array\n-        size_t k = l;\n-\n-        while(i < left_length && j < right_length)\n-        {\n-            if(left_tmp[i] <= right_tmp[j])\n-            {\n-                array[k] = left_tmp[i];\n-                i++;\n-\n-            }\n-            else {\n-                array[k] = right_tmp[j];\n-                j++;\n-            }\n-            k++;\n-        }\n-\n-        while(i < left_length) \n-        {\n-            array[k] = left_tmp[i];\n-            i++;\n-            k++;   \n-        }\n-\n-        while(j < right_length) \n-        {\n-            array[k] = right_tmp[j];\n-            j++;\n-            k++;   \n-        }\n-    };\n-\n-    if(l >= r) \n-    {\n-        return;\n-    } else \n-    {\n-        size_t q = (int)floor((l + r) / 2); // divide step\n-        merge_sort(array, l, q); // sub-problem of size n/2\n-        merge_sort(array, q + 1, r); // sub-problem of size n/2\n-        merge(array, l, q, r); // combine step\n-    }\n-}\n-\n-\n-void recursive_insertion_sort(std::vector<int>& array, size_t n) \n-{\n-    if(n == 0)\n-    {\n-        return;\n-    }\n-    else\n-    {\n-        recursive_insertion_sort(array, n - 1); // recursive call\n-        size_t k = n - 1;\n-        while(k > 0)\n-        {\n-            if(array[k - 1] > array[k])\n-            {\n-                std::swap(array[k - 1], array[k]);\n-                k--;\n-            }\n-            else \n-            {\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-\n-bool palindrome_number(int n)\n-{\n-    auto reverseNumber = [](int n) \n-    {\n-        int reversed = 0;\n-        while (n > 0) \n-        {\n-          int digit = n % 10;  // Extract the last digit\n-          reversed = reversed * 10 + digit;  // Add the digit to the reversed number\n-          n /= 10;  // Remove the last digit\n-        }\n-        return reversed;\n-    };\n-    if (n < 0) {\n-        return false;  // Negative numbers are not palindromes due to the negative sign\n-    }\n-\n-    int reversed = reverseNumber(n);\n-    return reversed == n;\n-}\n-\n-int binary_search(std::vector<int> array, size_t l, size_t r, int v)\n-{\n-    if(l >= r)\n-      return -1;\n-    else \n-    {\n-        size_t m = floor((l + r) / 2);\n-        if(array[m] == v)\n-          return m;\n-        else if(array[m] > v)\n-          return binary_search(array, l, m, v); // T(n/2)\n-        else\n-          return binary_search(array, m + 1, r, v); // T(n/2)\n-    }\n-}\n-\n-// given a set S of n integers and another integer v\n-// determines whether S contains two elements that sum to exactly v\n-// time complexity should be logarithmic -> n * lgn\n-std::optional<std::tuple<size_t, size_t>> sumOfTwoNumbers(const std::vector<int>& array, int target)\n-{\n-    std::unordered_map<int, int> map;\n-    for (int i = 0; i < array.size(); ++i) {\n-        int complement = target - array[i];\n-        if (map.find(complement) != map.end()) {\n-            return {map[complement], i};\n-        }\n-        map[array[i]] = i;\n-    }\n-    return std::nullopt;\n-}\n-\n-\n-int main()\n-{\n-    std::vector<int> array_1 = {78, 34, 67, 1111, 7, 6, -9, 11};\n-\n-    // selection(array_1);\n-    recursive_insertion_sort(array_1, array_1.size());\n-\n-    for (int i = 0; i < array_1.size(); i++) {  // Iterate through the array\n-        std::cout << array_1[i] << \" \";  // Print each element\n-    }\n-    std::cout << std::endl;  // End the line\n-\n-    std::vector<int> array_2 = {1, 2, 4, 5, 7, 9};\n-    std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n-\n-    std::vector<int> twoSum_array = {3, 3};\n-    auto opt = sumOfTwoNumbers(twoSum_array, 6);\n-    std::cout << opt.has_value std::get<1>(tpl);\n+    std::cout << opt.has_value ? std::get<1>(tpl) : \"\";\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1714752855917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,6 +208,6 @@\n     std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n \n     std::vector<int> twoSum_array = {3, 3};\n     auto opt = sumOfTwoNumbers(twoSum_array, 6);\n-    std::cout << opt.has_value ? std::get<1>(tpl) : \"null\";\n+    std::cout << (opt.has_value ? std::get<1>(tpl) : \"null\";\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1714752868027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,213 @@\n+#include <iostream>\n+#include <iterator>\n+#include <algorithm>\n+#include <vector>\n+#include <optional>\n+#include <cmath>\n+#include <tuple>\n+#include <unordered_map>\n+\n+using namespace std;\n+\n+\n+// function selectionSort(arr):\n+//     n = length of arr  // Length of the array\n+    \n+//     for i from 0 to n - 2:  // Outer loop from the first element to the second-to-last\n+//         minIndex = i  // Assume the first element of the unsorted section is the minimum\n+        \n+//         // Find the smallest element in the unsorted section\n+//         for j from i + 1 to n - 1:\n+//             if arr[j] < arr[minIndex]:  // Find a smaller element\n+//                 minIndex = j  // Update the index of the smallest element\n+                \n+//         // Swap the smallest element with the first element of the unsorted section\n+//         if minIndex != i:  // Only swap if the smallest element is not already in place\n+//             swap(arr[i], arr[minIndex])\n+\n+void selection(std::vector<int>& array) {\n+    size_t length = array.size();\n+    for (size_t i = 0; i < length - 1; i++)\n+    {\n+        size_t minIndex = i;\n+        for (size_t j = i + 1; j < length; j++)\n+        {\n+            if (array[j] < array[minIndex])\n+            {\n+                minIndex = j;\n+            }\n+            \n+        }\n+        if(minIndex != i)\n+        {\n+            std::swap(array[i], array[minIndex]);\n+        }\n+    }\n+}\n+\n+void merge_sort(std::vector<int>& array, size_t l, size_t r) \n+{\n+\n+    auto merge = [](std::vector<int>& array, size_t l, size_t m, size_t r) \n+    {\n+        size_t left_length = m - l + 1;\n+        size_t right_length = r - m;\n+        int left_tmp[left_length];\n+        int right_tmp[right_length];\n+\n+        for (size_t i = 0; i < left_length; i++)\n+        {\n+            left_tmp[i] = array[l + i];\n+        }\n+        \n+        for (size_t j = 0; j < right_length; j++)\n+        {\n+            right_tmp[j] = array[m + 1 + j];\n+        }\n+\n+        size_t i = 0; // left array\n+        size_t j = 0; // right array\n+        size_t k = l;\n+\n+        while(i < left_length && j < right_length)\n+        {\n+            if(left_tmp[i] <= right_tmp[j])\n+            {\n+                array[k] = left_tmp[i];\n+                i++;\n+\n+            }\n+            else {\n+                array[k] = right_tmp[j];\n+                j++;\n+            }\n+            k++;\n+        }\n+\n+        while(i < left_length) \n+        {\n+            array[k] = left_tmp[i];\n+            i++;\n+            k++;   \n+        }\n+\n+        while(j < right_length) \n+        {\n+            array[k] = right_tmp[j];\n+            j++;\n+            k++;   \n+        }\n+    };\n+\n+    if(l >= r) \n+    {\n+        return;\n+    } else \n+    {\n+        size_t q = (int)floor((l + r) / 2); // divide step\n+        merge_sort(array, l, q); // sub-problem of size n/2\n+        merge_sort(array, q + 1, r); // sub-problem of size n/2\n+        merge(array, l, q, r); // combine step\n+    }\n+}\n+\n+\n+void recursive_insertion_sort(std::vector<int>& array, size_t n) \n+{\n+    if(n == 0)\n+    {\n+        return;\n+    }\n+    else\n+    {\n+        recursive_insertion_sort(array, n - 1); // recursive call\n+        size_t k = n - 1;\n+        while(k > 0)\n+        {\n+            if(array[k - 1] > array[k])\n+            {\n+                std::swap(array[k - 1], array[k]);\n+                k--;\n+            }\n+            else \n+            {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+\n+bool palindrome_number(int n)\n+{\n+    auto reverseNumber = [](int n) \n+    {\n+        int reversed = 0;\n+        while (n > 0) \n+        {\n+          int digit = n % 10;  // Extract the last digit\n+          reversed = reversed * 10 + digit;  // Add the digit to the reversed number\n+          n /= 10;  // Remove the last digit\n+        }\n+        return reversed;\n+    };\n+    if (n < 0) {\n+        return false;  // Negative numbers are not palindromes due to the negative sign\n+    }\n+\n+    int reversed = reverseNumber(n);\n+    return reversed == n;\n+}\n+\n+int binary_search(std::vector<int> array, size_t l, size_t r, int v)\n+{\n+    if(l >= r)\n+      return -1;\n+    else \n+    {\n+        size_t m = floor((l + r) / 2);\n+        if(array[m] == v)\n+          return m;\n+        else if(array[m] > v)\n+          return binary_search(array, l, m, v); // T(n/2)\n+        else\n+          return binary_search(array, m + 1, r, v); // T(n/2)\n+    }\n+}\n+\n+// given a set S of n integers and another integer v\n+// determines whether S contains two elements that sum to exactly v\n+// time complexity should be logarithmic -> n * lgn\n+std::optional<std::tuple<size_t, size_t>> sumOfTwoNumbers(const std::vector<int>& array, int target)\n+{\n+    std::unordered_map<int, int> map;\n+    for (int i = 0; i < array.size(); ++i) {\n+        int complement = target - array[i];\n+        if (map.find(complement) != map.end()) {\n+            return {map[complement], i};\n+        }\n+        map[array[i]] = i;\n+    }\n+    return std::nullopt;\n+}\n+\n+\n+int main()\n+{\n+    std::vector<int> array_1 = {78, 34, 67, 1111, 7, 6, -9, 11};\n+\n+    // selection(array_1);\n+    recursive_insertion_sort(array_1, array_1.size());\n+\n+    for (int i = 0; i < array_1.size(); i++) {  // Iterate through the array\n+        std::cout << array_1[i] << \" \";  // Print each element\n+    }\n+    std::cout << std::endl;  // End the line\n+\n+    std::vector<int> array_2 = {1, 2, 4, 5, 7, 9};\n+    std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n+\n+    std::vector<int> twoSum_array = {3, 3};\n+    auto opt = sumOfTwoNumbers(twoSum_array, 6);\n+    std::cout << (opt.has_value ? std::get<1>(opt) : \"null\");\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1714752763019,
            "name": "Commit-0",
            "content": "#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <vector>\n#include <optional>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n\nusing namespace std;\n\n\n// function selectionSort(arr):\n//     n = length of arr  // Length of the array\n    \n//     for i from 0 to n - 2:  // Outer loop from the first element to the second-to-last\n//         minIndex = i  // Assume the first element of the unsorted section is the minimum\n        \n//         // Find the smallest element in the unsorted section\n//         for j from i + 1 to n - 1:\n//             if arr[j] < arr[minIndex]:  // Find a smaller element\n//                 minIndex = j  // Update the index of the smallest element\n                \n//         // Swap the smallest element with the first element of the unsorted section\n//         if minIndex != i:  // Only swap if the smallest element is not already in place\n//             swap(arr[i], arr[minIndex])\n\nvoid selection(std::vector<int>& array) {\n    size_t length = array.size();\n    for (size_t i = 0; i < length - 1; i++)\n    {\n        size_t minIndex = i;\n        for (size_t j = i + 1; j < length; j++)\n        {\n            if (array[j] < array[minIndex])\n            {\n                minIndex = j;\n            }\n            \n        }\n        if(minIndex != i)\n        {\n            std::swap(array[i], array[minIndex]);\n        }\n    }\n}\n\nvoid merge_sort(std::vector<int>& array, size_t l, size_t r) \n{\n\n    auto merge = [](std::vector<int>& array, size_t l, size_t m, size_t r) \n    {\n        size_t left_length = m - l + 1;\n        size_t right_length = r - m;\n        int left_tmp[left_length];\n        int right_tmp[right_length];\n\n        for (size_t i = 0; i < left_length; i++)\n        {\n            left_tmp[i] = array[l + i];\n        }\n        \n        for (size_t j = 0; j < right_length; j++)\n        {\n            right_tmp[j] = array[m + 1 + j];\n        }\n\n        size_t i = 0; // left array\n        size_t j = 0; // right array\n        size_t k = l;\n\n        while(i < left_length && j < right_length)\n        {\n            if(left_tmp[i] <= right_tmp[j])\n            {\n                array[k] = left_tmp[i];\n                i++;\n\n            }\n            else {\n                array[k] = right_tmp[j];\n                j++;\n            }\n            k++;\n        }\n\n        while(i < left_length) \n        {\n            array[k] = left_tmp[i];\n            i++;\n            k++;   \n        }\n\n        while(j < right_length) \n        {\n            array[k] = right_tmp[j];\n            j++;\n            k++;   \n        }\n    };\n\n    if(l >= r) \n    {\n        return;\n    } else \n    {\n        size_t q = (int)floor((l + r) / 2); // divide step\n        merge_sort(array, l, q); // sub-problem of size n/2\n        merge_sort(array, q + 1, r); // sub-problem of size n/2\n        merge(array, l, q, r); // combine step\n    }\n}\n\n\nvoid recursive_insertion_sort(std::vector<int>& array, size_t n) \n{\n    if(n == 0)\n    {\n        return;\n    }\n    else\n    {\n        recursive_insertion_sort(array, n - 1); // recursive call\n        size_t k = n - 1;\n        while(k > 0)\n        {\n            if(array[k - 1] > array[k])\n            {\n                std::swap(array[k - 1], array[k]);\n                k--;\n            }\n            else \n            {\n                break;\n            }\n        }\n    }\n}\n\n\nbool palindrome_number(int n)\n{\n    auto reverseNumber = [](int n) \n    {\n        int reversed = 0;\n        while (n > 0) \n        {\n          int digit = n % 10;  // Extract the last digit\n          reversed = reversed * 10 + digit;  // Add the digit to the reversed number\n          n /= 10;  // Remove the last digit\n        }\n        return reversed;\n    };\n    if (n < 0) {\n        return false;  // Negative numbers are not palindromes due to the negative sign\n    }\n\n    int reversed = reverseNumber(n);\n    return reversed == n;\n}\n\nint binary_search(std::vector<int> array, size_t l, size_t r, int v)\n{\n    if(l >= r)\n      return -1;\n    else \n    {\n        size_t m = floor((l + r) / 2);\n        if(array[m] == v)\n          return m;\n        else if(array[m] > v)\n          return binary_search(array, l, m, v); // T(n/2)\n        else\n          return binary_search(array, m + 1, r, v); // T(n/2)\n    }\n}\n\n// given a set S of n integers and another integer v\n// determines whether S contains two elements that sum to exactly v\n// time complexity should be logarithmic -> n * lgn\nstd:: std::tuple<size_t, size_t> sumOfTwoNumbers(const std::vector<int>& array, int target)\n{\n    std::unordered_map<int, int> map;\n    for (int i = 0; i < array.size(); ++i) {\n        int complement = target - array[i];\n        if (map.find(complement) != map.end()) {\n            return {map[complement], i};\n        }\n        map[array[i]] = i;\n    }\n    return {};\n}\n\n\nint main()\n{\n    std::vector<int> array_1 = {78, 34, 67, 1111, 7, 6, -9, 11};\n\n    // selection(array_1);\n    recursive_insertion_sort(array_1, array_1.size());\n\n    for (int i = 0; i < array_1.size(); i++) {  // Iterate through the array\n        std::cout << array_1[i] << \" \";  // Print each element\n    }\n    std::cout << std::endl;  // End the line\n\n    std::vector<int> array_2 = {1, 2, 4, 5, 7, 9};\n    std::cout << binary_search(array_2, 0, array_2.size(), 1) << std::endl;\n\n    std::vector<int> twoSum_array = {3, 3};\n    auto tpl = sumOfTwoNumbers(twoSum_array, 6);\n    std::cout << std::get<1>(tpl);\n}"
        }
    ]
}