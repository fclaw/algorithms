{
    "sourceFile": "algorithms/graph/leetcode/removeInvalidParentheses.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 26,
            "patches": [
                {
                    "date": 1725969191034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725969197086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,7 +16,8 @@\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n+        \n         return {};    \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969208165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,24 @@\n+#include <vector>\n+#include <string>\n+\n+\n+namespace algorithms::graph::leetcode::invalid_parentheses\n+{\n+\n+\n+    /**\n+     * https://leetcode.com/problems/remove-invalid-parentheses\n+     * Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses \n+     * to make the input string valid.\n+     * Return a list of unique strings that are valid with the minimum number of removals. \n+     * You may return the answer in any order. \n+     * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n+     * In the recursion, for each bracket, we can either use it or remove it.\n+     * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n+     * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n+    std::vector<std::string> removeInvalidParentheses(std::string s)\n+    {\n+\n+        return {};    \n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969216470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,35 +1,14 @@\n #include <vector>\n #include <string>\n+#include <queue>\n \n-\n namespace algorithms::graph::leetcode::invalid_parentheses\n {\n \n \n-    /**\n-     * https://leetcode.com/problems/remove-invalid-parentheses\n-     * Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses \n-     * to make the input string valid.\n-     * Return a list of unique strings that are valid with the minimum number of removals. \n-     * You may return the answer in any order. \n-     * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n-     * In the recursion, for each bracket, we can either use it or remove it.\n-     * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n-     * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n-    std::vector<std::string> removeInvalidParentheses(std::string s)\n-    {\n \n-        return {};    \n-    }\n-}\n-#include <vector>\n-#include <string>\n \n-namespace algorithms::graph::leetcode::invalid_parentheses\n-{\n-\n-\n     /**\n      * https://leetcode.com/problems/remove-invalid-parentheses\n      * Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses \n      * to make the input string valid.\n@@ -40,8 +19,8 @@\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n-        \n+\n         return {};    \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969230720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,11 +4,11 @@\n \n namespace algorithms::graph::leetcode::invalid_parentheses\n {\n \n+using state = std::pair<std::string, int>;\n \n \n-\n     /**\n      * https://leetcode.com/problems/remove-invalid-parentheses\n      * Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses \n      * to make the input string valid.\n"
                },
                {
                    "date": 1725969236565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,8 @@\n {\n \n using state = std::pair<std::string, int>;\n \n-\n     /**\n      * https://leetcode.com/problems/remove-invalid-parentheses\n      * Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses \n      * to make the input string valid.\n@@ -19,8 +18,8 @@\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n-\n-        return {};    \n+        \n+        return {};\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969249891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,8 +18,8 @@\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n-        \n+        std\n         return {};\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969261945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,8 +18,8 @@\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n-        std\n+        std::vector<std::string> ans;\n         return {};\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969267959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,7 +19,7 @@\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n-        return {};\n+        return ans;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969273748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,7 +19,8 @@\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n+        bfs(s, )\n         return ans;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969279969,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,8 +19,9 @@\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n+        std::qua\n         bfs(s, )\n         return ans;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969285274,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n-        std::qua\n+        std::queue<\n         bfs(s, )\n         return ans;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969292741,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n-        std::queue<\n+        std::queue<state> q;\n         bfs(s, )\n         return ans;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969300895,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,9 @@\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n         std::queue<state> q;\n+        q.push({})\n         bfs(s, )\n         return ans;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969306753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n         std::queue<state> q;\n-        q.push({})\n+        q.push({\"\", 0});\n         bfs(s, )\n         return ans;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969313759,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,28 @@\n+#include <vector>\n+#include <string>\n+#include <queue>\n+\n+namespace algorithms::graph::leetcode::invalid_parentheses\n+{\n+\n+using state = std::pair<std::string, int>;\n+\n+    /**\n+     * https://leetcode.com/problems/remove-invalid-parentheses\n+     * Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses \n+     * to make the input string valid.\n+     * Return a list of unique strings that are valid with the minimum number of removals. \n+     * You may return the answer in any order. \n+     * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n+     * In the recursion, for each bracket, we can either use it or remove it.\n+     * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n+     * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n+    std::vector<std::string> removeInvalidParentheses(std::string s)\n+    {\n+        std::vector<std::string> ans;\n+        std::queue<state> q;\n+        q.push({\"\", 0});\n+        bfs(s, q, a)\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969324158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,8 +16,9 @@\n      * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n      * In the recursion, for each bracket, we can either use it or remove it.\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n+    void bfs()\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n         std::queue<state> q;\n"
                },
                {
                    "date": 1725969334159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,42 +16,14 @@\n      * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n      * In the recursion, for each bracket, we can either use it or remove it.\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n-    void bfs()\n+    void bfs(const )\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n         std::queue<state> q;\n         q.push({\"\", 0});\n-        bfs(s, q, a)\n+        bfs(s, q, ans);\n         return ans;\n     }\n-}\n-#include <vector>\n-#include <string>\n-#include <queue>\n-\n-namespace algorithms::graph::leetcode::invalid_parentheses\n-{\n-\n-using state = std::pair<std::string, int>;\n-\n-    /**\n-     * https://leetcode.com/problems/remove-invalid-parentheses\n-     * Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses \n-     * to make the input string valid.\n-     * Return a list of unique strings that are valid with the minimum number of removals. \n-     * You may return the answer in any order. \n-     * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n-     * In the recursion, for each bracket, we can either use it or remove it.\n-     * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n-     * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n-    std::vector<std::string> removeInvalidParentheses(std::string s)\n-    {\n-        std::vector<std::string> ans;\n-        std::queue<state> q;\n-        q.push({\"\", 0});\n-        bfs(s, )\n-        return ans;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725969358604,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n      * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n      * In the recursion, for each bracket, we can either use it or remove it.\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n-    void bfs(const )\n+    void bfs(const std::string& s, std::queue<state> q, )\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n         std::queue<state> q;\n"
                },
                {
                    "date": 1725969367159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n      * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n      * In the recursion, for each bracket, we can either use it or remove it.\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n-    void bfs(const std::string& s, std::queue<state> q, )\n+    void bfs(const std::string& s, std::queue<state> q, std::vector<std::string>& ans)\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n         std::queue<state> q;\n"
                },
                {
                    "date": 1725969383088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,8 +17,11 @@\n      * In the recursion, for each bracket, we can either use it or remove it.\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     void bfs(const std::string& s, std::queue<state> q, std::vector<std::string>& ans)\n+    {\n+        while()\n+    }\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n         std::queue<state> q;\n"
                },
                {
                    "date": 1725969388571,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     void bfs(const std::string& s, std::queue<state> q, std::vector<std::string>& ans)\n     {\n-        while()\n+        while(q.empty())\n     }\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n"
                },
                {
                    "date": 1725969393814,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,12 @@\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n     void bfs(const std::string& s, std::queue<state> q, std::vector<std::string>& ans)\n     {\n-        while(q.empty())\n+        while(!q.empty())\n+        {\n+            \n+        }\n     }\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n         std::vector<std::string> ans;\n"
                },
                {
                    "date": 1725969404656,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n     void bfs(const std::string& s, std::queue<state> q, std::vector<std::string>& ans)\n     {\n         while(!q.empty())\n         {\n-            \n+            state s\n         }\n     }\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n"
                },
                {
                    "date": 1725969410721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n     void bfs(const std::string& s, std::queue<state> q, std::vector<std::string>& ans)\n     {\n         while(!q.empty())\n         {\n-            state s\n+            state st = q.\n         }\n     }\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n"
                },
                {
                    "date": 1725969417895,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,14 +16,15 @@\n      * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n      * In the recursion, for each bracket, we can either use it or remove it.\n      * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n      * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n+    \n     void bfs(const std::string& s, std::queue<state> q, std::vector<std::string>& ans)\n     {\n         while(!q.empty())\n         {\n             state st = q.front();\n-            \n+\n         }\n     }\n     std::vector<std::string> removeInvalidParentheses(std::string s)\n     {\n"
                },
                {
                    "date": 1725969427136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,37 @@\n+#include <vector>\n+#include <string>\n+#include <queue>\n+\n+namespace algorithms::graph::leetcode::invalid_parentheses\n+{\n+\n+using state = std::pair<std::string, int>;\n+\n+    /**\n+     * https://leetcode.com/problems/remove-invalid-parentheses\n+     * Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses \n+     * to make the input string valid.\n+     * Return a list of unique strings that are valid with the minimum number of removals. \n+     * You may return the answer in any order. \n+     * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n+     * In the recursion, for each bracket, we can either use it or remove it.\n+     * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n+     * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n+    std::vector<std::string> ans;\n+    void bfs(const std::string& s, std::queue<state> q, std::vector<std::string>& ans)\n+    {\n+        while(!q.empty())\n+        {\n+            state st = q.front();\n+\n+        }\n+    }\n+    std::vector<std::string> removeInvalidParentheses(std::string s)\n+    {\n+        std::vector<std::string> ans;\n+        std::queue<state> q;\n+        q.push({\"\", 0});\n+        bfs(s, q, ans);\n+        return ans;\n+    }\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1725969191034,
            "name": "Commit-0",
            "content": "#include <vector>\n#include <string>\n\nnamespace algorithms::graph::leetcode::invalid_parentheses\n{\n\n\n    /**\n     * https://leetcode.com/problems/remove-invalid-parentheses\n     * Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses \n     * to make the input string valid.\n     * Return a list of unique strings that are valid with the minimum number of removals. \n     * You may return the answer in any order. \n     * hints: Since we do not know which brackets can be removed, we try all the options! We can use recursion\n     * In the recursion, for each bracket, we can either use it or remove it.\n     * Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.\n     * We can count the number of invalid brackets to be deleted and only generate the valid strings in the recursion. */\n    std::vector<std::string> removeInvalidParentheses(std::string s)\n    {\n        return {};    \n    }\n}"
        }
    ]
}