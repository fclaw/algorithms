{
    "sourceFile": "algorithms/graph/leetcode/minimumMoves.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 123,
            "patches": [
                {
                    "date": 1725118812204,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725118832410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,2 +1,4 @@\n \n \n+\n+algorithms::graph::leetcode::\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725118849162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,7 @@\n \n \n \n-algorithms::graph::leetcode::\n\\ No newline at end of file\n+algorithms::graph::leetcode::snake\n+{\n+    \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725118861409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,10 @@\n \n \n \n-algorithms::graph::leetcode::snake\n+namespace algorithms::graph::leetcode::snake\n {\n-    \n+\n+int minimumMoves(vector<vector<int>>& grid) {\n+        \n+    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725118868567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,10 @@\n \n namespace algorithms::graph::leetcode::snake\n {\n \n-int minimumMoves(vector<vector<int>>& grid) {\n-        \n+using \n+\n+    int minimumMoves(vector<vector<int>>& grid) \n+    {    \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725118877304,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n+#include <ve\n \n \n-\n namespace algorithms::graph::leetcode::snake\n {\n \n-using \n+using grid = \n \n     int minimumMoves(vector<vector<int>>& grid) \n     {    \n     }\n"
                },
                {
                    "date": 1725118886291,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n-#include <ve\n+#include <vector>\n \n \n namespace algorithms::graph::leetcode::snake\n {\n \n-using grid = \n+using grid = vector<vector<int>>\n \n     int minimumMoves(vector<vector<int>>& grid) \n     {    \n     }\n"
                },
                {
                    "date": 1725118892077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n \n namespace algorithms::graph::leetcode::snake\n {\n \n-using grid = vector<vector<int>>\n+using grid = std::vector<std::vector<int>>;\n \n     int minimumMoves(vector<vector<int>>& grid) \n     {    \n     }\n"
                },
                {
                    "date": 1725118899363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,8 @@\n {\n \n using grid = std::vector<std::vector<int>>;\n \n-    int minimumMoves(vector<vector<int>>& grid) \n+    int minimumMoves(const grid& grid) \n     {    \n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725118905275,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,9 @@\n {\n \n using grid = std::vector<std::vector<int>>;\n \n-    int minimumMoves(const grid& grid) \n-    {    \n+    int minimumMoves(const grid& g) \n+    {\n+        return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725118914252,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,12 @@\n {\n \n using grid = std::vector<std::vector<int>>;\n \n+    /**\n+     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n+     * \n+     */\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725118993657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,15 @@\n using grid = std::vector<std::vector<int>>;\n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n-     * \n+     * In an n*n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n+\n+In one move the snake can:\n+\n+Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n+Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n+Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n      */\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n"
                },
                {
                    "date": 1725119002540,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,10 @@\n using grid = std::vector<std::vector<int>>;\n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n-     * In an n*n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n+     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n+     * The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n \n In one move the snake can:\n \n Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n"
                },
                {
                    "date": 1725119007569,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,10 @@\n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n      * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n-     * The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n+     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n+     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n \n In one move the snake can:\n \n Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n"
                },
                {
                    "date": 1725119013622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,11 +10,9 @@\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n      * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n      * The grid has empty cells represented by zeros and blocked cells represented by ones. \n      * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n-\n-In one move the snake can:\n-\n+     * In one move the snake can:\n Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n      */\n"
                },
                {
                    "date": 1725119024726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,10 @@\n      * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n      * The grid has empty cells represented by zeros and blocked cells represented by ones. \n      * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n      * In one move the snake can:\n-Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n+     * Move one cell to the right if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n      */\n     int minimumMoves(const grid& g) \n"
                },
                {
                    "date": 1725119032762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n      * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n      * In one move the snake can:\n      * Move one cell to the right if there are no blocked cells there. \n      * This move keeps the horizontal/vertical position of the snake as it is.\n-Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n+     * Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n      */\n     int minimumMoves(const grid& g) \n     {\n"
                },
                {
                    "date": 1725119040867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,10 @@\n      * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n      * In one move the snake can:\n      * Move one cell to the right if there are no blocked cells there. \n      * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n+     * Move down one cell if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n      */\n     int minimumMoves(const grid& g) \n     {\n"
                },
                {
                    "date": 1725119046973,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,9 +15,9 @@\n      * Move one cell to the right if there are no blocked cells there. \n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Move down one cell if there are no blocked cells there. \n      * This move keeps the horizontal/vertical position of the snake as it is.\n-Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n+     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n      */\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n"
                },
                {
                    "date": 1725119055809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,9 +15,10 @@\n      * Move one cell to the right if there are no blocked cells there. \n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Move down one cell if there are no blocked cells there. \n      * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n+     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n+     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n      */\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n"
                },
                {
                    "date": 1725119063283,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,10 +16,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Move down one cell if there are no blocked cells there. \n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n-     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n-     */\n+     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c). */\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725280576495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,10 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Move down one cell if there are no blocked cells there. \n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n-     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c). */\n+     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n+     *  */\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725280581916,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,9 @@\n      * Move down one cell if there are no blocked cells there. \n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n-     *  */\n+     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725280618854,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,8 +18,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n+    \n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725280625462,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    \n+    enum Position \n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725280642849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position \n+    enum Position = { horizontal}\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725280650478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position = { horizontal}\n+    enum Position = { Horizontal = 0, horizontal = 1 }\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725280658255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position = { Horizontal = 0, horizontal = 1 }\n+    enum Position = { Horizontal = 0, vertical = 1 }\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725280663455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position = { Horizontal = 0, vertical = 1 }\n+    enum Position { Horizontal = 0, Vertical = 1 }\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725280669187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = 0, Vertical = 1 }\n+    enum Position { Horizontal = 0, Vertical = 1 };\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725281471145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,8 +19,9 @@\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n     enum Position { Horizontal = 0, Vertical = 1 };\n+    ]\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725281489167,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,12 @@\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n     enum Position { Horizontal = 0, Vertical = 1 };\n-    ]\n+    const int inf = 5 * 1e+05;\n+    const int Empty = 0;\n+    const int Block = 1;\n+    int M, N;\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725281611642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,10 @@\n {\n \n using grid = std::vector<std::vector<int>>;\n \n+\n+\n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n      * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n      * The grid has empty cells represented by zeros and blocked cells represented by ones. \n"
                },
                {
                    "date": 1725281620658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,10 +5,10 @@\n {\n \n using grid = std::vector<std::vector<int>>;\n \n+struct Snake\n \n-\n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n      * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n      * The grid has empty cells represented by zeros and blocked cells represented by ones. \n"
                },
                {
                    "date": 1725281627937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,11 @@\n \n using grid = std::vector<std::vector<int>>;\n \n struct Snake\n+{\n+    \n+}\n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n      * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n"
                },
                {
                    "date": 1725281644678,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n using grid = std::vector<std::vector<int>>;\n \n struct Snake\n {\n-    \n+    std::pair<int, int> \n }\n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n"
                },
                {
                    "date": 1725281654575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,11 @@\n using grid = std::vector<std::vector<int>>;\n \n struct Snake\n {\n-    std::pair<int, int> \n+    std::pair<int, int> head;\n+    std::pair<int, int> tail;\n+    \n }\n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n"
                },
                {
                    "date": 1725281662467,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,13 +5,14 @@\n {\n \n using grid = std::vector<std::vector<int>>;\n \n+enum Position { Horizontal = 0, Vertical = 1 };\n struct Snake\n {\n     std::pair<int, int> head;\n     std::pair<int, int> tail;\n-    \n+\n }\n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n@@ -25,9 +26,8 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = 0, Vertical = 1 };\n     const int inf = 5 * 1e+05;\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n"
                },
                {
                    "date": 1725281671298,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,12 +6,14 @@\n \n using grid = std::vector<std::vector<int>>;\n \n enum Position { Horizontal = 0, Vertical = 1 };\n+\n struct Snake\n {\n     std::pair<int, int> head;\n     std::pair<int, int> tail;\n+    Position pos;\n \n }\n \n     /**\n"
                },
                {
                    "date": 1725281843563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,16 +7,8 @@\n using grid = std::vector<std::vector<int>>;\n \n enum Position { Horizontal = 0, Vertical = 1 };\n \n-struct Snake\n-{\n-    std::pair<int, int> head;\n-    std::pair<int, int> tail;\n-    Position pos;\n-\n-}\n-\n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n      * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n      * The grid has empty cells represented by zeros and blocked cells represented by ones. \n"
                },
                {
                    "date": 1725281882146,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,8 @@\n {\n \n using grid = std::vector<std::vector<int>>;\n \n-enum Position { Horizontal = 0, Vertical = 1 };\n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n      * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n"
                },
                {
                    "date": 1725281888363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,8 +19,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n+    enum Position { Horizontal = 0, Vertical = 1 };\n     const int inf = 5 * 1e+05;\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n"
                },
                {
                    "date": 1725281945497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,8 +24,9 @@\n     const int inf = 5 * 1e+05;\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n+    \n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725281955394,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,10 @@\n namespace algorithms::graph::leetcode::snake\n {\n \n using grid = std::vector<std::vector<int>>;\n+using vi = std::vector<std::vector<bool>>;\n+using dist = std::vector<std::vector<int>>;\n \n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n@@ -24,9 +26,9 @@\n     const int inf = 5 * 1e+05;\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n-    \n+\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725281964522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,35 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::leetcode::snake\n+{\n+\n+using grid = std::vector<std::vector<int>>;\n+using vi = std::vector<std::vector<std::vector<>>>;\n+using dist = std::vector<std::vector<int>>;\n+\n+\n+    /**\n+     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n+     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n+     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n+     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n+     * In one move the snake can:\n+     * Move one cell to the right if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Move down one cell if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n+     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n+     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n+    enum Position { Horizontal = 0, Vertical = 1 };\n+    const int inf = 5 * 1e+05;\n+    const int Empty = 0;\n+    const int Block = 1;\n+    int M, N;\n+\n+    int minimumMoves(const grid& g) \n+    {\n+        return 0;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725281971664,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n namespace algorithms::graph::leetcode::snake\n {\n \n using grid = std::vector<std::vector<int>>;\n-using vi = std::vector<std::vector<std::vector<>>>;\n+using vi = std::vector<std::vector<std::vector<Position>>>;\n using dist = std::vector<std::vector<int>>;\n \n \n     /**\n@@ -21,9 +21,8 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = 0, Vertical = 1 };\n     const int inf = 5 * 1e+05;\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n@@ -31,40 +30,5 @@\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n-}\n-#include <vector>\n-\n-\n-namespace algorithms::graph::leetcode::snake\n-{\n-\n-using grid = std::vector<std::vector<int>>;\n-using vi = std::vector<std::vector<bool>>;\n-using dist = std::vector<std::vector<int>>;\n-\n-\n-    /**\n-     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n-     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n-     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n-     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n-     * In one move the snake can:\n-     * Move one cell to the right if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Move down one cell if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n-     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n-     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = 0, Vertical = 1 };\n-    const int inf = 5 * 1e+05;\n-    const int Empty = 0;\n-    const int Block = 1;\n-    int M, N;\n-\n-    int minimumMoves(const grid& g) \n-    {\n-        return 0;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725281977496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,10 @@\n \n namespace algorithms::graph::leetcode::snake\n {\n \n+enum Position { Horizontal = 0, Vertical = 1 };\n+\n using grid = std::vector<std::vector<int>>;\n using vi = std::vector<std::vector<std::vector<Position>>>;\n using dist = std::vector<std::vector<int>>;\n \n"
                },
                {
                    "date": 1725282003579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n \n enum Position { Horizontal = 0, Vertical = 1 };\n \n using grid = std::vector<std::vector<int>>;\n-using vi = std::vector<std::vector<std::vector<Position>>>;\n+using vi = std::vector<std::vector<std::vector<bool>>>;\n using dist = std::vector<std::vector<int>>;\n \n \n     /**\n"
                },
                {
                    "date": 1725282011877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n enum Position { Horizontal = 0, Vertical = 1 };\n \n using grid = std::vector<std::vector<int>>;\n using vi = std::vector<std::vector<std::vector<bool>>>;\n-using dist = std::vector<std::vector<int>>;\n+using dist = std::vector<std::vector<std::>>;\n \n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n"
                },
                {
                    "date": 1725282018742,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n enum Position { Horizontal = 0, Vertical = 1 };\n \n using grid = std::vector<std::vector<int>>;\n using vi = std::vector<std::vector<std::vector<bool>>>;\n-using dist = std::vector<std::vector<std::>>;\n+using dist = std::vector<std::vector<std::vector<>>>;\n \n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n"
                },
                {
                    "date": 1725282025338,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,13 +3,11 @@\n \n namespace algorithms::graph::leetcode::snake\n {\n \n-enum Position { Horizontal = 0, Vertical = 1 };\n-\n using grid = std::vector<std::vector<int>>;\n using vi = std::vector<std::vector<std::vector<bool>>>;\n-using dist = std::vector<std::vector<std::vector<>>>;\n+using dist = std::vector<std::vector<std::vector<int>>>;\n \n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n"
                },
                {
                    "date": 1725282031819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,8 +21,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n+    enum Position { Horizontal = 0, Vertical = 1 };\n     const int inf = 5 * 1e+05;\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n"
                },
                {
                    "date": 1725282043777,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n     const int inf = 5 * 1e+05;\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n-\n+    vi visited;\n     int minimumMoves(const grid& g) \n     {\n         return 0;\n     }\n"
                },
                {
                    "date": 1725282049471,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,7 +29,8 @@\n     int M, N;\n     vi visited;\n     int minimumMoves(const grid& g) \n     {\n+        M = g.\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282061790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,8 +29,10 @@\n     int M, N;\n     vi visited;\n     int minimumMoves(const grid& g) \n     {\n-        M = g.\n+        M = g.size();\n+        N = g[0].size();\n+        \n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282067467,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,8 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        \n+        visited = vi()\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282074321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,8 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        visited = vi()\n+        visited = vi(M, std::vector<>)\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282079700,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,8 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        visited = vi(M, std::vector<>)\n+        visited = vi(M, std::vector<std::vector<>>)\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282099455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,8 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        visited = vi(M, std::vector<std::vector<>>)\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<>))\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282105561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,8 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<>))\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>()))\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282110867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,8 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>()))\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(Position::)))\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282275960,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,8 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(Position::)))\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(std::numeric_limits<enum Foo>::max())))\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282281985,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,8 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(std::numeric_limits<enum Foo>::max())))\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(std::numeric_limits<enum Position>::max())))\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282295237,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,8 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(std::numeric_limits<enum Position>::max())))\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(std::numeric_limits<enum Position>::max(), false)))\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282309859,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,8 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(std::numeric_limits<enum Position>::max(), false)))\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(std::numeric_limits<enum Position>::max(), false)));\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282516975,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,7 +32,8 @@\n     {\n         M = g.size();\n         N = g[0].size();\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(std::numeric_limits<enum Position>::max(), false)));\n+        cout << std::numeric_limits<enum Position>::max() << \"\\n\";\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282557886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(std::numeric_limits<enum Position>::max(), false)));\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n         cout << std::numeric_limits<enum Position>::max() << \"\\n\";\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282657434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = 0, Vertical = 1 };\n+    enum Position { Horizontal = (1u << 0), Vertical = 1 };\n     const int inf = 5 * 1e+05;\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n"
                },
                {
                    "date": 1725282663590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n      * This move keeps the horizontal/vertical position of the snake as it is.\n      * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n      * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n      * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = (1u << 0), Vertical = 1 };\n+    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n     const int inf = 5 * 1e+05;\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n"
                },
                {
                    "date": 1725282684790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,40 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::leetcode::snake\n+{\n+\n+using grid = std::vector<std::vector<int>>;\n+using vi = std::vector<std::vector<std::vector<bool>>>;\n+using dist = std::vector<std::vector<std::vector<int>>>;\n+\n+\n+    /**\n+     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n+     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n+     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n+     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n+     * In one move the snake can:\n+     * Move one cell to the right if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Move down one cell if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n+     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n+     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n+    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n+    const int inf = 5 * 1e+05;\n+    const int Empty = 0;\n+    const int Block = 1;\n+    int M, N;\n+    vi visited;\n+    int minimumMoves(const grid& g) \n+    {\n+        M = g.size();\n+        N = g[0].size();\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n+        int po\n+        cout << std::numeric_limits<enum Position>::max() << \"\\n\";\n+        return 0;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282694461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,48 +32,9 @@\n     {\n         M = g.size();\n         N = g[0].size();\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n-        int po\n-        cout << std::numeric_limits<enum Position>::max() << \"\\n\";\n+        int position = 0;\n+        cout <<  << \"\\n\";\n         return 0;\n     }\n-}\n-#include <vector>\n-\n-\n-namespace algorithms::graph::leetcode::snake\n-{\n-\n-using grid = std::vector<std::vector<int>>;\n-using vi = std::vector<std::vector<std::vector<bool>>>;\n-using dist = std::vector<std::vector<std::vector<int>>>;\n-\n-\n-    /**\n-     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n-     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n-     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n-     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n-     * In one move the snake can:\n-     * Move one cell to the right if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Move down one cell if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n-     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n-     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n-    const int inf = 5 * 1e+05;\n-    const int Empty = 0;\n-    const int Block = 1;\n-    int M, N;\n-    vi visited;\n-    int minimumMoves(const grid& g) \n-    {\n-        M = g.size();\n-        N = g[0].size();\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n-        cout << std::numeric_limits<enum Position>::max() << \"\\n\";\n-        return 0;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282702339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,8 +33,8 @@\n         M = g.size();\n         N = g[0].size();\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n         int position = 0;\n-        cout <<  << \"\\n\";\n+        cout << position |   << \"\\n\";\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282713043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,8 +33,8 @@\n         M = g.size();\n         N = g[0].size();\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n         int position = 0;\n-        cout << position |   << \"\\n\";\n+        cout << position |= Horizontal)  << \"\\n\";\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282734025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,8 +33,7 @@\n         M = g.size();\n         N = g[0].size();\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n         int position = 0;\n-        cout << position |= Horizontal)  << \"\\n\";\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282743419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n+        int position = 0;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n-        int position = 0;\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282837012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,39 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::leetcode::snake\n+{\n+\n+using grid = std::vector<std::vector<int>>;\n+using vi = std::vector<std::vector<std::vector<bool>>>;\n+using dist = std::vector<std::vector<std::vector<int>>>;\n+\n+\n+    /**\n+     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n+     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n+     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n+     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n+     * In one move the snake can:\n+     * Move one cell to the right if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Move down one cell if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n+     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n+     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n+    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n+    const int inf = 5 * 1e+05;\n+    const int Empty = 0;\n+    const int Block = 1;\n+    int M, N;\n+    vi visited;\n+    int minimumMoves(const grid& g) \n+    {\n+        M = g.size();\n+        N = g[0].size();\n+        int position = 0;\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n+        return 0;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282844821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,46 +33,8 @@\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n+        dist = \n         return 0;\n     }\n-}\n-#include <vector>\n-\n-\n-namespace algorithms::graph::leetcode::snake\n-{\n-\n-using grid = std::vector<std::vector<int>>;\n-using vi = std::vector<std::vector<std::vector<bool>>>;\n-using dist = std::vector<std::vector<std::vector<int>>>;\n-\n-\n-    /**\n-     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n-     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n-     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n-     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n-     * In one move the snake can:\n-     * Move one cell to the right if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Move down one cell if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n-     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n-     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n-    const int inf = 5 * 1e+05;\n-    const int Empty = 0;\n-    const int Block = 1;\n-    int M, N;\n-    vi visited;\n-    int minimumMoves(const grid& g) \n-    {\n-        M = g.size();\n-        N = g[0].size();\n-        int position = 0;\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n-        return 0;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282857535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,8 +33,8 @@\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n-        dist = \n+        dist = dist(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282875981,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,8 +33,8 @@\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n-        dist = dist(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n+        dist = dist(M, std::vector<std::vector<bool>>(N, std::vector<int>(2, inf)));\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725282883282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,8 +27,9 @@\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n     vi visited;\n+    \n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n"
                },
                {
                    "date": 1725282890582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n     const int Empty = 0;\n     const int Block = 1;\n     int M, N;\n     vi visited;\n-    \n+    dist distance;\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n"
                },
                {
                    "date": 1725282903164,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,8 +34,8 @@\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n-        dist = dist(M, std::vector<std::vector<bool>>(N, std::vector<int>(2, inf)));\n+        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf)));\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283077374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n     {\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false)));\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // \n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf)));\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283086058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,41 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::leetcode::snake\n+{\n+\n+using grid = std::vector<std::vector<int>>;\n+using vi = std::vector<std::vector<std::vector<bool>>>;\n+using dist = std::vector<std::vector<std::vector<int>>>;\n+\n+\n+    /**\n+     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n+     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n+     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n+     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n+     * In one move the snake can:\n+     * Move one cell to the right if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Move down one cell if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n+     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n+     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n+    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n+    const int inf = 5 * 1e+05;\n+    const int Empty = 0;\n+    const int Block = 1;\n+    int M, N;\n+    vi visited;\n+    dist distance;\n+    int minimumMoves(const grid& g) \n+    {\n+        M = g.size();\n+        N = g[0].size();\n+        int position = 0;\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells \n+        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf)));\n+        return 0;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283094213,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,41 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::leetcode::snake\n+{\n+\n+using grid = std::vector<std::vector<int>>;\n+using vi = std::vector<std::vector<std::vector<bool>>>;\n+using dist = std::vector<std::vector<std::vector<int>>>;\n+\n+\n+    /**\n+     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n+     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n+     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n+     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n+     * In one move the snake can:\n+     * Move one cell to the right if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Move down one cell if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n+     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n+     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n+    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n+    const int inf = 5 * 1e+05;\n+    const int Empty = 0;\n+    const int Block = 1;\n+    int M, N;\n+    vi visited;\n+    dist distance;\n+    int minimumMoves(const grid& g) \n+    {\n+        M = g.size();\n+        N = g[0].size();\n+        int position = 0;\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n+        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf)));\n+        return 0;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283103451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,90 +34,8 @@\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n-        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf)));\n+        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head\n         return 0;\n     }\n-}\n-#include <vector>\n-\n-\n-namespace algorithms::graph::leetcode::snake\n-{\n-\n-using grid = std::vector<std::vector<int>>;\n-using vi = std::vector<std::vector<std::vector<bool>>>;\n-using dist = std::vector<std::vector<std::vector<int>>>;\n-\n-\n-    /**\n-     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n-     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n-     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n-     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n-     * In one move the snake can:\n-     * Move one cell to the right if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Move down one cell if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n-     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n-     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n-    const int inf = 5 * 1e+05;\n-    const int Empty = 0;\n-    const int Block = 1;\n-    int M, N;\n-    vi visited;\n-    dist distance;\n-    int minimumMoves(const grid& g) \n-    {\n-        M = g.size();\n-        N = g[0].size();\n-        int position = 0;\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells \n-        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf)));\n-        return 0;\n-    }\n-}\n-#include <vector>\n-\n-\n-namespace algorithms::graph::leetcode::snake\n-{\n-\n-using grid = std::vector<std::vector<int>>;\n-using vi = std::vector<std::vector<std::vector<bool>>>;\n-using dist = std::vector<std::vector<std::vector<int>>>;\n-\n-\n-    /**\n-     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n-     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n-     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n-     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n-     * In one move the snake can:\n-     * Move one cell to the right if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Move down one cell if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n-     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n-     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n-    const int inf = 5 * 1e+05;\n-    const int Empty = 0;\n-    const int Block = 1;\n-    int M, N;\n-    vi visited;\n-    dist distance;\n-    int minimumMoves(const grid& g) \n-    {\n-        M = g.size();\n-        N = g[0].size();\n-        int position = 0;\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // \n-        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf)));\n-        return 0;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283109156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,8 +34,8 @@\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n-        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head\n+        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell \n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283115701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,41 @@\n+#include <vector>\n+\n+\n+namespace algorithms::graph::leetcode::snake\n+{\n+\n+using grid = std::vector<std::vector<int>>;\n+using vi = std::vector<std::vector<std::vector<bool>>>;\n+using dist = std::vector<std::vector<std::vector<int>>>;\n+\n+\n+    /**\n+     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n+     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n+     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n+     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n+     * In one move the snake can:\n+     * Move one cell to the right if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Move down one cell if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n+     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n+     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n+    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n+    const int inf = 5 * 1e+05;\n+    const int Empty = 0;\n+    const int Block = 1;\n+    int M, N;\n+    vi visited;\n+    dist distance;\n+    int minimumMoves(const grid& g) \n+    {\n+        M = g.size();\n+        N = g[0].size();\n+        int position = 0;\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n+        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n+        return 0;\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283121328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,46 +37,5 @@\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n         return 0;\n     }\n-}\n-#include <vector>\n-\n-\n-namespace algorithms::graph::leetcode::snake\n-{\n-\n-using grid = std::vector<std::vector<int>>;\n-using vi = std::vector<std::vector<std::vector<bool>>>;\n-using dist = std::vector<std::vector<std::vector<int>>>;\n-\n-\n-    /**\n-     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n-     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n-     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n-     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n-     * In one move the snake can:\n-     * Move one cell to the right if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Move down one cell if there are no blocked cells there. \n-     * This move keeps the horizontal/vertical position of the snake as it is.\n-     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n-     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n-     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n-    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n-    const int inf = 5 * 1e+05;\n-    const int Empty = 0;\n-    const int Block = 1;\n-    int M, N;\n-    vi visited;\n-    dist distance;\n-    int minimumMoves(const grid& g) \n-    {\n-        M = g.size();\n-        N = g[0].size();\n-        int position = 0;\n-        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n-        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell \n-        return 0;\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283127822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,11 @@\n     {\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n+        \n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n+\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283134097,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n #include <vector>\n+#include <queue>\n \n-\n namespace algorithms::graph::leetcode::snake\n {\n \n using grid = std::vector<std::vector<int>>;\n@@ -33,9 +33,9 @@\n     {\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n-        \n+\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n \n         return 0;\n"
                },
                {
                    "date": 1725283139966,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n     {\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n-\n+        std::que\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n \n         return 0;\n"
                },
                {
                    "date": 1725283149166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n     {\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n-        std::que\n+        std::queue<std::pair<\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n \n         return 0;\n"
                },
                {
                    "date": 1725283154622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,9 @@\n \n using grid = std::vector<std::vector<int>>;\n using vi = std::vector<std::vector<std::vector<bool>>>;\n using dist = std::vector<std::vector<std::vector<int>>>;\n+using \n \n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n"
                },
                {
                    "date": 1725283163621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n \n using grid = std::vector<std::vector<int>>;\n using vi = std::vector<std::vector<std::vector<bool>>>;\n using dist = std::vector<std::vector<std::vector<int>>>;\n-using \n+using cell = std::pair<int, int>\n \n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n"
                },
                {
                    "date": 1725283171354,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n     {\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n-        std::queue<std::pair<\n+        std::queue<std::pair<cell, \n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n \n         return 0;\n"
                },
                {
                    "date": 1725283176484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n \n using grid = std::vector<std::vector<int>>;\n using vi = std::vector<std::vector<std::vector<bool>>>;\n using dist = std::vector<std::vector<std::vector<int>>>;\n-using cell = std::pair<int, int>\n+using cell = std::pair<int, int>;\n \n \n     /**\n      * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n@@ -34,9 +34,9 @@\n     {\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n-        std::queue<std::pair<cell, \n+        std::queue<std::pair<cell, int>\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n \n         return 0;\n"
                },
                {
                    "date": 1725283185414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,11 +34,11 @@\n     {\n         M = g.size();\n         N = g[0].size();\n         int position = 0;\n-        std::queue<std::pair<cell, int>\n+        std::queue<std::pair<cell, int>> q;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n-\n+        q.\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283195127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,8 +37,8 @@\n         int position = 0;\n         std::queue<std::pair<cell, int>> q;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n-        q.\n+        q.push({0, 1})\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283201372,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,8 +37,8 @@\n         int position = 0;\n         std::queue<std::pair<cell, int>> q;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n-        q.push({0, 1})\n+        q.push({{0, 1},  })\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283207131,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,8 +37,8 @@\n         int position = 0;\n         std::queue<std::pair<cell, int>> q;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n-        q.push({{0, 1},  })\n+        q.push({{0, 1}, position |=  })\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283218629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,8 +37,8 @@\n         int position = 0;\n         std::queue<std::pair<cell, int>> q;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n-        q.push({{0, 1}, position |=  })\n+        q.push({{0, 1}, position |= Vertical })\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283224323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,8 +37,9 @@\n         int position = 0;\n         std::queue<std::pair<cell, int>> q;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n-        q.push({{0, 1}, position |= Vertical })\n+        q.push({{0, 1}, position |= Vertical});\n+        \n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283238434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,8 +38,8 @@\n         std::queue<std::pair<cell, int>> q;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n         q.push({{0, 1}, position |= Vertical});\n-        \n+        visited[]\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283244905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,8 +38,8 @@\n         std::queue<std::pair<cell, int>> q;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n         q.push({{0, 1}, position |= Vertical});\n-        visited[]\n+        visited[0][0] = true;\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283250502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,7 +39,8 @@\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n         q.push({{0, 1}, position |= Vertical});\n         visited[0][0] = true;\n+        visited[0][1] = true;\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283258484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,10 @@\n         std::queue<std::pair<cell, int>> q;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n         q.push({{0, 1}, position |= Vertical});\n-        visited[0][0] = true;\n+        visited[0][0][] = true;\n         visited[0][1] = true;\n+\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283266998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,9 @@\n         std::queue<std::pair<cell, int>> q;\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n         q.push({{0, 1}, position |= Vertical});\n-        visited[0][0][] = true;\n+        visited[0][0][position |= Vertical] = true;\n         visited[0][1] = true;\n \n         return 0;\n     }\n"
                },
                {
                    "date": 1725283275381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,9 @@\n         visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n         q.push({{0, 1}, position |= Vertical});\n         visited[0][0][position |= Vertical] = true;\n-        visited[0][1] = true;\n-\n+        visited[0][1][position |= Vertical] = true;\n+        distance[]\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283281892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,8 +40,8 @@\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n         q.push({{0, 1}, position |= Vertical});\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n-        distance[]\n+        distance[0][1][position |= Vertical]\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283290759,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,8 +40,9 @@\n         distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n         q.push({{0, 1}, position |= Vertical});\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n-        distance[0][1][position |= Vertical]\n+        distance[0][1][position |= Vertical] = 1;\n+        \n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283298816,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,8 +41,8 @@\n         q.push({{0, 1}, position |= Vertical});\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n         distance[0][1][position |= Vertical] = 1;\n-        \n+        bfs(g, )\n         return 0;\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283316725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,8 +41,8 @@\n         q.push({{0, 1}, position |= Vertical});\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n         distance[0][1][position |= Vertical] = 1;\n-        bfs(g, )\n-        return 0;\n+        bfs(g, q);\n+        return std::min();\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283325997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,7 +42,7 @@\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n         distance[0][1][position |= Vertical] = 1;\n         bfs(g, q);\n-        return std::min();\n+        return std::min(distance[0][1][position |= Vertical]);\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283333534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,7 +42,7 @@\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n         distance[0][1][position |= Vertical] = 1;\n         bfs(g, q);\n-        return std::min(distance[0][1][position |= Vertical]);\n+        return std::min(distance[M - 1][N - 1][position |= Vertical]);\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283345689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,7 +42,7 @@\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n         distance[0][1][position |= Vertical] = 1;\n         bfs(g, q);\n-        return std::min(distance[M - 1][N - 1][position |= Vertical]);\n+        return std::min(distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Vertical]);\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283351369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,7 +42,7 @@\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n         distance[0][1][position |= Vertical] = 1;\n         bfs(g, q);\n-        return std::min(distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Vertical]);\n+        return std::min(distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Horizontal]);\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283362544,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,8 +29,9 @@\n     const int Block = 1;\n     int M, N;\n     vi visited;\n     dist distance;\n+    void bfs()\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n"
                },
                {
                    "date": 1725283368405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n     const int Block = 1;\n     int M, N;\n     vi visited;\n     dist distance;\n-    void bfs()\n+    void bfs(const grid& g, )\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n"
                },
                {
                    "date": 1725283376801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,12 @@\n     const int Block = 1;\n     int M, N;\n     vi visited;\n     dist distance;\n-    void bfs(const grid& g, )\n+    void bfs(const grid& g, std::queue<std::pair<cell, int>> q)\n+    {\n+        \n+    }\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n         N = g[0].size();\n"
                },
                {
                    "date": 1725283392095,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     vi visited;\n     dist distance;\n     void bfs(const grid& g, std::queue<std::pair<cell, int>> q)\n     {\n-        \n+\n     }\n     int minimumMoves(const grid& g) \n     {\n         M = g.size();\n@@ -46,7 +46,8 @@\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n         distance[0][1][position |= Vertical] = 1;\n         bfs(g, q);\n+        int ans = std::min(distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Horizontal])\n         return std::min(distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Horizontal]);\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283399679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,8 +46,10 @@\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n         distance[0][1][position |= Vertical] = 1;\n         bfs(g, q);\n-        int ans = std::min(distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Horizontal])\n+        int ans = \n+              std::min(distance[M - 1][N - 1][position |= Vertical], \n+                       distance[M - 1][N - 1][position |= Horizontal])\n         return std::min(distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Horizontal]);\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283406707,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,8 +46,8 @@\n         visited[0][0][position |= Vertical] = true;\n         visited[0][1][position |= Vertical] = true;\n         distance[0][1][position |= Vertical] = 1;\n         bfs(g, q);\n-        int ans = std::min(distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Horizontal])\n+        int ans = distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Horizontal])\n         return std::min(distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Horizontal]);\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725283422793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,54 @@\n+#include <vector>\n+#include <queue>\n+\n+namespace algorithms::graph::leetcode::snake\n+{\n+\n+using grid = std::vector<std::vector<int>>;\n+using vi = std::vector<std::vector<std::vector<bool>>>;\n+using dist = std::vector<std::vector<std::vector<int>>>;\n+using cell = std::pair<int, int>;\n+\n+\n+    /**\n+     * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations\n+     * In an n * n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). \n+     * The grid has empty cells represented by zeros and blocked cells represented by ones. \n+     * The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n+     * In one move the snake can:\n+     * Move one cell to the right if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Move down one cell if there are no blocked cells there. \n+     * This move keeps the horizontal/vertical position of the snake as it is.\n+     * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. \n+     * In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c)\n+     * hint: The state of the BFS is the position (x, y) along with a binary value that specifies if the position is horizontal or vertical. */\n+    enum Position { Horizontal = (1u << 0), Vertical = (1u << 1) };\n+    const int inf = 5 * 1e+05;\n+    const int Empty = 0;\n+    const int Block = 1;\n+    int M, N;\n+    vi visited;\n+    dist distance;\n+    void bfs(const grid& g, std::queue<std::pair<cell, int>> q)\n+    {\n+\n+    }\n+    int minimumMoves(const grid& g) \n+    {\n+        M = g.size();\n+        N = g[0].size();\n+        int position = 0;\n+        std::queue<std::pair<cell, int>> q;\n+        visited = vi(M, std::vector<std::vector<bool>>(N, std::vector<bool>(2, false))); // 2 cells occupied\n+        distance = dist(M, std::vector<std::vector<int>>(N, std::vector<int>(2, inf))); // only head cell counts\n+        q.push({{0, 1}, position |= Vertical});\n+        visited[0][0][position |= Vertical] = true;\n+        visited[0][1][position |= Vertical] = true;\n+        distance[0][1][position |= Vertical] = 1;\n+        bfs(g, q);\n+        int v_ans = distance[M - 1][N - 1][position |= Vertical];\n+        int h_ans = distance[M - 1][N - 1][position |= Horizontal])\n+        return std::min(distance[M - 1][N - 1][position |= Vertical], distance[M - 1][N - 1][position |= Horizontal]);\n+    }\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1725118812204,
            "name": "Commit-0",
            "content": "\n\n"
        }
    ]
}