/*
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ§³ UVa 620 Cellular Structure, https://onlinejudge.org/external/6/620.pdf, rt: s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * =====================================================================================
 * STRATEGIC GUIDE: SOLVING UVa 620 - Cellular Structure
 * =====================================================================================
 *
 * This problem asks us to classify a given string (a cellular chain) based on a set
 * of recursive "growth" rules that define a "healthy" organism. The core of the
 * problem is to determine if a given string can be generated by these rules.
 *
 * -------------------------------------------------------------------------------------
 * The Grammar of a Healthy Organism
 * -------------------------------------------------------------------------------------
 *
 * The problem defines a formal grammar for the language of healthy organisms. Let 'O'
 * represent any valid, healthy organism string. The rules are:
 *
 * 1.  Base Case (Simple Stage):
 *     O -> "A"
 *     This is the "seed" or the axiom. The string "A" is the simplest healthy organism.
 *
 * 2.  Recursive Rule 1 (Fully-Grown Stage):
 *     O -> O + "AB"
 *     This rule states that if you have any healthy organism 'O', you can form a new,
 *     larger healthy organism by appending the suffix "AB".
 *     Example: If "A" is healthy, then "A" + "AB" -> "AAB" is also healthy.
 *
 * 3.  Recursive Rule 2 (Mutagenic Stage):
 *     O -> "B" + O + "A"
 *     This rule states that if you have any healthy organism 'O', you can form a new
 *     healthy organism by wrapping it with a 'B' prefix and an 'A' suffix.
 *     Example: If "A" is healthy, then "B" + "A" + "A" -> "BAA" is also healthy.
 *
 * Any string that can be generated by starting with "A" and applying these rules
 * some number of times is considered healthy. Any other string is a MUTANT.
 *
 * -------------------------------------------------------------------------------------
 * The Solution: A Recursive Deconstruction
 * -------------------------------------------------------------------------------------
 *
 * To determine the type of a given string 'S', we must work backwards. We write a
 * recursive function, let's call it `check(S)`, that determines if 'S' is a healthy
 * organism and, if so, what type it is.
 *
 * The logic of `check(S)` mirrors the grammar rules in reverse:
 *
 * 1.  Is S == "A"?
 *     -> If yes, it matches the base case. It is of type SIMPLE.
 *
 * 2.  Does S end with "AB"?
 *     -> If yes, this suggests it might have been formed by Rule 2 (Fully-Grown). To
 *        confirm, we must recursively check if the prefix part of the string (S without
 *        the "AB" suffix) is itself a healthy organism. If `check(prefix)` is successful,
 *        then S is FULLY-GROWN.
 *
 * 3.  Does S start with 'B' and end with 'A'?
 *     -> If yes, this suggests Rule 3 (Mutagenic). We must recursively check if the
 *        middle part of the string (S without the 'B' prefix and 'A' suffix) is a
 *        healthy organism. If `check(middle)` is successful, then S is MUTAGENIC.
 *
 * 4.  What if multiple rules apply?
 *     The problem states: "If an organism were in two stages of growth at the same time
 *     the first option from the list above should be printed". This gives us a
 *     priority order: SIMPLE > FULLY-GROWN > MUTAGENIC. Our checking function must
 *     respect this order. For example, even if a string matches the pattern for a
 *     Mutagenic organism, if it ALSO matches the pattern for a Fully-Grown one,
 *     we must classify it as FULLY-GROWN.
 *
 * 5.  If none of the above conditions can deconstruct the string back to a simple "A",
 *     the string is a MUTANT.
 *
 * The implementation requires a recursive function that checks these conditions in the
 * specified order of priority. Memoization (DP) can be used to optimize the recursive
 * checks on substrings to avoid re-computation.
 *
*/

#include "../debug.h"
#include "../../aux.h"
#include <bits/stdc++.h>




bool is_simple(const std::string& s) {
  return s.length() == 1 && s == "A";
}

bool is_fully_grown(const std::string& s) {
  return s.length() >= 3 && s.substr(s.size() - 2, s.size()) == "AB";
}

bool is_mutagenic(const std::string& s) {
  return s.length() >= 3 && s.front() == 'B' && s.back() == 'A';
}

bool is_healthy(const std::string& s, int l, int r) {
  if(is_simple(s)) return true;
  if(is_fully_grown(s)) {
    return is_healthy(s.substr(0, s.size() - 2), l, r);
  }
  if(is_mutagenic(s)) {
    return is_healthy(s.substr(1, s.size() - 2), l, r);
  }
  return false;
}


namespace algorithms::onlinejudge::strings::cellular_structure
{

    void submit(std::optional<char*> file, bool debug_mode)
    {
        if (file.has_value()) {
          // Attempt to reopen stdin with the provided file
          if (std::freopen(file.value(), "r", stdin) == nullptr) {
            // If freopen fails, throw an exception with a more detailed error message
            std::string name = file.value();
            std::string errorMessage = 
              "Failed to open file: " + name +
              " with error: " + std::strerror(errno);
            throw std::ios_base::failure(errorMessage);
          }
        }

        int t_cases;
        scanf("%d", &t_cases);
        while(t_cases--) {
          std::string s;
          while_read(s);
          if(is_healthy(s, 0, s.size())) {
            if(is_simple(s)) {
              printf("SIMPLE\n");
            } else if(is_fully_grown(s)) {
              printf("FULLY-GROWN\n");
            } else if(is_mutagenic(s)) {
              printf("MUTAGENIC\n");
            }
          } else {
            printf("MUTANT\n");
          }
        }
    }
}