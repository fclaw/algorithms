{
    "sourceFile": "algorithms/tree.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1715581270944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1715581297643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n \n+#include <vector>\n \n  struct TreeNode \n  {\n     int val;\n@@ -177,7 +178,6 @@\n     }\n }\n \n int deepestLeavesSum(TreeNode* root) \n-{\n-           \n+{          \n }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1715581270944,
            "name": "Commit-0",
            "content": "\n\n struct TreeNode \n {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n };\n  \nstd::vector<int> treePath(TreeNode* root)\n{\n   \n  auto findPathSums = [](auto&& findPathSums, TreeNode* node, int currentSum, std::vector<int>& pathSums) \n  {\n    if (node == nullptr)\n        return; // If the node is null, return\n    currentSum += node->val; // Add the current node's value to the path sum\n    // If this is a leaf node (no children), store the path sum\n    if (node->left == nullptr && \n        node->right == nullptr) \n    {\n        pathSums.push_back(currentSum);\n    } else \n    {\n        // Recursively find path sums for left and right children\n        findPathSums(findPathSums, node->left, currentSum, pathSums);\n        findPathSums(findPathSums, node->right, currentSum, pathSums);\n    }\n  };\n\n  std::vector<int> paths = {};\n  findPathSums(findPathSums, root, 0, paths);\n  return paths;\n}\n\nint minDepth(TreeNode* root)\n{\n    auto findPaths = [](auto&& findPathSums, TreeNode* node, int currentSum, std::vector<int>& paths) \n  {\n    if (node == nullptr)\n        return; // If the node is null, return\n    currentSum += 1; // Add the current node's value to the path sum\n    // If this is a leaf node (no children), store the path sum\n    if (node->left == nullptr &&\n        node->right == nullptr) \n    {\n        paths.push_back(currentSum);\n    } else \n    {\n        // Recursively find path sums for left and right children\n        findPathSums(findPathSums, node->left, currentSum, paths);\n        findPathSums(findPathSums, node->right, currentSum, paths);\n    }\n  };\n\n  std::vector<int> paths = {};\n  findPaths(findPaths, root, 0, paths);\n  std::min_element(paths.begin(), paths.end());\n  return 1;\n}\n\nvector<int> inorderTraversal(TreeNode* root)\n{\n    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n    {\n        if (node == nullptr)\n          return;\n        else if(node->left == nullptr && \n                node->right == nullptr)\n          xs.push_back(node->val);\n        else\n        {\n           traverse(traverse, node->left, xs);\n           xs.push_back(node->val);\n           traverse(traverse, node->right, xs);\n        }  \n    };\n    std::vector<int> xs = {};\n    traverse(traverse, root, xs);\n    return xs;\n}\n\nvector<int> postorderTraversal(TreeNode* root)\n{\n    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n    {\n        if (node == nullptr)\n          return;\n        else if(node->left == nullptr && \n                node->right == nullptr)\n          xs.push_back(node->val);\n        else\n        {\n           traverse(traverse, node->left, xs);\n           traverse(traverse, node->right, xs);\n           xs.push_back(node->val);\n        }  \n    };\n    std::vector<int> xs = {};\n    traverse(traverse, root, xs);\n    return xs;\n}\n\nvector<int> preorderTraversal(TreeNode* root)\n{\n    auto traverse = [](auto&& traverse, TreeNode* node, std::vector<int>& xs)\n    {\n        if (node == nullptr)\n          return;\n        else if(node->left == nullptr && \n                node->right == nullptr)\n          xs.push_back(node->val);\n        else\n        {\n           xs.push_back(node->val);\n           traverse(traverse, node->left, xs);\n           traverse(traverse, node->right, xs);\n        }  \n    };\n    std::vector<int> xs = {};\n    traverse(traverse, root, xs);\n    return xs;\n}\n\nbool treesEquality(TreeNode* first, TreeNode* second)\n{\n    if(first == nullptr && \n       second == nullptr)\n       return true;\n    else \n    {\n        return first->val == second->val && \n               treesEquality(first->left, second->left) && \n               treesEquality(first->right, second->right);\n    }\n}\n\nbool isSubtree(TreeNode* root, TreeNode* sub)\n{\n    if(root == nullptr)\n      return false;\n    else if(treesEquality(root, sub))\n      return true;\n    else\n      return isSubtree(root->left, sub) || \n             isSubtree(root->right, sub);\n}\n\nint diameterOfBinaryTree(TreeNode* root, int& diameter)\n{\n    if(root == nullptr)\n      return 0;\n    else \n    {\n        auto left = diameterOfBinaryTree(root->left, diameter);\n        auto right  = diameterOfBinaryTree(root->right, diameter);\n        diameter = max(diameter, left + right);\n        return 1 + max(left, right);\n    } \n}\n\nTreeNode* invertTree(TreeNode* root) \n{\n    if(root == nullptr)\n      return nullptr;\n    else\n    {\n        auto tmp = root->left;\n        root->left = root->right;\n        root->right = tmp;\n        invertTree(root->left);\n        invertTree(root->right);\n        return root;\n    }\n}\n\nint deepestLeavesSum(TreeNode* root) \n{\n           \n}"
        }
    ]
}